«IMPORT iaml»

/**
 * Calling an operation.
 */
«EXTENSION template::GeneratorExtensions»

/* default: don't know what to do */
«DEFINE callOperation(Boolean php, Boolean inStoreDb) FOR model::Wire»
	«throwException("Unknown wire to expand: " + this)»
«ENDDEFINE»

«DEFINE callOperation(Boolean php, Boolean inStoreDb) FOR model::Action»
	«throwException("Unknown action to expand: " + this)»
«ENDDEFINE»

«DEFINE callOperation(Boolean php, Boolean inStoreDb) FOR model::wires::RunAction»
	«IF inConditionEdges.size > 0» 
		/* expand conditions */
		if («EXPAND template::conditions::Runtime::callCondition(php, inStoreDb) FOREACH inConditionEdges SEPARATOR " && "») {
			«EXPAND callOperationContents(php, inStoreDb) FOR this»
		}
	«ELSE»
		«EXPAND callOperationContents(php, inStoreDb) FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperation(Boolean php, Boolean inStoreDb) FOR model::wires::NavigateAction»
	«IF inConditionEdges.size > 0» 
		/* expand conditions */
		if («EXPAND template::conditions::Runtime::callCondition(php, inStoreDb) FOREACH inConditionEdges SEPARATOR " && "») {
			«EXPAND callOperationContents(php, inStoreDb) FOR this»
		}
	«ELSE»
		«EXPAND callOperationContents(php, inStoreDb) FOR this»
	«ENDIF»
«ENDDEFINE»

/* 
 * Run a command with some parameters.
 * RunAction: event --> operation 
 *
 * @param inStoreDb is set if we are calling operations as a result of storing a value
 * in the database. instead of defining a new function 'get_db_param(...)' and
 * using this as a parameter source,
 * we instead use '$arg0', which we expect will be set already.
 * @see callOperationsParameterSource() and StoreDbPhp::expandDomainAttributeEvents()
 * @implementation RunAction
 *		When {@model RunAction running} an {@model Operation}, the {@model ParameterEdge}s are
 *		provided in alphabetical order according to their {@model ParameterEdge#name}.
 */
«DEFINE callOperationContents(Boolean php, Boolean inStoreDb) FOR model::wires::RunAction-»
	/* eContainer == «to.eContainer» */
	
	«IF php»
		$result = null;
	«ELSE»
		var result = null;
	«ENDIF»

	«IF php»
		$result =
	«ELSE»
		result = 
	«ENDIF»

	«IF model::VisibleThing.isInstance(to.eContainer) || model::visual::Frame.isInstance(to.eContainer)-»
		«REM»VisibleThing includes InputTextField«ENDREM»
		«REM»
			is both source and target on the same frame? NOTE this
			will also return true for Event-->Operation if they are
			both on the same frame.
		«ENDREM»
		«IF php || availableInCurrentScriptAction(from, to)-»
			«REM»// on current frame (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND Parameters::callParameter(php, inStoreDb, false) FOREACH inParameterEdges.sortBy(e|e.name) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current frame (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingFrame(to).id)»', '«operationName(to)-»'
				«IF !inParameterEdges.isEmpty», «EXPAND Parameters::callParameter(php, inStoreDb, false) FOREACH inParameterEdges.sortBy(e|e.name) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingFrame(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF model::scopes::Session.isInstance(to.eContainer)-»
		«IF php || availableInCurrentScriptAction(from, to)-»
			«REM»// on current frame (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND Parameters::callParameter(php, inStoreDb, false) FOREACH inParameterEdges.sortBy(e|e.name) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current frame (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingFrame(to).id)»', '«operationName(to)-»'
				«IF !inParameterEdges.isEmpty», «EXPAND Parameters::callParameter(php, inStoreDb, false) FOREACH inParameterEdges.sortBy(e|e.name) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingFrame(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF isDomainAttribute(to.eContainer)-»
		«REM»direct field --> abstract domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF !inParameterEdges.isEmpty», «EXPAND Parameters::callParameter(php, inStoreDb, false) FOREACH inParameterEdges.sortBy(e|e.name) SEPARATOR ", "»«ENDIF»
		); 
	«ELSEIF isDomainAttributeInstance(to.eContainer)-»
		«REM»direct field --> domain attribute instance«ENDREM»
		«EXPAND template::domain::AttributeInstance::attributeInstanceCall(php, this, inStoreDb, (model::DomainAttributeInstance) to.eContainer) FOR to»;
	«ELSEIF isDomainObjectInstance(to.eContainer)-»
		«REM»direct field --> domain object instance«ENDREM»
		«EXPAND template::domain::DomainInstance::domainInstanceCall(php, this, (model::DomainObjectInstance) to.eContainer) FOR to»;
	«ELSEIF model::components::AccessControlHandler.isInstance(to.eContainer)-»
		«EXPAND template::users::AccessControlHandler::accessControlHandlerOperationCall(php, this, (model::components::AccessControlHandler) to.eContainer) FOR to»;
	«ELSEIF model::scopes::Email.isInstance(to.eContainer)-»
		«EXPAND template::emails::Email::emailOperationCall(php, this, (model::scopes::Email) to.eContainer) FOR to»;
	«ELSE-»
		alert('unknown target operation type in «to.eContainer.metaType.name»');
		«throwException("Unknown target operation type in '" + to.eContainer.metaType.name + "' (this=" + this + ")")»
	«ENDIF-»

«ENDDEFINE»

/**
 * NavigateAction: browse to a new destination.
 * We need to switch on the target, because we could navigate to many different types
 * of new destinations?
 */
«DEFINE callOperationContents(Boolean php, Boolean inStoreDb) FOR model::wires::NavigateAction»
	«EXPAND navigateTo(php, inStoreDb, this) FOR to» 
«ENDDEFINE»

«DEFINE navigateTo(Boolean php, Boolean inStoreDb, model::wires::NavigateAction wire) FOR model::ActionDestination»
	«IF php»
		$url = null;
		«EXPAND getNavigateActionDestination(php, inStoreDb, wire, true)»
		if ($url !== null) {
			// navigate to another frame
			log_message("[redirect] Redirecting to '$url'");
			server_redirect($url);
			die;
		}
	«ELSE»
		var url = null;
		«EXPAND getNavigateActionDestination(php, inStoreDb, wire, true)»	
		debug("[resume] Resuming to '" + url + "'");
		window.location = url;
		ajaxIncrement();	// prevent other events from executing
	«ENDIF»
«ENDDEFINE»

/**
 * Get the destination for the given {@model NavigateAction} and put it into
 * a variable '<code>$url</code>'.
 *
 * @param includeSession should PHPSESSID (etc) be included in the URL? Should generally be <code>true</code>
 */
«DEFINE getNavigateActionDestination(Boolean php, Boolean inStoreDb, model::wires::NavigateAction wire, Boolean includeSession) FOR model::ActionDestination»
	«throwException("Unknown NavigateAction destination: " + this)»
«ENDDEFINE»

/**
 * Resuming navigation to a EntryGate.
 */
«DEFINE getNavigateActionDestination(Boolean php, Boolean inStoreDb, model::wires::NavigateAction wire, Boolean includeSession) FOR model::components::EntryGate»
	«IF php»
		/* navigating back to resume a gate */
		// get the resume ID
		«EXPAND template::scopes::EntryGate::getEntryResumeTarget('resume')»
		if (!$resume) {
			// nowhere to resume; select somewhere random
			«EXPAND template::scopes::EntryGate::getEntryAnyTarget('resume')»
		}
		
		if ($resume != CURRENT_PAGE) {
			// navigate to another frame
			$url = "$resume.php";
			«IF includeSession»
				$url .= "?" . get_sid();		// need to pass session on server-side
			«ENDIF»
			«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»	
		}
	«ELSE»
		var url = "<?php
			/* navigating back to resume a gate */
			// get the resume ID
			«EXPAND template::scopes::EntryGate::getEntryResumeTarget('resume')»
			if (!$resume) {
				// nowhere to resume; select somewhere random
				«EXPAND template::scopes::EntryGate::getEntryAnyTarget('resume')»
			}
			
			echo $resume;
		?>.php";
		«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»
	«ENDIF»
«ENDDEFINE» 

/**
 * Resuming navigation to an ExitGate.
 */
«DEFINE getNavigateActionDestination(Boolean php, Boolean inStoreDb, model::wires::NavigateAction wire, Boolean includeSession) FOR model::components::ExitGate»
	«IF php»
		/* navigating back to resume a gate */
		// get the resume ID
		«EXPAND template::scopes::ExitGate::getExitResumeTarget('resume')»
		if (!$resume) {
			// nowhere to resume; select somewhere random
			«EXPAND template::scopes::ExitGate::getExitAnyTarget('resume')»
		}
		
		if ($resume != CURRENT_PAGE) {
			// navigate to another frame
			$url = "$resume.php";
			«IF includeSession»
				$url .= "?" . get_sid();		// need to pass session on server-side
			«ENDIF»
			«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»	
		}
	«ELSE»
		var url = "<?php
			/* navigating back to resume a gate */
			// get the resume ID
			«EXPAND template::scopes::ExitGate::getExitResumeTarget('resume')»
			if (!$resume) {
				// nowhere to resume; select somewhere random
				«EXPAND template::scopes::ExitGate::getExitAnyTarget('resume')»
			}
			
			echo $resume;
		?>.php";
		«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»	
	«ENDIF»
«ENDDEFINE» 

/**
 * Navigate to a frame.
 */
«DEFINE getNavigateActionDestination(Boolean php, Boolean inStoreDb, model::wires::NavigateAction wire, Boolean includeSession) FOR model::visual::Frame»
	«IF php»
		/* prevent infinite loops on the current frame */
		if ("«id-»" != CURRENT_PAGE) {
			// navigate to another frame
			$url = "«safeName()».php";
			«IF includeSession»
				$url .= "?" . get_sid();		// need to pass session on server-side
			«ENDIF»
			«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»	
		}
	«ELSE»
		// navigating to a new frame
		var url = "«safeName()».php";
		«EXPAND addNamedParameters(php, inStoreDb, "url") FOR wire»	
	«ENDIF»
«ENDDEFINE»

/**
 * Add any named parameters to the given URL (in $argName).
 *
 * @implementation NavigateAction,ParameterEdge
 * 		Any incoming named {@model ParameterEdge}s to a {@model NavigateAction} will be
 * 		passed along as named <code>GET</code> parameters to the destination.
 */
«DEFINE addNamedParameters(Boolean php, Boolean inStoreDb, String argName) FOR model::wires::NavigateAction»
	«IF !inParameterEdges.isEmpty»
		// add named parameters
		«FOREACH inParameterEdges.select(p|p.name != null && p.name.length != 0) AS param»
			«IF php»
			{
				$add_url = urlencode("«escapePhpString(safeNameString(param.name))»") . "=" .
					urlencode(«EXPAND Parameters::callParameter(php, inStoreDb, false) FOR param»)
					;
					
				if (strpos($«argName-», "?") === false) {
					$«argName-» .= "?" . $add_url;
				} else {
					$«argName-» .= "&" . $add_url;
				}
			}
			«ELSE»
			{
				var add_url = encodeURIComponent("«escapePhpString(safeNameString(param.name))»") + "=" +
					encodeURIComponent(«EXPAND Parameters::callParameter(php, inStoreDb, false) FOR param»)
					;
					
				if («argName-».indexOf("?") == -1) {
					«argName-» += "?" + add_url;
				} else {
					«argName-» += "&" + add_url;
				}
			}
			«ENDIF»
		«ENDFOREACH»
	«ENDIF»
«ENDDEFINE»

/**
 * Assumes that there is a function call waiting in 'function_queue'.
 * This function will be executed with the response as a parameter.
 */
«DEFINE callRemoteOperation(Boolean php, Boolean inStoreDb) FOR model::wires::RunAction-»
	«IF inParameterEdges.size > 0» 
		var arg0 = «EXPAND Parameters::callParameter(php, inStoreDb, false) FOR inParameterEdges.get(0)»;
	«ELSE»
		var arg0 = null;	/* no parameter */
	«ENDIF»
	«IF inParameterEdges.size > 1»
		var arg1 = «EXPAND Parameters::callParameter(php, inStoreDb, false) FOR inParameterEdges.get(1)»;
	«ELSE»
		var arg1 = null;	/* no parameter */
	«ENDIF»
	call_remote_event(
		'«safeNameString(containingFrame(to).id)»', 
		'«operationName(to)-»',
		arg0,
		arg1,
		function_queue
	);
«ENDDEFINE»
