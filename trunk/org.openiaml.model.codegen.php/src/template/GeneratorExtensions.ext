import iaml;

extension metamodel::Extensions reexport;

frameTitle(model::InternetApplication this) :
	if name == null || name == "" then "(untitled application)" else name.toFirstUpper();

frameTitle(model::visual::Frame this) :
	if name == null || name == "" then id else name;

formName(model::visual::InputForm this) :
	if (name == null || name == "") then "(untitled form)" else name;
	
textFieldName(model::visual::InputTextField this) :
	if (name == null || name == "") then "(untitled field)" else name;

buttonName(model::visual::Button this) :
	if (name == null || name == "") then "Submit Query" else name;
	
simpleName(model::NamedElement this) :
	safeNameString(name);
simpleName(emf::EObject this) :
	safeName();

/**
 * Get a safe string name of the given element; that is, one that only consists
 * of alpha-numeric characters, and the underscore character.
 *
 * <p>NOTE: if you are getting this with a newly created model element, the ID
 * may not be getting generated automatically in XXXFactoryImpl. See issue 165.
 *
 * @pseudocode
 *   if id = null then
 *     throw exception
 *   else
 *     return element.id.replace('[^A-Za-z0-9]', '_')
 *   endif
 */	
safeName(model::GeneratedElement this) :
	if (id == null) then
		throwException("Cannot get the safeName of an element with no ID: " + this)
	else
		safeNameString(id);

safeName(emf::EObject this) :
	throwException("Cannot get the safeName of an EObject: " + this);

safeNameString(String s) :
	s.replaceAll("[^A-Za-z0-9]", "_");

escapeString(String s) :
	s.replaceAll("[\"]", "\\\"");
	
/* TODO not a complete encoding, misses \r\n\t\v\f\[0-7]{1,3}\x[0-9A-Fa-f]{1,2} and perhaps unicode too */
escapePhpString(String s):
	s.replaceAll("[\\\\]", "\\\\").replaceAll("[\"]", "\\\"").replaceAll("[$]", "\\$");

// TODO this should be used everywhere
/**
 * Escape an arbitrary unsafe string so it may be used within HTML output.
 */
escapeHtmlString(String s) :
	s.replaceAll("&", "&amp;").replaceAll("\"", "&quot;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");

escapeXmlString(String s) :
	escapeHtmlString(s).replaceAll("'", "&apos;");

operationName(model::WireDestination this) : 
	throwException("Invalid operation: " + this);

operationName(model::ActionDestination this) : 
	throwException("Invalid operation: " + this);

operationName(model::Operation this) :
	safeName(this);

conditionName(emf::EObject this ) :
	throwException("Invalid condition: " + this);

conditionName(model::Condition this) :
	safeName(this);
	
attributeName(model::DomainAttribute this) :
	safeNameString(name);

attributeName(model::DomainAttributeInstance this) :
	safeNameString(name);
	
attributeName(Void v) :
	throwException("Invalid attribute (Void)");

isXPath(model::DynamicApplicationElementSet this) :
	query.startsWith("xpath:");
	
/**
 * Get the {@model Frame} which can contain the given {@model Operation}.
 */
model::visual::Frame frameContainingOperation(model::visual::Frame this) :
	this;
	
model::visual::Frame frameContainingOperation(model::NamedElement this) :
	if (eContainer == null)
		then null
		else frameContainingOperation(eContainer);

/* any frame in the Session will contain all the operations for the Session */
model::visual::Frame frameContainingOperation(model::scopes::Session this) :
	scopes.typeSelect( model::visual::Frame ).first();

/* default for any EObject */
model::visual::Frame frameContainingOperation(emf::EObject this) :
	null;

/* is [target] on the same frame as [source]? */ 
onCurrentFrame(model::WireSource source, model::WireDestination target) :
	containingFrame(source) != null && 
	containingFrame(source) == containingFrame(target);

onCurrentFrame(emf::EObject source, model::WireDestination target) :
	containingFrame(source) != null && 
	containingFrame(source) == containingFrame(target);

onCurrentFrameAction(emf::EObject source, model::ActionDestination target) :
	containingFrame(source) != null && 
	containingFrame(source) == containingFrame(target);

/* is [target] in the same session as [source]? */ 
onCurrentSession(model::WireSource source, model::WireDestination target) :
	containingSession(source) != null && 
	containingSession(source) == containingSession(target);

/**
 * is [target] available in the same _script_ as [source]?
 * this is true if onCurrentFrame() is true, or
 * it is an operation that will also be included in the current frame.
 *
 * all operations contained within a session are NOT available to all
 * elements outside that session.
 *
 * all operations and properties that are contained with an Email
 * are NOT available for the current script.
 *
 * this is based on allContainerOperations() and possibleParentOperations().
 *
 * @implementation Operation
 *		An {@model Operation} will <strong>only</strong> be executed on the client-side
 *		if it is contained within the same {@model Frame} as the current
 *		{@model Frame}.
 */
availableInCurrentScript(model::WireSource source, model::WireDestination target) :
	containingEmail(target) == null && 
	(onCurrentFrame(source, target));
		
availableInCurrentScriptAction(model::ActionSource source, model::ActionDestination target) :
	containingEmail(target) == null &&
	(onCurrentFrameAction(source, target));

/**
 * Get all the operations that may be referenced in a container. In particular:
 * - Any operations in the frame/container
 * - Any operations in the elements contained in this frame/container
 * - Any operations contained in the direct parent scope (if any)
 */
List[model::Operation] allContainerOperations(model::Scope this) :
	operations.toSet().union( scopes.allContainerOperations() )
		.union( elements.allContainerOperations() )
		.union( possibleParentOperations(eContainer) )
		.select(o | operationUsed(o));

List[model::Operation] allContainerOperations(model::scopes::Email this) :
	operations.toSet().union( scopes.allContainerOperations() )
		.union( elements.allContainerOperations() )
		.union( labels.allContainerOperations() )
		.union( buttons.allContainerOperations() )
		.union( possibleParentOperations(eContainer) )
		.select(o | operationUsed(o));

List[model::Operation] allContainerOperations(model::visual::Frame this) :
	operations.toSet().union( scopes.allContainerOperations() )
		.union( elements.allContainerOperations() )
		.union( children.allContainerOperations() )
		.union( possibleParentOperations(eContainer) )
		.select(o | operationUsed(o));

List[model::Operation] allContainerOperations(model::VisibleThing this) :
	operations.toSet().union( children.allContainerOperations() )
		.union( possibleParentOperations(eContainer) )
		.select(o | operationUsed(o));
		
List[model::Operation] allContainerOperations(model::ApplicationElement this) :
	operations.select(o | operationUsed(o));

List[model::Operation] allContainerOperations(model::ContainsOperations this) :
	operations.select(o | operationUsed(o));

List[model::Operation] allContainerOperations(model::InternetApplication this) :
	 operations.toSet()
		.union( scopes.allContainerOperations() )
	 	.union( children.allContainerOperations() )
	 	.select(o | operationUsed(o));	 
		
/** All of the ApplicationElementProperties stored within this InternetApplication */
List[model::Property] allProperties(model::InternetApplication this) :
	eAllContents.typeSelect(model::Property);

/* for a frame that is part of a session/scope */
possibleParentOperations(model::scopes::Session this ) :
	operations;

possibleParentOperations(emf::EObject this ) :
	{};

/* get the start node for an operation */
startNode(model::CompositeOperation this) :
	nodes.typeSelect(model::operations::StartNode).first();

startNodeCondition(model::CompositeCondition this) :
	nodes.typeSelect(model::operations::StartNode).first();

/* get the next execution flow for a Node that has passed */
passedExectionFlow(model::ExecutionEdgesSource this) :	
	outExecutions.selectFirst( e | isPassFlow(e) );

/* get the next execution flow for a Node that has failed */
failedExectionFlow(model::ExecutionEdgesSource this) :
	outExecutions.selectFirst( e | isFailFlow(e) );

hasFailFlow(model::ExecutionEdgesSource this) :
	getFailFlows(this).size > 0; 
hasPassFlow(model::ExecutionEdgesSource this) :
	getPassFlows(this).size > 0;

/**
 * @implementation ExecutionEdge
 *		A "failure" {@model ExecutionEdge} is any edge with a lowercase {@model ExecutionEdge#name} starting
 *		with 'n' or 'f'.
 * @implementation ExecutionEdge
 *		A "passing" {@model ExecutionEdge} is any edge that is not a "failure" edge.
 */
isFailFlow(model::ExecutionEdge e) :
	e.name != null && (e.name.toLowerCase().startsWith("n") || e.name.toLowerCase().startsWith("f"));
isPassFlow(model::ExecutionEdge e) :
	!isFailFlow(e);

/* get failed/passed out edges from a given DecisionCondition */
getFailFlows(model::ExecutionEdgesSource this):
	outExecutions.select( e | isFailFlow(e) );

getPassFlows(model::ExecutionEdgesSource this):
	outExecutions.select( e | isPassFlow(e) );

/** does this operation have a "fail" edge? */
getFailEdge(model::CompositeOperation this) :
	outActions.selectFirst( e | e.isFailEdge() ) ;

isFailEdge(model::Action this ) :
	false;
	
isFailEdge(model::wires::NavigateAction this ) :
	name == "fail" ;

isFailEdge(model::wires::RunAction this ) :
	name == "fail" ;

/**
 * Get the containing session of the given element, or null if none.
 *
 * @pseudocode
 *   if container == null
 *		then return null 
 *		else return containingSession(container)
 */	
model::scopes::Session containingSession(emf::EObject this) :
	if (eContainer == null)
		then null
		else containingSession(eContainer);

/**
 * Get the containing session of the given element, or null if none.
 *
 * @pseudocode
 *   return self
 */		
model::scopes::Session containingSession(model::scopes::Session this) :
	this;
	
/**
 * Get the containing session of the given element, or null if none.
 *
 * @pseudocode
 *   return null
 */	
model::scopes::Session containingSession(model::InternetApplication this) :
	null;

model::scopes::Email containingEmail(model::scopes::Email this) :
	this;

model::scopes::Email containingEmail(emf::EObject this) :
	if (eContainer == null) then
		null
	else
		containingEmail(eContainer);

/** get the containing Scope of the given element, or null if none */
model::Scope containingScope(emf::EObject this) :
	null;

model::Scope containingScope(model::NamedElement this) :
	containingScope(eContainer);
	
model::Scope containingScope(model::Scope this) :
	this;
	
model::Scope containingScope(model::InternetApplication this) :
	null;

model::DomainStore getDomainStore(model::DomainStore this) :
	this;
model::DomainStore getDomainStore(model::DomainObject this) :
	getDomainStore(eContainer);
model::DomainStore getDomainStore(model::DomainAttribute this) :
	getDomainStore(eContainer);
model::DomainStore getDomainStore(emf::EObject this) :
	null;

model::DomainObject getDomainObject(model::DomainObject this) :
	this;
model::DomainObject getDomainObject(model::DomainAttribute this) :
	getDomainObject(eContainer);
model::DomainObject getDomainObject(emf::EObject this) :
	null;
	
/** for a given set operation, should we be calling
  additional event triggers? */
shouldExpandEventTriggers(model::PrimitiveOperation this ) :
	getOperationName( eContainer ) == "update";
	
shouldExpandEventTriggersServer(model::PrimitiveOperation this ) :
	shouldExpandEventTriggers(this);
	
getOperationName(model::Operation this) :
	name;
getOperationName(emf::EObject this) :
	throwException("Cannot get the operationName for an EObject: " + this);
	
isVisibleThing(emf::EObject this) :
	model::VisibleThing.isInstance(this);
isDomainAttribute(emf::EObject this) :
	model::DomainAttribute.isInstance(this);	
isDomainAttributeInstance(emf::EObject this) :
	model::DomainAttributeInstance.isInstance(this);
isDomainObjectInstance(emf::EObject this) :
	model::DomainObjectInstance.isInstance(this);
isSession(emf::EObject this) :
	model::scopes::Session.isInstance(this);	
isFrame(emf::EObject this) :
	model::visual::Frame.isInstance(this);
canBeSet(emf::EObject this) :
	isInputTextField(this) || isLabel(this);
isInputTextField(emf::EObject this) :
	model::visual::InputTextField.isInstance(this);	
isLabel(emf::EObject this) :
	model::visual::Label.isInstance(this);	

isPropertiesFile(model::DomainStore store) :
	store != null && store.type != null && store.type.toString() == "PROPERTIES_FILE";

/* get the root InternetApplication */
model::InternetApplication getRoot(emf::EObject this) :
	getRoot(eContainer);

model::InternetApplication getRoot(model::InternetApplication this) :
	this;

/** get all Conditions in the InternetApplication */
cached List[model::Condition] getAllConditions(model::InternetApplication this) :
	eAllContents.typeSelect(model::Condition)
		.select(o | conditionUsed(o));
		
/** get all Frames in the InternetApplication */
cached List[model::visual::Frame] getAllFrames(model::InternetApplication this) :
	eAllContents.typeSelect(model::visual::Frame);

/** get all Emails in the InternetApplication */
cached List[model::scopes::Email] getAllEmails(model::InternetApplication this) :
	eAllContents.typeSelect(model::scopes::Email);
	
/** get all Dynamic Element Sets in the InternetApplication */
List[model::DynamicApplicationElementSet] getAllDynamicElements(model::InternetApplication this) :
	eAllContents.typeSelect(model::DynamicApplicationElementSet);

/** get all Domain Attribute Instances in the InternetApplication */
List[model::DomainAttributeInstance] getAllDomainAttributeInstances(model::InternetApplication this) :
	eAllContents.typeSelect( model::DomainAttributeInstance );

/** get all Domain Object Instances in the InternetApplication */
List[model::DomainObjectInstance] getAllDomainObjectInstances(model::InternetApplication this) :
	eAllContents.typeSelect(model::DomainObjectInstance);

getAllDomainObjects(emf::EObject e) :
	e.eAllContents.typeSelect(model::DomainObject);

/** find all actual matches for the given DynamicApplicationSet in a given root */
List[emf::EObject] resolveDynamicSet(model::InternetApplication root, model::DynamicApplicationElementSet set) :
	JAVA org.openiaml.model.codegen.php.OawCodeGenerator.resolveDynamicSet(org.openiaml.model.model.InternetApplication, org.openiaml.model.model.DynamicApplicationElementSet);

getFailHandler(model::ActionSource this) :
	outActions.select( w | w.isFailEdge()).first();

isAutosaveOff(model::DomainAttributeInstance this) :
	autosave == false || isAutosaveOff(eContainer);

isAutosaveOff(model::DomainObjectInstance this) :
	autosave == false;
	
isAutosaveOff(emf::EObject this):
	false;

model::DomainAttribute getPrimaryKey(model::DomainAttributeInstance this) :
	if inWires.typeSelect(model::wires::NewInstanceWire).size >= 1 then
		getPrimaryKey(inWires.typeSelect(model::wires::NewInstanceWire).first())
	else if model::DomainObjectInstance.isInstance(eContainer) then
		getPrimaryKey((model::DomainObjectInstance) eContainer);

model::DomainAttribute getPrimaryKey(model::wires::NewInstanceWire this) :
	getPrimaryKey(from);

model::DomainAttribute getPrimaryKey(model::DomainObject this) :
	attributes.selectFirst( e | e.primaryKey );

model::DomainAttribute getPrimaryKey(model::DomainAttribute this) :
	getPrimaryKey(eContainer);

model::DomainAttribute getPrimaryKey(model::DomainObjectInstance this) :
	getPrimaryKey(inWires.typeSelect(model::wires::NewInstanceWire).first());

model::DomainAttribute getPrimaryKey(emf::EObject this) :
	null;

/**
 * Does this given attribute instance represent a generated primary key?
 */	
isGeneratedPrimaryKey(model::DomainAttributeInstance this) :
	isGenerated && !outExtendsEdges.to.typeSelect(model::DomainAttribute).select(a|a.primaryKey).isEmpty ;

List[model::DomainObject] allSubtypes(model::DomainObject this):
	inExtendsEdges.from.typeSelect(model::DomainObject).collect(e|allSubtypes(e)).flatten().add(this);

model::ExecutionEdgesSource castToExecutionEdgesSource(emf::EObject this) :
	(model::ExecutionEdgesSource) this;

/**
 * If this extension fails, then you are trying to find the defining attribute for an AttributeInstance
 * which isn't actually defined as an extension in the system, so we can't find the containing DomainSchema
 * for it.
 */
model::DomainAttribute getAttributeForAttributeInstance(model::DomainAttributeInstance this) :
	if outExtendsEdges.to.typeSelect(model::DomainAttribute).first() == null
		then throwException("Tried to get the parent attribute of an attribute instance that is not an extension: " + this)
		else getDefinedAttribute(outExtendsEdges.to.typeSelect(model::DomainAttribute).first());
	
/**
 * Get the defined attribute for the given attribute. That is:
 * - any attribute which extends a primary key (i.e. is a foreign key)
 * - any attribute that does not extend anything
 */
model::DomainAttribute getDefinedAttribute(model::DomainAttribute this) :
	if !outExtendsEdges.to.typeSelect(model::DomainAttribute).select(a|a.primaryKey).isEmpty
	then this
	else 
		if outExtendsEdges.to.typeSelect(model::DomainAttribute).isEmpty
		then this
		else getDefinedAttribute(outExtendsEdges.to.typeSelect(model::DomainAttribute).first());

/**
 * Get a list of all the possible execution states from the given node.
 * Cached to prevent loops causing infinite loops in logic.
 */
// for a destination that is actually a source: recurse
List[model::ExecutionEdgeDestination] allDestinations(model::ExecutionEdgesSource this, Collection[model::ExecutionEdgesSource] visited) :
	if visited.contains(this) then
		{}
	else
		outExecutions.to.toSet().addAll (
			outExecutions.to.collect(e | allDestinations(e, visited.toSet().add(this)) )
		).flatten().toSet()
	;

// default for an execution edge destination: empty
List[model::ExecutionEdgeDestination] allDestinations(Object this, Collection[model::ExecutionEdgesSource] visited) :
	{};

model::operations::JoinNode findFinalJoinNode(model::operations::SplitNode this) :
	findFinalJoinNode(outExecutions.to.selectFirst( t | findFinalJoinNode(t) != null));

model::operations::JoinNode findFinalJoinNode(emf::EObject this) :
	null;

model::operations::JoinNode findFinalJoinNode(model::ExecutionEdgesSource this) :
	findFinalJoinNode(outExecutions.to.selectFirst( t | findFinalJoinNode(t) != null));

model::operations::JoinNode findFinalJoinNode(model::operations::JoinNode this) :
	this;

/**
 * Get all necessary gates for the given scope, in order that they
 * need to be applied.
 */
/*
TODO is this necessary?
List[model::components::EntryGate] getFrameEntryGates(model::visual::Frame this) :
	getFrameEntryGates(eContainer);
*/

List[model::components::EntryGate] getFrameEntryGates(model::Scope this) :
	if entryGate == null then
		getFrameEntryGates(eContainer)
	else
		getFrameEntryGates(eContainer).toSet().add( entryGate );

List[model::components::EntryGate] getFrameEntryGates(emf::EObject this) :
	{};

/**
 * Get all exit gates that may apply to the given frame.
 * They should be provided in a reverse order by depth, i.e.
 * gates at level 3 should be provided before level 2, etc.
 * The order should also be consistent across multiple calls.
 *
 * @implementation ExitGate
 * 		{@model ExitGate}s are executed in reverse order from their
 *		depth from the {@model InternetApplication root}; however, for
 *		gates at the same node depth, order is undefined.
 */
getAllExitGates(model::visual::Frame this) :
	getRoot().eAllContents.typeSelect(model::components::ExitGate)
		.sortBy( n | -getNodeDepth(n) );

int getNodeDepth(emf::EObject this) :
	if eContainer == null 
		then 0
		else 1 + getNodeDepth(eContainer);

/** Get all possible resume targets for this gate. */
getEntryResumeTargets(model::components::EntryGate this) :
	eContainer.eContents.typeSelect(model::visual::Frame);

/** 
 * For possible exit targets, we will just select all frames.
 * Technically this should be all frames that are _not_ protected by a Gate,
 * but I don't think it matters.
 */
getExitResumeTargets(model::components::ExitGate this) :
	getRoot().eAllContents.typeSelect(model::visual::Frame);

/**
 * Get all conditions which the server needs to keep track of, and 
 * the client needs to be updated.
 * <strong>All of these operations need to be consequence-free.</strong>
 */
List[model::Condition] getClientSideCacheConditions(model::InternetApplication this) :
	eAllContents.typeSelect(model::PrimitiveCondition)
		.select(o | model::DomainObjectInstance.isInstance(o.eContainer))
		.select(o | conditionUsed(o));

/**
 * Get all properties which the server needs to keep track of, and 
 * the client needs to be updated.
 */
List[model::Property] getClientSideCacheProperties(model::InternetApplication this) :
	eAllContents.typeSelect(model::DomainObjectInstance)
		.select(o | o.results != null)
		.results.toSet().
	addAll(eAllContents.typeSelect(model::VisibleThing).properties.toSet());

/**
 * Should the given exit gate be activated/enabled on the given frame?
 */
exitGateNeedsActivating(model::components::ExitGate gate, model::visual::Frame frame) :
	frame.eContainer != null &&
	(frame.eContainer.eContents.contains( gate ) /* we aren't exiting if we are in the same scope */
		|| exitGateNeedsActivatingRecurse(gate, frame.eContainer));

exitGateNeedsActivatingRecurse(model::components::ExitGate gate, model::Scope scope) :
	scope.eContainer != null && 
	(scope.eContainer.eContents.contains( gate )
		|| exitGateNeedsActivatingRecurse(gate, scope.eContainer));

exitGateNeedsActivatingRecurse(model::components::ExitGate gate, emf::EObject obj) :
	false;

/**
 * Does the given exit gate need to block access to the given frame if necessary?
 * This should return false if the gate is contained in the parent scope or session
 * of the frame, or likewise.
 */
exitGateNeedsToRedirect(model::components::ExitGate gate, model::visual::Frame frame) :
	exitGateNeedsToRedirectRecurse(gate, frame);
		
exitGateNeedsToRedirectRecurse(model::components::ExitGate gate, model::Scope scope) :
	if scope.eContents.contains(gate) 
		then false		// we're in the same scope; don't need to redirect
		else 
			if scope.eContainer == null 
				then true		// we're not within any possible scope
				else exitGateNeedsToRedirectRecurse(gate, scope.eContainer);
					// otherwise check the scope's container 

exitGateNeedsToRedirectRecurse(model::components::ExitGate gate, model::InternetApplication root) :
	true;
exitGateNeedsToRedirectRecurse(model::components::ExitGate gate, emf::EObject obj) :
	true;

/**
 * Get the containing parent Map of the given point, or <code>null</code>
 * if there is none.
 */
model::visual::Map getParentMap(emf::EObject this) :
	if eContainer == null 
		then null
		else getParentMap(eContainer);

model::visual::Map getParentMap(model::visual::Map this) :
	this;
	
isDomainObjectInstanceResults(model::Property this) :
	model::DomainObjectInstance.isInstance(eContainer) 
		&& ((model::DomainObjectInstance) eContainer).results == this;

/**
 * Is the given type numeric?
 * This returns true if this type is, or is recursively restricted, from
 * 		<code>http://www.w3.org/2001/XMLSchema#decimal</code>.
 */
boolean isNumeric(xsd::XSDSimpleTypeDefinition this) :
	uRI == "http://www.w3.org/2001/XMLSchema#decimal"
	|| (baseTypeDefinition != null && isNumeric(baseTypeDefinition));

operationUsed(model::Operation this) :
	!(inActions.isEmpty && inExecutions.isEmpty && inFlows.isEmpty && inWires.isEmpty); 

conditionUsed(model::Condition this) :
	!(outConditionEdges.isEmpty && outFlows.isEmpty && outWires.isEmpty);

/**
 * Get the containing {@model UserStore} for this given object, or <code>null</code>
 * if there is none.
 */
model::users::UserStore getContainingUserStore(model::users::UserStore this) :
	this;

model::users::UserStore getContainingUserStore(emf::EObject this) :
	if eContainer == null
		then null
		else getContainingUserStore(eContainer);

/**
 * Get the current version of the IAML code generation platform.
 */
String iamlVersion() :
	JAVA org.openiaml.model.codegen.php.OawCodeGenerator.getIamlVersion();

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540
 * to use: «EXPAND exception FOR throwException("Your message goes here")»
 * AND add this anywhere in your template file: (very important)

«DEFINE exception FOR Object»
«ENDDEFINE»
   
 */
String throwException(String message) :
	JAVA org.openiaml.model.codegen.php.OawCodeGenerator.throwException(java.lang.String);

String _instrument(String destination, String filename, String location) :
	JAVA org.openiaml.model.codegen.php.coverage.InstrumentOawCode.instrument(java.lang.String, java.lang.String, java.lang.String);
