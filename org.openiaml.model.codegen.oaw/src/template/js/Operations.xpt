/**
 * Client-side operations.
 */
«IMPORT iaml»

/* expand EventTriggers when they are attached to a child. */
/* perhaps a better way of doing this would be to create a secondary model (using model extensions)
   which is then used to generate the application more straightforward. */
/* or even iaml --> [phpModel] --> phpOutput, although this reduces little complexity */
«EXTENSION template::GeneratorExtensions»

/* we are in an input element, and we have to register event handlers */
/* the event handlers are not actually defined here - they have to be defined elsewhere in the page */
«DEFINE expandEventTriggers(String type) FOR model::EventTrigger»
	«IF name==type»
		«REM»the Page call worries about which ones to place where«ENDREM»
		«EXPAND callOperations(false) FOREACH outEdges»
	«ENDIF»
«ENDDEFINE»

/* implicit triggers for a button: navigate, run instance wires */
«DEFINE expandImplicitEventTriggersButton FOR model::WireEdge»
«ENDDEFINE»

«DEFINE expandImplicitEventTriggersButton FOR model::wires::NavigateWire»
	«IF (name == "click" || name == "onClick")»
		/* expanding implicit trigger (navigate) */
		«EXPAND callOperations(false) FOR this»
	«ENDIF» 
«ENDDEFINE»
«DEFINE expandImplicitEventTriggersButton FOR model::wires::RunInstanceWire»
	«IF (name == "click" || name == "onClick")»
		/* expanding implicit trigger (run) */
		«EXPAND callOperations(false) FOR this»
	«ENDIF» 
«ENDDEFINE»

/* if we are expanding inline a function already */
«DEFINE expandEventTriggersInline FOR emf::EObject»
	// cannot expand for non-event object
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::ContainsEventTriggers»
	«EXPAND expandEventTriggersInline FOREACH eventTriggers»
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::EventTrigger»
	// expanding inline event trigger «name»
	«IF name=="edit"»
		«EXPAND callOperations(true) FOREACH outEdges»
	«ELSEIF name=="access"»
		// we don't expand 'access' events inline
	«ELSE»
		«EXPAND exception FOR throwException("Unknown client-side event trigger: " + this)»
	«ENDIF»
«ENDDEFINE»

/* default: don't know what to do with a wire */
«DEFINE callOperations(Boolean inline) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Unknown wire edge connected to edit trigger: " + this)»
«ENDDEFINE»

/* 
 * run a command with some parameters. this could be in inline JS or a JS block.
 * RunInstanceWire: event --> operation 
 */
«DEFINE callOperations(Boolean inline) FOR model::wires::RunInstanceWire-»
	/* eContainer == «to.eContainer» */
	
	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		/* expand conditions */
		if («EXPAND Conditions::conditionWires(this, inline) FOREACH inEdges.typeSelect(model::wires::ConditionWire) SEPARATOR " && "») {
	«ENDIF»

	«IF to.eContainer.metaType.superTypes.contains( model::VisibleThing )-»
		«REM»VisibleThing includes InputTextField and Page«ENDREM»
		«REM»
			is both source and target on the same page? NOTE this
			will also return true for Event-->Operation if they are
			both on the same page.
		«ENDREM»
		«IF onCurrentPage(from, to)-»
			«REM»// on current page (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND callOperationParameters(this, inline) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current page (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingPage(to).id)»', '«operationName(to)-»'
				«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingPage(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF isDomainAttribute(to.eContainer)-»
		«REM»direct field --> domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
		); 
	«ELSEIF isDomainAttributeInstance(to.eContainer)-»
		«REM»direct field --> domain attribute instance«ENDREM»
		«EXPAND operationDomainAttributeInstance(inline, this, (model::DomainAttributeInstance) to.eContainer) FOR to»
	«ELSEIF isDomainObjectInstance(to.eContainer)-»
		«REM»direct field --> domain object instance«ENDREM»
		«EXPAND operationDomainObjectInstance(inline, this, (model::DomainObjectInstance) to.eContainer) FOR to»
	«ELSE-»
		alert('unknown target operation type in «to.eContainer.metaType.name»');
		«EXPAND exception FOR throwException("Unknown target operation type in '" + to.eContainer.metaType.name + "' (this=" + this + ")")»
	«ENDIF-»

	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE operationDomainAttributeInstance(Boolean inline, model::wires::RunInstanceWire wire, model::DomainAttributeInstance attribute) FOR model::WireEdgeDestination»
	«EXPAND exception FOR throwException("Unexpected domain attribute run instance wire destination: " + this)»
«ENDDEFINE»
«DEFINE operationDomainAttributeInstance(Boolean inline, model::wires::RunInstanceWire wire, model::DomainAttributeInstance attribute) FOR model::Operation»
	/* domain attribute instance: wire = «wire», attribute = «attribute», this = «this» */
	«IF name=="save"»
		«REM»"save" operation for DomainAttribute«ENDREM»
		save_queued_store_domain_attribute('«safeNameString(attribute.id)»');
	«ELSE»
		«IF isAutosaveOff(attribute)»
			«REM»queue it up for hopefully saving it later«ENDREM»
			queue_store_domain_attribute_«safeNameString(attribute.id)»(
				«EXPAND callOperationParameters(wire, inline) FOREACH wire.inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»
				«IF wire.inEdges.typeSelect(model::wires::ParameterWire).size > 1»
					«EXPAND exception FOR throwException("Cannot have more than one incoming parameter for a DomainAttributeInstance: " + this)»
				«ENDIF»
			);
		«ELSE»
			«REM»set it right now«ENDREM»
			store_domain_attribute_«safeNameString(attribute.id)»(
				«EXPAND callOperationParameters(wire, inline) FOREACH wire.inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»
				«IF wire.inEdges.typeSelect(model::wires::ParameterWire).size > 1»
					«EXPAND exception FOR throwException("Cannot have more than one incoming parameter for a DomainAttributeInstance: " + this)»
				«ENDIF»
			);
		«ENDIF»
	«ENDIF» 
«ENDDEFINE»

«DEFINE operationDomainObjectInstance(Boolean inline, model::wires::RunInstanceWire wire, model::DomainObjectInstance object) FOR model::WireEdgeDestination»
	«EXPAND exception FOR throwException("Unexpected domain attribute run instance wire destination: " + this)»
«ENDDEFINE»
«DEFINE operationDomainObjectInstance(Boolean inline, model::wires::RunInstanceWire wire, model::DomainObjectInstance object) FOR model::Operation»
	/* domain object instance: wire = «wire», object = «object», this = «this» */
	«IF name=="save"»
		«REM»"save" operation for DomainAttribute«ENDREM»
		save_queued_store_domain_object('«safeNameString(object.id)»');
	«ELSE»
		«EXPAND exception FOR throwException("Cannot expand a non-save operation for DomainObjectInstance: " + this)»
	«ENDIF» 
«ENDDEFINE»

«DEFINE callOperations(Boolean inline) FOR model::wires::NavigateWire-»
	// navigating to a new page
	var url = "«safeName(to)».php";
	debug("Redirecting to '" + url + "'");
	window.location = url;
«ENDDEFINE»

/* ditto: check or error? */
«DEFINE callOperationParameters(model::WireEdge wire, Boolean inline) FOR model::wires::ParameterWire»
	«EXPAND callOperationParametersSource(wire, inline) FOR from»
«ENDDEFINE»

/* ditto: check or error? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::WireEdgesSource»
	«EXPAND exception FOR throwException("Unknown parameter wire source: " + this)»
«ENDDEFINE»

/* text fields can be a parameter source: it refers to their 'fieldValue' property */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::visual::InputTextField»
	«IF getFieldValue(this) != null»
		«EXPAND callOperationParametersSource(wire, inline) FOR getFieldValue(this)»
	«ELSE»
		«EXPAND exception FOR throwException("No 'fieldValue' property found in the InputTextField '" + this + "', which is being used as a Parameter source.")»
	«ENDIF» 
«ENDDEFINE»

/* what is the runtime value of the parameter? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::ApplicationElementProperty»
	/* wire = «wire», from = «wire.from», to = «wire.to» */
	«IF name == "fieldValue"»
		«REM»where is this value stored? is it available on the current page?«ENDREM»
		«IF onCurrentPage(wire.from, this)» 
			document.getElementById('«safeName(eContainer)»').value
		«ELSE»
			«REM»
				it's not on the current page. it could be anywhere!
				but we want it NOW, so we can't just ask the 
				server. we have to find out where it is.
			«ENDREM»			
			«EXPAND remoteParameterSource(false, wire, inline, this) FOR this.eContainer-»
		«ENDIF»
	«ELSE»
		get_application_element_property("«safeName()-»")
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::StaticValue»
	"«value-»" /* static value "«name-»" */
«ENDDEFINE»

/* we are in JS mode. TODO document when we are switching in/out of it */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::DynamicApplicationElementSet»
	/* dynamic element set "«name-»" */
	get_dynamic_elements_«safeName()-»()
«ENDDEFINE»

/* we are in JS mode. TODO document when we are switching in/out of it */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::visual::Page»
	/* Page "«name-»" */
	new Visual_Page("«id-»", "«name-»")
«ENDDEFINE»

/* a remote data source */
«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR emf::EObject»
	«EXPAND exception FOR throwException("Cannot find a remote parameter source for " + this)»
«ENDDEFINE»

«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::visual::InputTextField»
	«REM»
		TODO we are trying to find the remote parameter source for a field that isn't on the current page! what are we supposed to do??
	«ENDREM»
	/* throwJavascriptException("I don't know how to find the remote parameter source for a field that isn't on the current page.") */
	null
«ENDDEFINE»

«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::DomainAttribute»
	«IF isPropertiesFile(getDomainStore(this))»
		«EXPAND remoteParameterSourceProperties(require, wire, inline, property) FOR this»
	«ELSE»
		«EXPAND remoteParameterSourceDatabase(require, wire, inline, property) FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE remoteParameterSourceProperties(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::DomainAttribute»
	<?php 
		// remote parameter source from a .properties file
		$db_type = "FileDomainObject";
		«IF model::DomainStore.isInstance(getDomainStore(this))»
			$db_name = "«getDomainStore(this).file-»";
		«ELSEIF model::InternetApplication.isInstance(getDomainStore(this))»
			$db_name = "internet_application.properties";
		«ELSE»
			«EXPAND exception FOR throwException("Remote parameter source '" + getDomainStore(this) + "' was not a DomainStore or InternetApplication.")»
		«ENDIF»
		$row_name = "«safeNameString(this.name)-»";
		$properties = load_properties($db_name);
		$value = get_property($properties, $row_name, null);
		«IF require»
			// the value is required
			if ($value === null) {
				throw new IamlRuntimeException("Could not fetch row '$row_name' from properties database '$db_name': no results found");
			}
		«ENDIF»
		if ($value !== null) {
			echo "\"" . htmlspecialchars($value) . "\"";
		} else {
			echo "null";	/* signifies that we shouldn't change anything */
		} 
	?>
«ENDDEFINE» 

«DEFINE remoteParameterSourceDatabase(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::DomainAttribute»
	<?php 
		// remote parameter source from a database file
		$db_type = "DomainObject";
		«IF getDomainStore(this) != null»
			$db_name = "sqlite:«safeNameString(getDomainStore(this).id)».db";
		«ELSE»
			/* default database, for attributes without stores */
			$db_name = "sqlite:internet_application.db";
		«ENDIF»
		«IF getDomainObject(this) != null»
			$table_name = "«safeNameString(getDomainObject(this).name)»";
		«ELSE»
			/* default table name, for attributes without objects */
			$table_name = "single_values";
		«ENDIF»
		$row_name = "«safeNameString(this.name)»";
		
		// TODO: put this into a function
		if (!$db_name)
			throw new IamlRuntimeException("no $db_type db found");
		if (!$table_name)
			throw new IamlRuntimeException("no $db_type table found (db=$db_name)");
		if (!$row_name)
			throw new IamlRuntimeException("no $db_type row found (table=$table_name)");
		
		// connect to the database source
		$db = new PDO($db_name) or throw_new_IamlRuntimeException("could not open $db_type db '$db_name'");
		
		// does anything exist?
		$results = $db->query("SELECT $row_name FROM $table_name") or throw_new_IamlRuntimeException("could not look for existing values in $db_type '$table_name': " .print_r($db->errorInfo(), true));
		if ($row = $results->fetch()) {
			// update
			echo "\"" . htmlspecialchars($row[$row_name]) . "\"";
		} else {
			// empty
			«IF require»
				throw new IamlRuntimeException("Could not fetch row '$row_name' from table '$table_name' from database '$db_name': no results found");
			«ELSE»
				echo "null";	/* signifies that we shouldn't change anything */
			«ENDIF»
		}		
	?> 
«ENDDEFINE» 

«DEFINE exception FOR Object»
«ENDDEFINE»