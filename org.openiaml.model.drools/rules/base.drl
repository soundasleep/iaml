/**
 * Creates 'field value' {@model Property}s and the related 'is set' {@model Condition}.
 */
#created on: 4/11/2008
package org.openiaml.model.drools.rules.base

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create empty domain schema for 'test' InternetApplication"
	when
		a : InternetApplication ( name == "test" )
		not (DomainSchema ( name=="test domain schema", eContainer == a ) )

		eval ( handler.veto( a ))

	then 
		#actions
		// DomainStore ds = (DomainStore) handler.createElement( a, ModelPackage.eINSTANCE.getDomainStore(), ModelPackage.eINSTANCE.getInternetApplication_DomainStores() );
		// ds.setIsGenerated(true);
		// ds.setGeneratedBy(a);
		
		DomainSchema ds = handler.generatedDomainSchema( a, a );
		handler.setName(ds, "test domain schema");
		
		queue.add(ds, drools); // possibly infer new knowledge (this is necessary)
		
		# a schema also requires a DomainSource
		DomainSource source = handler.generatedDomainSource(a, a);
		handler.setName(source, "test domain schema source");
		queue.add(source, drools);
		
		SchemaEdge edge = handler.generatedSchemaEdge(a, a, source, ds);
		queue.add(edge, drools); 
		
end

/**
 * Since an InputForm can not yet support having a fieldValue accessible at
 * runtime (although in the future, this could be something like the title 
 * of the InputForm: TODO), we prevent the fieldValue from even being created
 * to prevent a target onAccess.init using a fieldValue that can't ever be
 * completed.
 *
 * <p>A DomainIterator also can not have a fieldValue, because it doesn't make
 * any sense at the moment. Both DomainIterator and InputForm should have this
 * incorrect inheritance of Changeable removed.
 *
 * @inference Changeable,Property 
 *		A {@model Changeable} 
 * 		contains an untyped {@model Property property} named 'fieldValue'.
 * @inference Changeable,Property 
 *		If set, the {@model Changeable#defaultValue defaultValue}
 *		is used as the default value of the created {@model Changeable#fieldValue } {@model Property property}.
 * @inference InputForm
 *		{@model InputForm}s do <em>not</em> have a {@model Property property} 
 *		named 'fieldValue' created by default.
 * @inference DomainIterator
 *		{@model DomainIterator}s do <em>not</em> have a {@model Property property} 
 *		named 'fieldValue' created by default.
 */
rule "Create field value for Changeable (untyped)"
	when
		f : Changeable( )
		not ( InputForm ( this == f ))
		not ( DomainIterator ( this == f ))
		not (prop : Property( eContainer == f, f.fieldValue != null, f.fieldValue == prop ))
			
		eval ( handler.veto( f ))
		
	then
		Property fieldValue = handler.generatedPropertyFieldValue(f, f);
		handler.setName(fieldValue, "fieldValue");
		handler.setType(fieldValue, f.getType());
		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getDefaultValue() != null) {
			handler.setDefault(fieldValue, f.getDefaultValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference Condition,Property All {@model Property Properties}
 * 		will have a {@model CompositeCondition} in its container called "is set".
 */
rule "Properties will also have a related 'is set' condition (not fieldValue)"
	when
		container : ContainsConditions ( )
		containerGe : GeneratesElements ( this == container )
		value : Property ( eContainer == container, name != "fieldValue" )
		
		not ( Condition( eval(name.equals(value.getName() + " is set")), eContainer == container ))
	
		eval ( handler.veto( containerGe ))
	
	then
		CompositeCondition cond = handler.generatedCompositeCondition(containerGe, container);
		handler.setName(cond, value.getName() + " is set");
		queue.add(cond, drools);

end

/**
 * "fieldValue is set" is generated as a PrimitiveCondition, not a CompositeCondition.
 */
rule "Properties will also have a related 'is set' condition (fieldValue)"
	when
		container : ContainsConditions ( )
		containerGe : GeneratesElements ( this == container )
		value : Property ( eContainer == container, name == "fieldValue" )
		
		not ( Condition( name == "fieldValue is set", eContainer == container ))
	
		eval ( handler.veto( containerGe ))
	
	then
		PrimitiveCondition cond = handler.generatedPrimitiveCondition(containerGe, container);
		handler.setName(cond, "fieldValue is set");
		queue.add(cond, drools);

end

/**
 * @inference Operation,Property All {@model Property Properties}, other than 'fieldValue',
 * 		will have an {@model PrimitiveOperation} in its container called "set XXX".
 */
rule "Properties will have a related 'set XXX' operation"
	when
		container : ContainsOperations ( )
		containerGe : GeneratesElements ( this == container )
		value : Property ( eContainer == container, name != "fieldValue" )
		
		not ( Operation( eval(name.equals("set " + value.getName())), eContainer == container ))
	
		eval ( handler.veto( containerGe ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(containerGe, container);
		handler.setName(op, "set " + value.getName());
		queue.add(op, drools);

end

rule "Create contents of 'X is set' operation"
	when
		container : ContainsConditions ( )
		value : Property ( eContainer == container )
		
		o : CompositeCondition( eval(name.equals(value.getName() + " is set")), eContainer == container )
		
		not ( StartNode ( eContainer == o ))
		
		eval ( handler.veto( o ))
	
	then
		
		DecisionNode decision = handler.generatedDecisionNode(o, o);
		handler.setName(decision, "is set?");
		queue.add(decision, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);

		CancelNode cancel = handler.generatedCancelNode(o, o);
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, value);
		handler.setTo(data1, decision);
		queue.add(data1, drools);

		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, decision);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, decision);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, decision);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end
