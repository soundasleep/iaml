#created on: 4/11/2008
package org.openiaml.model.drools

#list any import classes here.
import org.eclipse.emf.ecore.*;
import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.domain.*;
import ca.ecliptical.emf.xpath.*;
import java.util.*;

#declare any global variables here
global EcoreCreateElementsHelper handler;

# insertion queue
import org.openiaml.model.drools.*;
global DroolsInsertionQueue queue;

function boolean connects(WireEdge wire, Object a, Object b) {
	return (wire.getFrom().equals(a) && wire.getTo().equals(b)) ||
		(wire.getFrom().equals(b) && wire.getTo().equals(a));
}

function boolean isXPath(String query) {
	return query.startsWith("xpath:");
}

/**
 * Could this potentially be an XPath match?
 * 
 * In particular, we take a query /a/b[c]/d[e] and
 * consider /a/b/d as potential matches. /a/b[c]/d[e] will become
 * the ConditionWire.
 *
 * Note we have to use the same XPath expressions as test
 * cases, i.e. //iaml:children[@name], not //Page
 */
function boolean potentialXPathMatch(EObject container, DynamicApplicationElementSet ds, Page target) {
	String query = ds.getQuery();
	if (!query.startsWith("xpath:"))
		throw new RuntimeException("potentialXPathMatch was called without an xpath: query: '" + query + "'");

	// remove prefix		
	query = query.substring("xpath:".length());
	
	// remove all conditionals
	// TODO note this will fail if we have a[a[b]], though I don't think this is possible in XPath anyway 	
	query = query.replaceAll("\\[([^\\]]+)\\]", "");
	
	// evaluate xpath using EMFXPath
	// TODO move this into Java code (to reduce redunancy of the following code)
	EMFXPath xpath = new EMFXPath(query);
	xpath.addNamespace("iaml", ModelPackage.eNS_URI);
	xpath.addNamespace("iaml.domain", DomainPackage.eNS_URI);
	xpath.addNamespace("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	List results = xpath.selectNodes(container);

	if (results.contains(target)) {
		return true;
	}
	
	return false;
}

rule "Connect SyncWires for a dynamic source, referenced by XPath"
		
	when
		container : InternetApplication ( )
		ds : DynamicApplicationElementSet( eval(isXPath(query)), overridden == false, eContainer == container )
		source : Page ( ) 
		sw : SyncWire ( eval(connects(sw, ds, source)) )
		target : Page ( eval(source != target), eval(potentialXPathMatch(container, ds, target)) )
		not ( tw : SyncWire( eval(connects(tw, source, target)) ) )
		
	then 
		SyncWire sw2 = handler.generatedSyncWire( container, container, source, target );
		handler.setName(sw2, "dynamic sync");
		queue.add(sw2, drools);
		
end

rule "Create the Condition for an XPath set"

	when
		ds : DynamicApplicationElementSet( eval(isXPath(query)), overridden == false )
		not ( CompositeCondition(eContainer == ds, name == 'xpath' ) )
	
	then
		CompositeCondition c = handler.generatedCompositeCondition(ds, ds);
		handler.setName(c, "xpath");
		queue.add(c, drools);
	
end

rule "Create the contents of the XPath condition"
	
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(isXPath(query)), overridden == false, eContainer == container )
		source : Page ( ) 
		sw : SyncWire ( eval(connects(sw, ds, source)) )
		target : Page ( eval(source != target), eval(potentialXPathMatch(container, ds, target)) )
		tw : SyncWire ( eval(connects(tw, source, target)) )
		o : CompositeCondition ( eContainer == ds, name == "xpath" )
		cw : ConditionWire ( from == o, to == tw )
		
		not ( StartNode( eContainer == o ))
	
	then
		# create contents
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "element");
		queue.add(parameter, drools);

		Parameter xpath = handler.generatedParameter(o, o);
		handler.setName(xpath, "xpath");
		queue.add(xpath, drools);
		
		DecisionCondition dc = handler.generatedDecisionCondition(o, o);
		handler.setName(dc, "xpathMatch");
		queue.add(dc, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		CancelNode cancel = handler.generatedCancelNode(o, o);
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, parameter);
		handler.setTo(data1, dc);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, xpath);
		handler.setTo(data2, dc);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, dc);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, dc);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge3, dc);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

/**
 * This rule used to contain the following negative existential:
 *
 * not (
 *   tw_cw : ConditionWire ( from == condition, to == tw ) and 
 *   tw_pw : ParameterWire ( from == ds, to == tw_cw ) and
 *   tw_pw2 : ParameterWire ( from == target, to == tw_cw )
 * )
 *
 * In order to satisfy our requirement that there are no more than
 * one negative existential in each rule [TODO see upcoming paper],
 * we can decompose this into two rules.
 */
rule "Create the XPath ConditionWire for generated SyncWires"
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(isXPath(query)), overridden == false, eContainer == container )
		source : Page ( ) 
		sw : SyncWire ( eval(connects(sw, ds, source)) )
		target : Page ( eval(source != target), eval(potentialXPathMatch(container, ds, target)) )
		tw : SyncWire ( eval(connects(tw, source, target)) )
		condition : CompositeCondition ( eContainer == ds )
		not (
			tw_cw : ConditionWire ( from == condition, to == tw ) 
		)
	
	then
		ConditionWire cwt = handler.generatedConditionWire( ds, ds, condition, tw );
		handler.setName(cwt, "xpath condition (target)");
		queue.add(cwt, drools);
		
		# Create the contents like normal

		ParameterWire pwt = handler.generatedParameterWire( cwt, cwt, ds, cwt);
		handler.setName(pwt, "[xpath] from ds 2");
		queue.add(pwt, drools);		 

		ParameterWire pwt2 = handler.generatedParameterWire( cwt, cwt, target, cwt);
		handler.setName(pwt2, "[xpath] from target");
		queue.add(pwt2, drools);

end

/**
 * This is a decomposition of the rule above.
 */
rule "Connect ParameterWires to empty ConditionWire for XPath"
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(isXPath(query)), overridden == false, eContainer == container )
		source : Page ( ) 
		sw : SyncWire ( eval(connects(sw, ds, source)) )
		target : Page ( eval(source != target), eval(potentialXPathMatch(container, ds, target)) )
		tw : SyncWire ( eval(connects(tw, source, target)) )
		condition : CompositeCondition ( eContainer == ds )
		cwt : ConditionWire ( from == condition, to == tw )
		not (
			#tw_cw : ConditionWire ( from == condition, to == tw ) and
			tw_pw : ParameterWire ( from == ds, to == cwt ) 
			#and
			#tw_pw2 : ParameterWire ( from == target, to == tw_cw )
		)
	
	then
		# We have a ConditionWire that does not have any parameters:
		# connect the parameters up to the wire

		ParameterWire pwt = handler.generatedParameterWire( cwt, cwt, ds, cwt);
		handler.setName(pwt, "[xpath] from ds 2");
		queue.add(pwt, drools);		 

		ParameterWire pwt2 = handler.generatedParameterWire( cwt, cwt, target, cwt);
		handler.setName(pwt2, "[xpath] from target");
		queue.add(pwt2, drools);

end

