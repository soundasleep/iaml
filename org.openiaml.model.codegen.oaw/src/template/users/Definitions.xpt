«IMPORT iaml»

/**
 * Method definitions for access control handlers.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * Expand out all domain object instances.
 */
«DEFINE accessControlHandlerDefinitions(Boolean php) FOR model::scopes::Session»
	«IF php»
		«REM»TODO clean up the metamodel, as an ACH can be either in 'children' or 'components' right now«ENDREM»
		«EXPAND checkAccessDefinition FOREACH children.typeSelect(model::components::AccessControlHandler)»
		«EXPAND checkAccessDefinition FOREACH components.typeSelect(model::components::AccessControlHandler)»
	«ELSE»
		/* no client-side access control handler definitions for Session */
	«ENDIF»
«ENDDEFINE»
«DEFINE accessControlHandlerDefinitions(Boolean php) FOR model::visual::Page»
	«IF php»
		«EXPAND checkAccessDefinition FOREACH children.typeSelect(model::components::AccessControlHandler)»
	«ELSE»
		/* no client-side access control handler definitions for Page */
	«ENDIF»
«ENDDEFINE»

/**
 * Definition of the access_control_permissions_check_*() method.
 * Expected to be in PHP.
 */
«DEFINE checkAccessDefinition FOR model::components::AccessControlHandler»
	/**
	 * Definition of access control handler '«name»'
	 */
	function access_control_permissions_check_«safeNameString(id)»() {
		«REM»find the desired UserInstance to check against«ENDREM»
		«REM»there should be exactly one incoming parameter wire with a UserInstance«ENDREM»
		«LET inEdges.typeSelect(model::wires::ParameterWire).from.typeSelect(model::users::UserInstance).first() AS user»
			«IF user==null»
				«EXPAND exception FOR throwException("No incoming UserInstances for AccessControlHandler " + this)»
			«ENDIF»
			«EXPAND checkAccessDefinitionUser(user) FOR this»
		«ENDLET»
	}
«ENDDEFINE»

/**
 * We now have a UserInstance on which to validate against
 */
«DEFINE checkAccessDefinitionUser(model::users::UserInstance user) FOR model::components::AccessControlHandler»
	$instance = get_object_instance_«safeName(user)»();
	if (!$instance)
		throw new IamlRuntimeException("Unexpected empty UserInstance '«user.name»'; has the user logged in?");

	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Role) AS targetRole»
		«LET user.inEdges.typeSelect(model::wires::SelectWire).from.typeSelect(model::DomainObject).first() AS initialRole»
			/* check role '«targetRole.name»' */
			if (cast_«safeName(initialRole)»_as_«safeName(targetRole)»($instance) == null) {
				throw new IamlRuntimeException("Source role '«initialRole.name»' could not be translated into '«targetRole.name»'");
			} else {
				// can be cast fine
			}
		«ENDLET»
	«ENDFOREACH»
	
	/* check permissions */
	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Permission) AS targetPermission»
		/* permission '«targetPermission.name»' */
		if (
		«IF user.inEdges.typeSelect(model::wires::NewInstanceWire).isEmpty»
			«IF user.inEdges.typeSelect(model::wires::SelectWire).isEmpty»
				«EXPAND exception FOR throwException("Cannot deduce the instance type of UserInstance: " + user)»
			«ELSE»
				user_instance_«safeName(user.inEdges.typeSelect(model::wires::SelectWire).from.first())»_has_permission_«safeName(targetPermission)»
			«ENDIF»
		«ELSE»
			user_instance_«safeName(user.inEdges.typeSelect(model::wires::NewInstanceWire).from.first())»_has_permission_«safeName(targetPermission)»
		«ENDIF»
		($instance)) {
			// user has permission
		} else {
			throw new IamlRuntimeException("User of type '«user.name»' did not have permission '«targetPermission.name»'");
		}
	«ENDFOREACH»
	
	/* check is successful */
	return true;
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
