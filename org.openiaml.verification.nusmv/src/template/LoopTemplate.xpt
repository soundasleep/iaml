«IMPORT iaml»

«EXTENSION metamodel::LoopExtensions»

«DEFINE main FOR model::InternetApplication»
	«FILE "output/check.smv"»	

-- definitions for each CompositeOperation
«EXPAND OperationContents::operationContents FOREACH eAllContents.typeSelect(model::CompositeOperation)»

-- definitions for each CompositeCondition
«EXPAND ConditionContents::conditionContents FOREACH eAllContents.typeSelect(model::CompositeCondition)»

-- main module
«LET eAllContents.typeSelect(model::visual::Page) AS allPages»
«LET eAllContents.typeSelect(model::visual::Button) AS allButtons»

MODULE main

VAR
	-- possible running operations
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)» : process operation_«safeName(operation)»(run_«safeName(operation)», navigation_finished
			«FOREACH allApplicationProperties() AS p», property_«safeName(p)»«ENDFOREACH»);
		run_«safeName(operation)» : boolean;
	«ENDFOREACH»

	-- possible running conditions
	«FOREACH eAllContents.typeSelect(model::CompositeCondition) AS condition»
		running_condition_«safeName(condition)» : process condition_«safeName(condition)»(run_condition_«safeName(condition)»
			«FOREACH allApplicationProperties() AS p», property_«safeName(p)»«ENDFOREACH»);
		run_condition_«safeName(condition)» : boolean;
	«ENDFOREACH»
	
	-- all pages
	«IF !allPages.isEmpty»
		current_page : {
			null 
			«FOREACH allPages AS p»
				, «safeName(p)»
			«ENDFOREACH»
		};
	
		-- allowing NuSMV to select pages at random
		select_browse_to_page : {
			«FOREACH allPages AS p SEPARATOR ", "»
				«safeName(p)»
			«ENDFOREACH»
		};

		-- storing the current target
		browse_to_page : {
			null,
			«FOREACH allPages AS p SEPARATOR ", "»
				«safeName(p)»
			«ENDFOREACH»
		};
	«ENDIF»
	
	-- all buttons on all pages
	«FOREACH allButtons AS b»
	click_«safeName(b)» : boolean;
	«ENDFOREACH»
	
	-- application properties
	«FOREACH allApplicationProperties() AS p»
	property_«safeName(p)» : 0..«maximumIntegerSize()»;
	«ENDFOREACH»

	-- value overflow
	value_overflow : boolean;
	
	-- flags
	operation_running : boolean;
	operation_finished : boolean;
	
	navigation_running : boolean;
	navigation_finished : boolean;

ASSIGN
	init(value_overflow) := 0;
	init(operation_running) := 0;
	init(operation_finished) := 0;
	
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		init(run_«safeName(operation)») := 0;
	«ENDFOREACH»
	
	«FOREACH allApplicationProperties().select(p|p.defaultValue != null) AS p»
		-- initialise default values, if specified
		init(property_«safeName(p)») := «p.defaultValue»;
	«ENDFOREACH»

	«IF !allPages.isEmpty»
		-- we start off without being on any page
		init(current_page) := null;
	«ENDIF»		
	
	-- click_button is chosen by nusmv
	-- select_browse_to_page is chosen by nusmv
	
	«IF !allPages.isEmpty»
	next(browse_to_page) := case
		operation_running = 1 : browse_to_page;
		navigation_running = 1 : browse_to_page;
		1 : select_browse_to_page;
	esac;
	«ENDIF»
	
	«REM»
	TODO I think the current implementation supports clicking two buttons
	simultaneously, and executing these two operations simultaneously.
	«ENDREM»
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		next(run_«safeName(operation)») := case
			-- already running
			run_«safeName(operation)» = 1 : case 
				-- operation finished?
				running_«safeName(operation)».finished = 1 : 0;
				
				-- still running
				1 : 1;
			esac;
			
			-- we have just accessed a page; wait until it is finished
			navigation_running = 1 : 0;
			
			-- executed by accessing a page
			«REM»
			«REM»an access operation can be executed many times while in the
			same page (as long as it isn't currently being run); this is the same as reloading the page«ENDREM»
			operation_running = 0 : case
				«FOREACH allPages AS p»
					«IF p.eventTriggers.select(e|e.name == "access" || e.name == "onAccess")
							.outEdges.typeSelect(model::wires::RunInstanceWire).to.contains(operation)»
						browse_to_page = «safeName(p)» : 1;
					«ENDIF»
				«ENDFOREACH»
		
				-- executed by clicking a button
				«FOREACH allButtons AS b»
					«REM»button -> run[onClick] -> operation«ENDREM»
					«IF !b.outEdges.typeSelect(model::wires::RunInstanceWire).select(w|w.name == "click" || w.name == "onClick").select(w|w.to == operation).isEmpty»				
					click_«safeName(b)» = 1 : 1;
					«ENDIF»
					«REM»button -> event[onClick] -> run -> operation«ENDREM»
					«IF !b.eventTriggers.select(e|e.name == "click" || e.name == "onClick").outEdges.typeSelect(model::wires::RunInstanceWire).select(w|w.to == operation).isEmpty»				
					click_«safeName(b)» = 1 : 1;
					«ENDIF»
					«REM»TODO button -> event -> run -> operation«ENDREM»
				«ENDFOREACH»
			
				1 : run_«safeName(operation)»;	-- don't change it	
			esac;
			
			-- should not be running
			1 : 0;
		esac;
	«ENDFOREACH»
	
	«FOREACH eAllContents.typeSelect(model::CompositeCondition) AS condition»
		next(run_condition_«safeName(condition)») := case
			-- already running
			run_condition_«safeName(condition)» = 1 : case 
				-- condition finished?
				running_condition_«safeName(condition)».finished = 1 : 0;
				
				-- still running
				1 : 1;
			esac;
			
			-- has it finished?
			running_condition_«safeName(condition)».finished = 1 : 0;
			
			-- navigation just started?
			navigation_running = 1 & navigation_finished = 0 : case
				«FOREACH allPages AS p»
					«IF !p.eventTriggers.select(e|e.name == "access" || e.name == "onAccess")
							.outEdges.typeSelect(model::WireEdgeDestination).select(w | !w.inEdges.select(w|w.from == condition).isEmpty).isEmpty»
						-- start the condition
						current_page = «safeName(p)» : 1;
					«ENDIF»
				«ENDFOREACH»
				
				-- should not be running
				1 : 0;
			esac;
						
			-- should not be running
			1 : 0;
		esac;
	«ENDFOREACH»
	
	next(value_overflow) := case
		«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
			running_«safeName(operation)».value_overflow = 1 : 1;
		«ENDFOREACH»
		«FOREACH eAllContents.typeSelect(model::CompositeCondition) AS condition»
			running_condition_«safeName(condition)».value_overflow = 1 : 1;
		«ENDFOREACH»
		1 : value_overflow;
	esac;

	next(operation_running) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 0;
		run_«safeName(operation)» = 1 : 1;
	«ENDFOREACH»
	«FOREACH eAllContents.typeSelect(model::CompositeCondition) AS condition»
		running_condition_«safeName(condition)».finished = 1 : 0;
		run_condition_«safeName(condition)» = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;
	
	next(operation_finished) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 1;
	«ENDFOREACH»
	«FOREACH eAllContents.typeSelect(model::CompositeCondition) AS condition»
		running_condition_«safeName(condition)».finished = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;
	
	«IF !allPages.isEmpty»
		-- browsing to a new page
		next(current_page) := case
			-- we have just accessed a page which needs instant redirection?
			«FOREACH allPages AS p»
				«LET p.eventTriggers.select(e|e.name == "access").outEdges.typeSelect(model::wires::NavigateWire).select(w | model::visual::Page.isInstance(w.to)) AS navs»
				«IF !navs.isEmpty»
					«LET navs.first() AS nav»
						current_page = «safeName(p)» 
						«IF !inConditionWires(nav).isEmpty»
							«FOREACH inConditionWires(nav).from.typeSelect(model::Condition) AS condition»
								«REM»& run_condition_«safeName(condition)» = 1«ENDREM»
								& running_condition_«safeName(condition)».finished = 1 
								& running_condition_«safeName(condition)».result = passed								
							«ENDFOREACH»
						«ENDIF»
						:  
						«safeName(nav.to)»
						;
					«ENDLET»
				«ENDIF»
				«ENDLET»
			«ENDFOREACH»

			«REM»
			cannot change pages if an operation is running.
			NOTE this is a design assumption: when an operation is running, the user may not browse to another page
			«ENDREM»
			operation_running = 1 : current_page;
						
			-- are we still navigating?
			navigation_running = 1 : current_page;
			
			-- browse to another page chosen by NuSMV
			«FOREACH allPages AS p»
				browse_to_page = «safeName(p)» : «safeName(p)»;
			«ENDFOREACH»
			1 : current_page;
		esac;
	«ENDIF»
	
	next(navigation_running) := case
		«REM»can never navigate while an operation is running«ENDREM»
		operation_running = 1 : 0;
		
		«REM»are we currently navigating?«ENDREM»
		navigation_running = 1 : case
			«FOREACH allPages AS p»
				current_page = «safeName(p)» :
					«LET p.eventTriggers.select(e|e.name == "access").outEdges.typeSelect(model::wires::NavigateWire).select(w | model::visual::Page.isInstance(w.to)) AS navs»
						«IF !navs.isEmpty»
							«REM»this page redirects to another page«ENDREM»
							«LET navs.first() AS nav»
								«IF inConditionWires(nav).isEmpty»
								1	«REM»always redirects«ENDREM»
								«ELSE»
									«REM»redirects based on incoming conditions«ENDREM»
									case
									«FOREACH inConditionWires(nav).from.typeSelect(model::Condition) AS condition SEPARATOR " & "»
										«REM»& run_condition_«safeName(condition)» = 1«ENDREM»
										running_condition_«safeName(condition)».finished = 1 
										& running_condition_«safeName(condition)».result = passed								
									«ENDFOREACH»
									: 0;
									1 : 1;
									esac
								«ENDIF»
							«ENDLET»						
						«ELSE»
							0«REM»this page does not instantly redirect anywhere«ENDREM»
						«ENDIF»
					«ENDLET»
				;
			«ENDFOREACH»
			1 : 0;	«REM»nothing can be run«ENDREM»
		esac;
		
		«REM»have we started to browse to another page, as chosen by NuSMV?«ENDREM»
		-- browse to another page chosen by NuSMV
		«FOREACH allPages AS p»
			browse_to_page = «safeName(p)» : 1;
		«ENDFOREACH»
		
		-- otherwise, not navigating
		1 : 0;
	esac;
	
	next(navigation_finished) := case
		«REM»are we currently navigating?«ENDREM»
		navigation_running = 1 : case
			«FOREACH allPages AS p»
				current_page = «safeName(p)» : 
					«LET p.eventTriggers.select(e|e.name == "access").outEdges.typeSelect(model::wires::NavigateWire).select(w | model::visual::Page.isInstance(w.to)) AS navs»
						«IF !navs.isEmpty»
							«REM»this page redirects to another page«ENDREM»
							«LET navs.first() AS nav»
								«IF inConditionWires(nav).isEmpty»
								1	«REM»always redirects«ENDREM»
								«ELSE»
									«REM»redirects based on incoming conditions«ENDREM»
									case
									«FOREACH inConditionWires(nav).from.typeSelect(model::Condition) AS condition SEPARATOR " & "»
										«REM»& run_condition_«safeName(condition)» = 1«ENDREM»
										running_condition_«safeName(condition)».finished = 1 
										& running_condition_«safeName(condition)».result = passed								
									«ENDFOREACH»
									: 1;
									1 : 0;
									esac
								«ENDIF»
							«ENDLET»
						«ELSE»
							1«REM»this page does not instantly redirect anywhere«ENDREM»
						«ENDIF»
					«ENDLET»
				;
			«ENDFOREACH»
			1 : 1;	«REM»it has to finish«ENDREM»
		esac;
		
		-- otherwise, navigation hasn't started, so we can't finish it
		1 : 1;	«REM»otherwise, we haven't started navigation, so we have to finish«ENDREM»
	esac;
	
	«FOREACH allApplicationProperties() AS p»
	next(property_«safeName(p)») := case
		«REM»find all operations that change it«ENDREM»
		«FOREACH eAllContents.typeSelect(model::DataFlowEdge)
				.select(d | d.to == p).eContainer.typeSelect(model::CompositeOperation) AS operation»
			
			run_«safeName(operation)» = 1 : case
				«REM»find all ways that it may be set (may be multiple per composite operation)«ENDREM»
				«FOREACH operation.operations.typeSelect(model::PrimitiveOperation)
						.select(o | o.name == "setPropertyToValue")
						.select(o | !o.outFlows.select(f|f.to == p).isEmpty) AS setOp»
					running_«safeName(operation)».current_step = «safeName(setOp)» :
						(«EXPAND Flow::getTemporaryVariableValue FOR setOp.inFlows.from.first()») mod «maximumIntegerSize() + 1»;
					«REM»TODO value overflow«ENDREM»
				«ENDFOREACH»
				
				1 : property_«safeName(p)»;
			esac;
		«ENDFOREACH»
	
		-- otherwise, property value cannot change
		1 : property_«safeName(p)»;
	esac;
	«ENDFOREACH»

«REM»if we only have 'main' module, we cannot have FAIRNESS«ENDREM»
«IF !eAllContents.typeSelect(model::CompositeOperation).isEmpty»
FAIRNESS
  running
«ENDIF»

«ENDLET»
«ENDLET»
	
	«ENDFILE»
«ENDDEFINE»

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540  
 */
«DEFINE exception FOR Object»
«ENDDEFINE»
