«IMPORT iaml»

/**
 * Visually rendering a text field.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * @implementation InputTextField
 * 		If an invalid value is typed into a typed {@model InputTextField}, then the
 *		text field is cleared, and no {@model EventTrigger events} are run.
 * @implementation InputTextField
 *		If a typed {@model InputTextField} is changed, the value of the text field
 *		is re-cast to a standard implementation using <code>do_cast</code> before
 *		any events are fired.
 * @implementation InputTextField
 *		Any {@model VisibleThing children} of a {@model InputTextField} are also rendered
 *		as part of that InputTextField.
 */
«DEFINE renderTextField(model::visual::Frame currentFrame) FOR model::visual::InputTextField-»
	<div>
	<label id="label_«safeNameString(id)-»">
		«textFieldName()»
		
		<input type="text" id="«safeNameString(id)»" name="«safeNameString(id)»"
			onChange="return onChange_«safeNameString(id)»(this);"
			«EXPAND EventHandlers::getInlineClickJavascript(currentFrame)»

			«REM»any initial values?«ENDREM»
			«EXPAND getInitialValuesSetWire(currentFrame) FOREACH inWires.typeSelect(model::wires::SetWire)» 			 
			«EXPAND getInitialValuesSyncWire(currentFrame) FOREACH inWires.typeSelect(model::wires::SyncWire)» 
			«EXPAND getInitialValuesSyncWire(currentFrame) FOREACH outWires.typeSelect(model::wires::SyncWire)» 			 

			«REM»
				an initial value?
				TODO we could have multiple default values; right now we are relying on
				browser behaviour to place this value as lower priority. we should work
				out some way to select it programatically.
			«ENDREM»
			«EXPAND staticInitialValue(currentFrame) FOREACH properties.select( e | e.name == "fieldValue")»			
		>
		
		<script language="Javascript" type="application/javascript">
		/* <![CDATA[ */
			function onChange_«safeNameString(id)»(obj) {
				// check data type
				«IF type != null»
					var value = obj.value;
					if (!can_cast(value, '«type.uRI»')) {
						// reset
						obj.value = "";
						return false;
					} else {
						// reformat it
						// but make sure it's represented as a string
						// (this prevents the Date from switching timezones, etc)
						obj.value = do_cast(do_cast(value, '«type.uRI»'), 'http://openiaml.org/model/datatypes#iamlString');						
					}
				«ENDIF»
			
				«IF onChange != null»
					// expand all onChanges
					«REM»
						we save a copy of the current value, so that server update replies
						don't update the value before we are finished using it.
						
						the calls below (in particular, set_application_value) will update
						the local value anyway, if it needs to be changed.
						
						this solves a problem where JWebUnit test cases would fail, but
						running them locally (in a non-AJAX-synchronized environment) would pass. 
					«ENDREM»
					var pre_onChange_value = obj.value;
					«EXPAND template::events::EventCall::callEvent(false) FOR onChange-»
					obj.value = pre_onChange_value;
				«ENDIF»

				«REM»
					if 'server values' is after 'outgoing values', then the value of the field
					is temporarily changed to the old one, until 'server values' is then executed.
					see: r1795
				«ENDREM»

				// server values
				«REM»save a value for myself (which is not covered by an outEdge/inEdge) to the server/session?«ENDREM»
				«EXPAND template::operations::OutgoingValues::outgoingValue(this) FOREACH properties.select( e | e.name == "fieldValue")»

				// outgoing values
				«REM»any application element properties to change? (both on client and server)«ENDREM»
				«REM»this doesn't cover fieldValues connected by Set/SyncWires; these are covered by server code (below)«ENDREM»
				«EXPAND template::operations::OutgoingValues::outgoingValues(this) FOREACH outWires»
				«EXPAND template::operations::OutgoingValues::outgoingValues(this) FOREACH inWires»
				«REM»it may be required to outgoingValues(this) FOREACH properties.outWires«ENDREM»
				
				return false;
			}
			
			«REM»any on-access events?«ENDREM»
			addOnloadFunction( function() {
			«IF onAccess != null»
				// expand all onAccess
				«EXPAND template::events::EventCall::callEvent(false) FOR onAccess-»
			«ENDIF»
			} );
		/* ]]> */
		</script>

		«EXPAND EventHandlers::getScriptClickDefinition(currentFrame)»

		«REM»expand all children«ENDREM»
		«EXPAND Render::renderVisual(currentFrame) FOREACH children-»
		
		«IF type != null && type.uRI == "http://openiaml.org/model/datatypes#iamlOpenIDURL"»
			«EXPAND textFieldOpenID(currentFrame)»
		«ENDIF»
	</label>
	</div>
«ENDDEFINE»

/* if it connects to a SyncWire that is an Property, use this
   property as the value */
«DEFINE getInitialValuesSyncWire(model::visual::Frame currentFrame) FOR model::wires::SyncWire»
	«EXPAND staticInitialValue(currentFrame) FOR from»
	«EXPAND staticInitialValue(currentFrame) FOR to»
«ENDDEFINE»

/* if it connects to a SetWire that is an Property, use this
   property as the value */
«DEFINE getInitialValuesSetWire(model::visual::Frame currentFrame) FOR model::wires::SetWire»
	«EXPAND staticInitialValue(currentFrame) FOR from»
«ENDDEFINE»

/* ignore these sources */
«DEFINE staticInitialValue(model::visual::Frame currentFrame) FOR model::WireSource»
«ENDDEFINE»
«DEFINE staticInitialValue(model::visual::Frame currentFrame) FOR model::WireDestination»
«ENDDEFINE»

/* we have a property to provide [in PHP] */
«DEFINE staticInitialValue(model::visual::Frame currentFrame) FOR model::Property»
	«IF containingSession(this) == null»
		«REM»contained in a Frame or InternetApplication: a static value«ENDREM»
		value="<?php echo htmlspecialchars(get_application_value("«safeNameString(id)»", "«escapeString(defaultValue)»")); ?>"
	«ELSE»
		«REM»contained in a Session: a session value«ENDREM»
		value="<?php echo htmlspecialchars(require_session("«safeName(containingSession(this))»_«safeNameString(id)»", "«escapeString(defaultValue)»")); ?>"
	«ENDIF»
«ENDDEFINE»

«DEFINE staticInitialValue(model::visual::Frame currentFrame) FOR model::DomainAttributeInstance»
	«REM»from a domain attribute instance.«ENDREM»
	<?php if (has_attribute_instance_«safeName()»()) { ?>
	value="<?php echo htmlspecialchars(get_attribute_instance_«safeName()»()); ?>"
	<?php } ?>
«ENDDEFINE»

«DEFINE staticInitialValue(model::visual::Frame currentFrame) FOR model::QueryParameter»
	«REM»from the query«ENDREM»
	value="<?php echo «EXPAND template::operations::Parameters::callParameterValue(true, false)»; ?>"
«ENDDEFINE»

/**
 * @implementation InputTextField
 *		{@model InputTextField}s of {@model InputTextField#type} <code>iamlOpenIDURL</code> will
 *		provide a link to authenticate against the provided OpenID URL.
 */ 
«DEFINE textFieldOpenID(model::visual::Frame currentFrame) FOR model::visual::InputTextField-»
	<!-- openID -->
	<input type="button" value="Authenticate" 
		onClick="return openid_authenticate_«safeName()»();">

	<script language="Javascript" type="application/javascript">
		/* <![CDATA[ */
			function openid_authenticate_«safeName()»() {
				<?php log_message("Current URL: " . get_current_url()); ?>
				var url = "open_id_callback.php?mode=start";
				url += "&url=" + encodeURIComponent(document.getElementById('«safeNameString(id)»').value);
				url += "&final=" + encodeURIComponent('<?php echo htmlspecialchars(get_current_url()); ?>');
				url += create_stacktrace_parameter();
				execute_queued_url(url, 'new_domain_instance');
							
				return false;
			}
		/* ]]> */
	</script>
«ENDDEFINE»
