«IMPORT iaml»

/**
 * Methods for casting instances of inherited domain objects.
 */
«EXTENSION template::GeneratorExtensions»

«DEFINE allCasts FOR model::DomainObject»
	«REM»expand self cast«ENDREM»
	«EXPAND castSourceAsTarget(this) FOR this»
	
	«REM»expand all direct extends«ENDREM»
	«FOREACH inEdges.typeSelect(model::wires::ExtendsWire).from.typeSelect(model::DomainObject) AS target»
		«EXPAND castSourceAsTarget(target) FOR this»
	«ENDFOREACH»
«ENDDEFINE»

«REM»
// return an object of the accumulated data, or null if it could
// not be cast
function cast_[source]_as_[target]($instance) {
	if [source] == [target]
		return $instance;

	foreach subclass of [source]
		attribute source_key = [source].primaryKey;
		attribute target_key = subclass.attributes ( k | k extends source_key )
		$source_value = $instance[source_key];
		
		$new_instance = (select * from subclass where target_key = ?)($source_value);
		
		if ($new_instance) {
			// add $instance to $new_instance
			foreach ($attr in $instance) {
				if (isset($new_instance[$attr]))
					$new_instance[[source] '.' $attr] = $instance[$attr];
				else
					$new_instance[$attr] = $new_instance[$attr];
			}
			return cast_[subclass]_as_[target]($new_instance);
		} else {
			return null;
		}

}

«ENDREM»
«DEFINE castSourceAsTarget(model::DomainObject target) FOR model::DomainObject»
/**
 * Try to cast a '«name»' into a subclass '«target.name»'. 
 *
 * Returns an instance of '«target.name»' with all accumulated attributes of
 * '«name»' and the heirarchy of subclasses, or <b>null</b> if it
 * could not be cast.
 */
function cast_«safeName()»_as_«safeName(target)»($instance) {
	«IF this == target»
		/* same instance; return immediately */
		return $instance;
	«ELSE»
		«FOREACH inEdges.typeSelect(model::wires::ExtendsWire).from.typeSelect(model::DomainObject) AS subclass»
			«LET attributes.selectFirst(a | a.primaryKey) AS sourceKey»
				«LET subclass.attributes.select(a | !a.outEdges.typeSelect(model::wires::ExtendsWire).to.select( a | a == sourceKey ).isEmpty).first() AS targetKey»
					$source_value = $instance["«safeNameString(sourceKey.name)»"];

					«EXPAND Select::selectDatabase FOR subclass»
					
					$query = "SELECT * FROM «safeNameString(subclass.name)» WHERE
						«safeNameString(targetKey.name)» = ?";

					$args = array($source_value);
					
					log_message("Selecting instance for cast from «name» to «target.name»: '$query', args = " . print_r($args, true));
					
					$db_query = new DatabaseQuery($db_name);
					$new_instance = $db_query->fetchFirst($query, $args);
					if ($new_instance === null) {
						log_message("Could not find any result");
						return null;
					}
			
					log_message("Found instance: " . print_r($new_instance, true));
					 
					// add $instance to $new_instance
					foreach ($instance as $key => $value) {
						if (isset($new_instance[$key])) {
							$new_instance["«safeNameString(this.name)»." . $key] = $value;
						} else {
							$new_instance[$key] = $value;
						}
					}
					
					// continue casting call
					return cast_«safeName(subclass)»_as_«safeName(target)»($new_instance);
				«ENDLET»
			«ENDLET»
		«ENDFOREACH»
	«ENDIF»
}
«ENDDEFINE»

«REM»

we want this method to return _all_ joins for this object, not just
those which are directly inherited

direct_joins("doctoral") = array(
	"teacher" => "join teacher on teacher.id = doctoral.t_id",
	"student" => "join student on student.id = doctoral.s_id",
)

«ENDREM»

«DEFINE defineInheritanceJoins FOR model::DomainObject»
 	/* «safeNameString(name)» */ 
	$direct_joins["«safeNameString(id)»"] = array(
		
		«FOREACH outEdges.typeSelect(model::wires::ExtendsWire).to.typeSelect(model::DomainObject) AS parent»
			«REM»find the PK of the parent object«ENDREM»
			«LET parent.attributes.select(a | a.primaryKey).first() AS parentPK»				
				«REM»find the corresponding FK of this current object«ENDREM»
				«LET attributes.select(a | a.outEdges.typeSelect(model::wires::ExtendsWire).to.contains(parentPK)).first() AS fk»
					"«safeNameString(parent.id)»" => 
					"JOIN «safeNameString(parent.name)» ON
						«safeNameString(parent.name)».«safeNameString(parentPK.name)» 
						= «safeNameString(name)».«safeNameString(fk.name)»",
				«ENDLET»
			«ENDLET» 
		«ENDFOREACH»
		 
	); 
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
