«IMPORT iaml»

/**
 * Code behind Roles.
 *
 */
«EXTENSION template::GeneratorExtensions»

«DEFINE roleFunctions FOR model::users::Role»
	«REM»all roles that extend this role«ENDREM»
	«FOREACH getDomainStore().eAllContents.typeSelect(model::users::Role) AS role»
		«EXPAND addRoleFunction(role) FOR this»
		«EXPAND removeRoleFunction(role) FOR this»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE addRoleFunction(model::users::Role target) FOR model::users::Role»
/**
 * Add the role '«target.name»' to the current instance of '«name»'.
 *
 * This role can only be added if there is a common ancestor of both.
 *
 */
function add_role_«safeName(target)»_to_«safeName()»($instance) {
	«IF target==this»
		// same role; no need to do any more
		return $instance;
	«ELSEIF allSubtypes().contains(target)»
		// the type '«target.name»' is a subtype of '«name»'
		
		«LET inExtendsEdges.from.typeSelect(model::users::Role) AS directSubtypes»
		«FOREACH directSubtypes AS subType»
			«IF allSubtypes(subType).contains(target)»
				// the subtype '«subType.name»' has a path to '«target.name»'
				
				// does an instance of '«subType.name»' exist?
				$this_instance = cast_«safeName()»_as_«safeName(subType)»($instance);
				if ($this_instance === null) {
					// insert in a new instance
					
					«LET getPrimaryKey() AS pk»
					«LET subType.attributes.select(a|a.outExtendsEdges.to.contains(pk)).first() AS subtypeFk»

					«EXPAND template::domain::Select::selectDatabase FOR subType»
					
					// the database will insert in a new primary key
					$query = "INSERT INTO «safeNameString(subType.name)» 
						(«safeNameString(subtypeFk.name)»)
						VALUES
						(?)";
						
					if (!isset($instance["«safeNameString(pk.name)-»"])) {
						throw new IamlRuntimeException("Primary key '«pk.name»' did not exist in instance of '«name»'");
					}
					$args = array($instance["«safeNameString(pk.name)-»"]);
					
					$db_query = new DatabaseQuery($db_name);
					$db = $db_query->execute($query, $args);
					«ENDLET»
					«ENDLET»

					// now that we have inserted it, we should be able to successfully cast
					$this_instance = cast_«safeName()»_as_«safeName(subType)»($instance);
					if ($this_instance === null) {
						throw new IamlRuntimeException("Could not successfully add new role '«subType.name»' to existing role '«name»'");
					}
					
					// if this role provides any permissions, we need to add them by default
					«FOREACH subType.outEdges.typeSelect(model::wires::ProvidesWire).to.typeSelect(model::users::Permission) AS permission»
						// permission '«permission.name»'
						$result = add_permission_«safeName(permission)»_to_«safeName(subType)»($this_instance);
						if (!$result) {
							throw new IamlRuntimeException("Could not add permission '«permission.name»' to subtype role '«subType.name»'");
						}
					«ENDFOREACH»					
				
				}
				
				// now get the next subtype to add information 
				return add_role_«safeName(target)»_to_«safeName(subType)»($this_instance);
			«ENDIF»
		«ENDFOREACH»
		«ENDLET»		
	«ELSE»
		// the target class is not in any subclasses; try the direct superclasses
		«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS superclass»
			// subclass '«superclass.name»'
			$superclass_instance = get_subclass_«safeName(superclass)»_from_«safeName()»($instance);
			if ($superclass_instance != null) {
				$result = add_role_«safeName(target)»_to_«safeName(superclass)»($superclass_instance);
				if ($result !== null) {
					// successful
					return $result;
				}
				log_message("[add role] could not add role from superclass '«superclass.name»'");
			}
		«ENDFOREACH»
		
		// could not find any
		throw new IamlRuntimeException("Could not find any common ancestor between '«target.name»' and '«name»'"); 
	«ENDIF»
}
«ENDDEFINE»

«DEFINE removeRoleFunction(model::users::Role target) FOR model::users::Role»
/**
 * Remove the role '«target.name»' to the current instance of '«name»'.
 *
 * Even if this role is not currently an instance of '«name»', this method
 * will not fail.
 *
 * Returns true if the role was successfully removed.
 */
function remove_role_«safeName(target)»_from_«safeName()»($instance) {
	«IF target==this»
		// same role; we need to remove this instance
		«EXPAND template::domain::Select::selectDatabase FOR target»
		
		«LET getPrimaryKey() AS pk»
		$query = "DELETE FROM «safeNameString(name)»
			WHERE «safeNameString(pk.name)» = ?";
			
		if (!isset($instance["«safeNameString(pk.name)-»"])) {
			throw new IamlRuntimeException("Primary key '«pk.name»' did not exist in instance of '«name»'");
		}
		$args = array($instance["«safeNameString(pk.name)-»"]);
		
		$db_query = new DatabaseQuery($db_name);
		$db = $db_query->execute($query, $args);
		«ENDLET»

		// if this role provides any permissions, we need to remove them by default
		«FOREACH outEdges.typeSelect(model::wires::ProvidesWire).to.typeSelect(model::users::Permission) AS permission»
			// permission '«permission.name»'
			remove_permission_«safeName(permission)»_from_«safeName()»($instance);
		«ENDFOREACH»
		
		// success!
		return true;
	«ELSEIF allSubtypes().contains(target)»
		// the type '«target.name»' is a subtype of '«name»'
		
		«LET inExtendsEdges.from.typeSelect(model::users::Role) AS directSubtypes»
		«FOREACH directSubtypes AS subType»
			«IF allSubtypes(subType).contains(target)»
				// the subtype '«subType.name»' has a path to '«target.name»'
				
				// does an instance of '«subType.name»' exist?
				$this_instance = cast_«safeName()»_as_«safeName(subType)»($instance);
				if ($this_instance !== null) {
					// instruct this instance to remove the tole
					$result = remove_role_«safeName(target)»_from_«safeName(subType)»($this_instance);
					if ($result) {
						// removed successfully
						return true;
					}
				}
			«ENDIF»
		«ENDFOREACH»
		«ENDLET»		
	«ELSE»
		// the target class is not in any subclasses; try the direct superclasses
		«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS superclass»
			// subclass '«superclass.name»'
			$superclass_instance = get_subclass_«safeName(superclass)»_from_«safeName()»($instance);
			if ($superclass_instance != null) {
				$result = remove_role_«safeName(target)»_from_«safeName(superclass)»($superclass_instance);
				if ($result) {
					// successful
					return $result;
				}
			}
		«ENDFOREACH»
		
		// could not find any
		return false;
	«ENDIF»
}
«ENDDEFINE»


«DEFINE getRoleSuperclass FOR model::users::Role»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»