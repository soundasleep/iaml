«IMPORT iaml»

/**
 * The flow of execution within an operation.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * TODO unresolved: How to handle multiple outExecutions within PHP and JS.
 * 
 * Option: Start new threads, though this could be challenging for Javascript, and it
 * will also introduce concurrency issues.  
 */
# @implementation StartNode If a {@model StartNode} has more than one {@model ExecutionEdge} coming out of it, they will be executed sequentially. 
«DEFINE executionFlow(model::visual::Page container, Boolean php) FOR model::operations::StartNode-»
	«EXPAND executionFlowInternal(container, php, outExecutions) FOR this»
«ENDDEFINE»

«DEFINE executionFlowInternal(model::visual::Page container, Boolean php, List[model::ExecutionEdge] edges) FOR model::ExecutionEdgesSource-»
	// flow starts here
	/**
	 * Since Javascript does not support GOTO, we must emulate this manually.
	 * We also implement this in PHP to unify the approach.
	 * 
	 * TODO Ideally we would take the execution graph and translate it sensibly
	 * into a correct structure of blocks, but this remains future work.
	 */
	// we emulate goto using an infinite loop of switch(pos)
	«REM»initialise stack«ENDREM»
	«IF php»
		$call_stack_«safeName()» = new CallStack();
		$completed_«safeName()» = false;
	«ELSE»
		var call_stack_«safeName()» = new CallStack();
		var completed_«safeName()» = false;
	«ENDIF»
	
	«REM»all of the initial outgoing executions are inserted onto the stack initially«ENDREM»
	«FOREACH edges AS e»
		«EXPAND addStack(this, php) FOR e»
	«ENDFOREACH»
	
	«REM»loop over stack until it is complete«ENDREM»
	«IF php»
		while (!$completed_«safeName()») {
			$current_node_«safeName()» = $call_stack_«safeName()»->pop();
			switch ($current_node_«safeName()») {
	«ELSE»
		while (!completed_«safeName()») {
			var current_node_«safeName()» = call_stack_«safeName()».pop();
			switch (current_node_«safeName()») {
	«ENDIF»
	
			«FOREACH allDestinations(this, {}) AS dest»
				case "«safeName(dest)»":
					«EXPAND executionFlowStep(this, container, php) FOR dest»
					break;
			«ENDFOREACH»
			
				default:
					«IF php»
						throw new IamlRuntimeException("Unexpected state: " . $current_node);
					«ELSE»
						throw new IamlJavascriptException("Unexpected state: " + current_node);
					«ENDIF»
				}
			}
	// all destinations 2:
	/*
	 * «allDestinations(this, {})»
	 */
«ENDDEFINE»

«DEFINE executionFlow(model::visual::Page container, Boolean php) FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/**
 * Converts an ExecutionEdge into an operation on the call stack.
 */
«DEFINE addStack(model::ExecutionEdgesSource start, Boolean php) FOR model::ExecutionEdge»
	«IF php»$call_stack_«safeName(start)»->push«ELSE»call_stack_«safeName(start)».push«ENDIF»
	("«safeName(to)-»");
«ENDDEFINE»

«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR emf::EObject-»
	/* disabled */
	// all destinations 1:
	/*
	 * «allDestinations(this, {})»
	 */
«ENDDEFINE»

/**
 * The individual steps within a flow.
 */
«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::ExecutionEdgeDestination-»
	«EXPAND exception FOR throwException("Unknown operation contents node: " + this)»
«ENDDEFINE»

«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::CancelNode-»
	«IF exceptionText.length > 0»
		«IF php»
		throw new IamlRuntimeException("«exceptionText»");
		«ELSE»
		throw new IamlJavascriptException("«exceptionText»");
		«ENDIF»
	«ELSE»
		// ignored cancel node "«this»" since it did not have an exception text
	«ENDIF»
«ENDDEFINE»

«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::StartNode-»
	«EXPAND exception FOR throwException("Should never have the executionFlowStep start at a StartNode: use executionFlow.")»
«ENDDEFINE»

«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::FinishNode-»
	// operation finished successfully
	«IF php»
		$completed_«safeName(start)» = true;
	«ELSE»
		completed_«safeName(start)» = true;
	«ENDIF»
«ENDDEFINE»

/**
 * We implement split nodes lazily; each branch is executed in sequence.
 *
 * Each split node will continue execution as normal until it reaches a
 * JoinNode, then it will stop.
 *
 * The second part of this template will iterate down the first split
 * path until it finds a JoinNode; we define this as the end of the split,
 * and continue execution from there.
 *
 * This assumes that all splits and joins occur with the same edges, etc. 
 *
 * TODO: What about recursive split/joins? 
 * TODO: What about multi level split/joins? e.g.
 *       |-> b ->|-> f ->|
 *   a ->|-> c ->|       |-> g
 *       |-> d ----> e ->|
 */ 
# @implementation SplitNode,JoinNode Currently execution split is implemented in a single threaded way; each {@model ExecutionEdge execution flow} is executed sequentially until all flows are complete. 
«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::SplitNode-»
	/* a split node */
	
	«REM»
		disable function_queue until we get to the end.
		this is necessary, otherwise all split functions in
		here will call the same function_queue multiple times.
	
		one side effect of this is that any splitted "set" operations
		will only get to the first "set" operation before
		the function queue (which may be a redirect to another page)
		executes, so the other "set" operations would not complete.	
	«ENDREM»
	«IF !php»
		«REM»
		// disable function queue over split
		var function_queue_split_«safeName()» = function_queue;
		var function_queue_queued_split_«safeName()» = function_queue_queued;
		function_queue = function() { };
		function_queue_queued = false;
		«ENDREM»

		/* we wrap up the function queue in N layers, so we
		 can progressively unwrap it as it is executed */
		
		var function_queue_wrapped_«safeName()» = function_queue;
		var function_queue_wrapped_«safeName()»_count = «outExecutions.size»;
		
		function_queue = function() {
			function_queue_wrapped_«safeName()»_count--;
			
			if (function_queue_wrapped_«safeName()»_count == 0) {
				function_queue_wrapped_«safeName()»();	// execute it
			} else if (function_queue_wrapped_«safeName()»_count < 0) {
				throw new IamlJavascriptException("Ran out of function queue wrapping: «this»");
			} else {
				// expected
			}
		}
	«ENDIF»
	
		
	«REM»
		we emulate split nodes by adding additional layers of
		call stacks, in a similar way to StartNode, for each
		outgoing edge
	«ENDREM»
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowInternal(container, php, {e}) FOR this» 
	«ENDFOREACH»
	
	«REM»
		find the target join node for this split node; this is
		where execution will continue (and set the next step
		in the call stack)
	«ENDREM»
	// final join node = «findFinalJoinNode(this)»
	«IF findFinalJoinNode(this) != null»
		«EXPAND executionFlowStep(start, container, php) FOR findFinalJoinNode(this)»
	«ELSE»
		«EXPAND exception FOR throwException("No join node found for split node '" + this + "'")»
	«ENDIF»
	
	«REM»
	«IF !php»
		// restore function queue after split
		function_queue = function_queue_split_«safeName()»;
		function_queue_queued = false;
	«ENDIF»
	«ENDREM»

«ENDDEFINE»

«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::JoinNode-»
	// split finished successfully
	«IF php»
		$completed_«safeName(start)» = true;
	«ELSE»
		completed_«safeName(start)» = true;
	«ENDIF»
«ENDDEFINE»

/* a primitive operation: carry on */
«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::PrimitiveOperation-»
	// primitive operation "«name-»"
	«EXPAND Contents::operationContents(start, container, php) FOR this-»
	
	«REM»Contents::operationContents() will expand outgoing executions as necessary«ENDREM»
	
	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/* a decision operation: expandOperationContents will continue the execution flow */
«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::DecisionOperation-»
	// decision operation "«name-»"
	«EXPAND Contents::operationContents(start, container, php) FOR this-»

	«REM»Contents::operationContents() will expand outgoing executions as necessary«ENDREM»

	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/* an operation call: expand for any parameters */
«DEFINE executionFlowStep(model::ExecutionEdgesSource start, model::visual::Page container, Boolean php) FOR model::operations::OperationCallNode-»
	// virtual operation call "«name-»"

	«REM»
		if we are in javascript, and 
		if the remote operation to call is part of a DomainObject, then
		we need to call it remotely. this is because the JS might be
		out-of-date.
	«ENDREM»
	«IF !php && model::DomainObjectInstance.isInstance(outEdges.typeSelect(model::wires::RunInstanceWire).first().to.eContainer)»
		// function call_remote_event(container, operation_name, arg0, arg1, function_queue = false) {
		var old_function_queue_«safeName()» = function_queue;
		var function_queue = function(response) {
		 	if (response == "ok") {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getPassFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
				old_function_queue_«safeName()»();
		 	} else {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getFailFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
				old_function_queue_«safeName()»();
			}
		};
		function_queue_queued = true;
		«EXPAND OperationCall::callRemoteOperation(php, false, container) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire)-»
	«ELSE»
		«REM»We assume '$result' will be set as the result of this operation call.«ENDREM»
		«EXPAND OperationCall::callOperation(php, false, container) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire)-»
		
		«IF getFailFlows().isEmpty || getPassFlows().isEmpty»
			/* No conditional flows; it was just an operation call */
			«FOREACH getFailFlows() AS e-»
				«EXPAND addStack(start, php) FOR e»
			«ENDFOREACH»
			«FOREACH getPassFlows() AS e-»
				«EXPAND addStack(start, php) FOR e»
			«ENDFOREACH»
		«ELSE»		
			/* Condition flow for virtual operation '«name»' */
			if (!«IF php»$result«ELSE»result«ENDIF») {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getFailFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
			} else {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getPassFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
			}
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

/**
 * Continue operations chained onto the current one.
 * TODO more documentation required. When are chained conditions used?
 */
# @implementation PrimitiveOperation,ExecutionEdge After a {@model PrimitiveOperation}, all outgoing {@model ExecutionEdge ExecutionEdges} are executed sequentially.
«DEFINE continueChainedOperations(Boolean php) FOR model::PrimitiveOperation-»
	«EXPAND continueChainedOperations(php) FOREACH outEdges»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Cannot continue a chained operation for " + this)»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::wires::NavigateWire»
	«IF name != "fail"»
		«IF php»
			«IF model::visual::Page.isInstance(to)»
			/* prevent infinite loops on the current page */
			if ("«((model::visual::Page) to).id»" != CURRENT_PAGE) {
			«ELSE»
			if (true) {
			«ENDIF»
				// navigate to another page
				$url = "«safeName(to)».php";
				log_message("Redirecting to '$url'");
				header("Location: $url");
				die;
			}
		«ELSE»
			// navigate to another page
			var url = "«safeName(to)».php";
			debug("Redirecting to '" + url + "'");
			window.location = url;
			ajaxIncrement();	// prevent other events from executing
		«ENDIF»
	«ELSE»
		// ignoring fail wire
	«ENDIF»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
