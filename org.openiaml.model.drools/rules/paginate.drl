/**
 * Rules related to DomainIterators connected to InputForms for
 * pagination, etc.
 */
package org.openiaml.model.drools.rules.paginate

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.datatypes.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

/**
 * @inference DomainIterator,InputForm,SelectWire
 *		An {@model InputForm} connected to a {@model DomainIterator},
 *		populated by a {@model SelectWire} that will return {@model SelectWire#limit many results},
 *		will contain {@model Button}s named 'Next', 'Previous', 'First' and 'Last'.
 */
rule "Create navigation buttons for InputForms when connected to DomainIterators with many results"
	when
		object : DomainSchema ( )
		instance : DomainIterator ( limit != 1 )
		
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( from == domainSource, to == object )
		select : SelectEdge ( from == instance, to == domainSource )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )
				
		not ( button : VisibleThing ( eContainer == form, name == "Next" ) )
		not ( button : VisibleThing ( eContainer == form, name == "Previous" ) )
		not ( button : VisibleThing ( eContainer == form, name == "First" ) )
		not ( button : VisibleThing ( eContainer == form, name == "Last" ) )

		eval ( handler.veto( select ))
		
	then
		Button next = handler.generatedButton(select, form);
		handler.setName(next, "Next");
		queue.add(next, drools);

		Button previous = handler.generatedButton(select, form);
		handler.setName(previous, "Previous");
		queue.add(previous, drools);

		Button first = handler.generatedButton(select, form);
		handler.setName(first, "First");
		queue.add(first, drools);

		Button last = handler.generatedButton(select, form);
		handler.setName(last, "Last");
		queue.add(last, drools);

end

/**
 * @inference DomainIterator,InputForm,SelectWire
 *		An {@model InputForm} connected to a {@model DomainIterator},
 *		populated by a {@model SelectWire} that will return {@model SelectWire#limit many results},
 *		will contain a {@model Label} named 'Results'.
 */
rule "Create 'Results' Label for InputForms when connected to DomainIterators with many results"
	when
		object : DomainSchema ( )
		instance : DomainIterator ( limit != 1 )
		
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( from == domainSource, to == object )
		select : SelectEdge ( from == instance, to == domainSource )
				
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		not ( button : VisibleThing ( eContainer == form, name == "Results" ) )

		eval ( handler.veto( select ))
		
	then
		Label label = handler.generatedLabel(select, form);
		handler.setName(label, "Results");
		queue.add(label, drools);

end

rule "Connect Next button to 'next' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		next : Button ( eContainer == form, name == "Next" )
		onClick : EventTrigger ( next.onClick == onClick )
		
		nextOp : Operation ( instance.next == nextOp )
	
		not ( run : ActionEdge ( from == onClick, to == nextOp ))  
		
		eval ( handler.veto( next ))

	then
		ActionEdge run = handler.generatedActionEdge(next, next, onClick, nextOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'hasNext' condition to Next button action"
	when
		instance : DomainIterator (  )
		hasNext : Condition ( instance.hasNext == hasNext )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		next : Button ( eContainer == form, name == "Next" )
		onClick : EventTrigger ( next.onClick == onClick )
		
		nextOp : Operation ( instance.next == nextOp )
		run : ActionEdge ( from == onClick, to == nextOp )
	
		not ( ce : ConditionEdge ( from == hasNext, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, next, hasNext, run);
		queue.add(ce, drools);

end

rule "Connect Previous button to 'previous' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		prev : Button ( eContainer == form, name == "Previous" )
		onClick : EventTrigger ( prev.onClick == onClick )
		
		prevOp : Operation ( instance.previous == prevOp )
	
		not ( run : ActionEdge ( from == onClick, to == prevOp ))  
		
		eval ( handler.veto( prev ))

	then
		ActionEdge run = handler.generatedActionEdge(prev, prev, onClick, prevOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'hasPrevious' condition to Previous button action"
	when
		instance : DomainIterator (  )
		hasPrevious : Condition ( instance.hasPrevious == hasPrevious )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		prev : Button ( eContainer == form, name == "Previous" )
		onClick : EventTrigger ( prev.onClick == onClick )
		
		prevOp : Operation ( instance.previous == prevOp )
		run : ActionEdge ( from == onClick, to == prevOp )
	
		not ( ce : ConditionEdge ( from == hasPrevious, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, prev, hasPrevious, run);
		queue.add(ce, drools);

end

rule "Connect First button to 'reset' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		first : Button ( eContainer == form, name == "First" )
		onClick : EventTrigger ( first.onClick == onClick )
		
		resetOp : Operation ( instance.reset == resetOp )
	
		not ( run : ActionEdge ( from == onClick, to == resetOp ))  
		
		eval ( handler.veto( first ))

	then
		ActionEdge run = handler.generatedActionEdge(first, first, onClick, resetOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'not empty' condition to First button action"
	when
		instance : DomainIterator (  )
		notEmpty : Condition ( eContainer == instance, name == "not empty" ) 
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		first : Button ( eContainer == form, name == "First" )
		onClick : EventTrigger ( first.onClick == onClick )
		
		resetOp : Operation ( instance.reset == resetOp )
		run : ActionEdge ( from == onClick, to == resetOp )
	
		not ( ce : ConditionEdge ( from == notEmpty, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, first, notEmpty, run);
		queue.add(ce, drools);

end

rule "Connect Last button to 'jump' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		
		jumpOp : Operation ( instance.jump == jumpOp )
	
		not ( run : ActionEdge ( from == onClick, to == jumpOp ))  
		
		eval ( handler.veto( last ))

	then
		ActionEdge run = handler.generatedActionEdge(last, last, onClick, jumpOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'not empty' condition to Last button action"
	when
		instance : DomainIterator (  )
		notEmpty : Condition ( eContainer == instance, name == "not empty" ) 
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
	
		not ( ce : ConditionEdge ( from == notEmpty, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, last, notEmpty, run);
		queue.add(ce, drools);

end

rule "Create 'target' property in Last button"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		
		not ( property : Property ( eContainer == last, name == "target" ))
		
		eval ( handler.veto( last ))

	then
		Property property = handler.generatedProperty(last, last);
		handler.setName(property, "target");
		queue.add(property, drools);
		
end

rule "Connect 'target' property to ActionEdge in Last button"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		property : Property ( eContainer == last, name == "target" )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( run ))

	then
		ParameterEdge param = handler.generatedParameterEdge(run, last, property, run);
		queue.add(param, drools);
		
end

rule "'Last' button will have a CompositeOperation named 'update target'"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		
		not ( op : Operation ( eContainer == last, name == "update target" )) 
		
		eval ( handler.veto( last ))

	then
		CompositeOperation op = handler.generatedCompositeOperation(last, last);
		handler.setName(op, "update target");
		queue.add(op, drools);
		
end

rule "'Last' button needs to call 'update target' before calling 'reset'"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		property : Property ( eContainer == last, name == "target" )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
		
		op : Operation ( eContainer == last, name == "update target" )
		
		not ( run2 : ActionEdge ( from == onClick, to == op ) ) 
		
		eval ( handler.veto( last ))

	then
		ActionEdge run2 = handler.generatedActionEdge(last, last, onClick, op);
		handler.setName(run2, "update target");
		handler.setPriority(run2, run.getPriority() + 100); 	// higher = run earlier
		queue.add(run2, drools);
		
end

rule "Create contents of 'update target' operation"
	when
		instance : DomainIterator (  )
		results : Property ( instance.results == results )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		last : Button ( eContainer == form, name == "Last" )
		target : Property ( eContainer == last, name == "target" )

		op : CompositeOperation ( eContainer == last, name == "update target" )
		
		not ( StartNode ( eContainer == op ))

	then
		StartNode start = handler.generatedStartNode(op, op);
		FinishNode finish = handler.generatedFinishNode(op, op);
		queue.add(start, drools);
		queue.add(finish, drools);
		
		PrimitiveOperation setOp = handler.generatedPrimitiveOperation(op, op);
		handler.setName(setOp, "set");
		queue.add(setOp, drools);
		
		StaticValue one = handler.generatedStaticValue(op, op);
		handler.setName(one, "one");
		handler.setValue(one, "1");
		handler.setType(one, BuiltinDataTypes.getTypeInteger());
		queue.add(one, drools);
		
		Arithmetic subtract = handler.generatedArithmetic(op, op);
		handler.setType(subtract, ArithmeticOperationTypes.SUBTRACT);
		queue.add(subtract, drools);
		
		DataFlowEdge d1 = handler.generatedDataFlowEdge(op, op, results, subtract);
		DataFlowEdge d2 = handler.generatedDataFlowEdge(op, op, one, subtract);
		DataFlowEdge d3 = handler.generatedDataFlowEdge(op, op, subtract, setOp);
		DataFlowEdge d4 = handler.generatedDataFlowEdge(op, op, setOp, target);
		
		queue.add(d1, drools);
		queue.add(d2, drools);
		queue.add(d3, drools);
		queue.add(d4, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(op, op, start, setOp);
		ExecutionEdge e2 = handler.generatedExecutionEdge(op, op, setOp, finish);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		
end

/**
 * @implementation EventTrigger,DomainIterator
 *		The '{@model Changeable#onChange}' event for a {@model DomainIterator}
 *		is executed when the results, that the {@model DomainIterator} represent, change.
 */
rule "Connect Instance.onChange to Results.update"
	when
		instance : DomainIterator (  )
		event : EventTrigger ( instance.onChange == event )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )
	
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		not ( run : ActionEdge ( from == event, to == updateOp ) )
		
		eval ( handler.veto( set ))
		
	then
		ActionEdge run = handler.generatedActionEdge(set, set, event, updateOp);
		handler.setName(run, "update");
		queue.add(run, drools);
		
end

rule "Connect results parameter to Results label update (onChange)"
	when
		instance : DomainIterator (  )
		event : EventTrigger ( instance.onChange == event )
		
		form : InputForm ( )
		set : SetWire ( from == instance, to == form )

		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		run : ActionEdge ( from == event, to == updateOp )
		property : Property ( instance.results == property )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( set ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(set, set, property, run);
		queue.add(param, drools);
		
end

/**
 * @implementation InputForm,DomainIterator
 *		The '{@model Accessible#onAccess}' event for a paginated {@model InputForm}
 *		is executed when the {@model DomainIterator} is accessed for the first time.
 */
rule "Connect Instance.onAccess to Results.update"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		event : EventTrigger ( form.onAccess == event )
		set : SetWire ( from == instance, to == form )
	
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		not ( run : ActionEdge ( from == event, to == updateOp ) )
		
		eval ( handler.veto( set ))
		
	then
		ActionEdge run = handler.generatedActionEdge(set, set, event, updateOp);
		handler.setName(run, "update");
		queue.add(run, drools);
		
end

rule "Connect results parameter to Results label update (onAccess)"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		event : EventTrigger ( form.onAccess == event )
		set : SetWire ( from == instance, to == form )

		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		run : ActionEdge ( from == event, to == updateOp )
		property : Property ( instance.results == property )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( set ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(set, set, property, run);
		queue.add(param, drools);
		
end
