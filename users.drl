#created on: 4/11/2008
package org.openiaml.model.drools.rules.users

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.datatypes.*;

import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "When a session is protected by an AccessControlHandler with no login handler[type=user], add it"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		
		not (LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session ))
	then
		LoginHandler lh = handler.generatedLoginHandler(ach, session);
		handler.setValue(lh, ComponentsPackage.eINSTANCE.getLoginHandler_Type(), LoginHandlerTypes.USER);
		handler.setName(lh, "role-based login handler");
		queue.add(lh, drools);

end

rule "When a page is protected by an AccessControlHandler with no login handler[type=user], add it"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == page, overridden == false )
		
		not (LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session ))
		
		# no AccessControlHandler within the session too (the above rule will create one)
		not (AccessControlHandler ( eContainer == session ))

	then
		LoginHandler lh = handler.generatedLoginHandler(ach, session);
		handler.setValue(lh, ComponentsPackage.eINSTANCE.getLoginHandler_Type(), LoginHandlerTypes.USER);
		handler.setName(lh, "role-based login handler");
		queue.add(lh, drools);

end

/**
 * Issue 206: Allow AccessControlHandlers to specify target Login pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'login' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the login Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Login page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "login" )
		
		not ( ActionEdge( from == login_handler, name == "login" ))

	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "login");
		queue.add(edge, drools);

end

/**
 * Allow AccessControlHandlers to specify target Logout pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'logout' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the logout Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Logout page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "logout" )
		
		not ( ActionEdge( from == login_handler, name == "logout" ))
		
	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "logout");
		queue.add(edge, drools);

end

/**
 * Allow AccessControlHandlers to specify target Success pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'success' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the successful login Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Success page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "success" )
		
		not ( ActionEdge( from == login_handler, name == "success" ))

	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "success");
		queue.add(edge, drools);

end

rule "A page within a session protected by an ACH should have a 'permissions check' operation"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session, overridden == false )

		not ( Operation ( eContainer == page, name == "permissions check" ))

	then
		CompositeOperation check = handler.generatedCompositeOperation(ach, page);
		handler.setName(check, "permissions check");
		queue.add(check, drools);	

end

rule "A page protected by an ACH should have a 'permissions check' operation"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page, overridden == false )

		not ( Operation ( eContainer == page, name == "page permissions check" ))
	
	then
		CompositeOperation check = handler.generatedCompositeOperation(ach, page);
		handler.setName(check, "page permissions check");
		queue.add(check, drools);	

end

rule "Connect 'permissions check' up to the 'access' event of the session (ACH in session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		access : EventTrigger ( eContainer == page, page.onAccess == access ) 
		check : Operation ( eContainer == page, name == "permissions check" )
		
		not ( ActionEdge ( from == access, to == check ))
	
	then
		ActionEdge run = handler.generatedActionEdge(ach, page, access, check);
		handler.setName(run, "run");
		queue.add(run, drools); 	

end 

rule "Connect 'permissions check' up to the 'access' event of the page (ACH in page)"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page, overridden == false )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : Operation ( eContainer == page, name == "page permissions check" )
		
		not ( ActionEdge ( from == access, to == check ))

	then
		ActionEdge run = handler.generatedActionEdge(ach, page, access, check);
		handler.setName(run, "run");
		queue.add(run, drools); 	

end 

rule "Connect fail wire from 'permissions check' to 'login page'"
	when
		root : InternetApplication ( )
		session : Session ( eContainer == root )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : CompositeOperation ( eContainer == page, name == "permissions check" )
		lh : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		login : Frame ( name == "login", eContainer == root ) 
		
		not ( ActionEdge ( from == check, to == login, name == "fail" ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(ach, page, check, login);
		handler.setName(nav, "fail");
		queue.add(nav, drools);

end

rule "Connect fail wire from 'permissions check' to 'login page' (in separate login session)"
	when
		root : InternetApplication ( )
		session : Session ( eContainer == root )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : CompositeOperation ( eContainer == page, name == "permissions check" )
		lh : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		login_session : Session ( eContainer == root, eval(functions.loginHandlerScopeMatches( login_session, lh )) )
		login : Frame ( name == "login", eContainer == login_session ) 
		
		not ( ActionEdge ( from == check, to == login, name == "fail" ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(ach, page, check, login);
		handler.setName(nav, "fail");
		queue.add(nav, drools);

end

rule "If a Role is defined, a default role User is also defined"
	when
		root : InternetApplication ( overridden == false )
		exists ( r : Role ( eContainer == root ))
		
		not ( Role ( name == "User", eContainer == root ))
					
	then
		Role user = handler.generatedRole(root, root);
		handler.setName(user, "User");
		queue.add(user, drools);

end

rule "'User' role contains a default attribute 'email'"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root, overridden == false )
		
		not ( DomainAttribute ( name == "email", eContainer == user ))
	
	then
		DomainAttribute attr = handler.generatedDomainAttribute(user, user);
		handler.setName(attr, "email");
		handler.setType(attr, BuiltinDataTypes.getTypeEmail());
		queue.add(attr, drools);

end

rule "'User' role contains a default attribute 'password'"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root, overridden == false )
		
		not ( DomainAttribute ( name == "password", eContainer == user ))
	
	then
		DomainAttribute attr = handler.generatedDomainAttribute(user, user);
		handler.setName(attr, "password");
		// TODO set type to iamlPassword
		queue.add(attr, drools);

end

# TODO can we refactor these from [User/Session] pairs into an abstract 'Scope'?
/**
 * It doesn't matter whether the ACH is in the Session or in a Frame; 
 * the LoginHandler will always have the same input class (User role),
 * as the actual check logic is handled by the 'permissions check'
 * method.
 */
rule "A LoginHandler of type 'user' should have an incoming Role as a parameter, defaulting to User"
	when
		root : InternetApplication ( )
		session : Session( ) 
		login_handler : LoginHandler ( eContainer == session, type == LoginHandlerTypes.USER, overridden == false )
		
		exists ( 
			// it doesn't matter if the ACH is in the session or the page
			ach : AccessControlHandler ( eContainer == session 
				|| eval(functions.containingSession(ach).equals(session)) ) and

			// the store contains either the roles or the permissions
			// referenced by the ACH; we only want one
			obj : NamedElement ( ) and
			/*
				TODO This code doesn't work - it allows two incoming Permission/Roles to create
				multiple outgoing ParameterEdges.
				
				(( p : Permission ( ) and eval (obj == p) ) or
				( r : Role ( ) and eval (obj == r )) ) and
				*/

			RequiresEdge ( from == ach, to == obj )
		)
		
		# default Role
		user : Role ( eContainer == root, name == "User" )
	
		# if there is already an incoming parameter wire, don't connect up User
		not (ParameterEdge ( to == login_handler ))
		
		not (ParameterEdge ( from == user, to == login_handler ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(login_handler, session, user, login_handler);
		queue.add(param, drools);

end

rule "Create 'check permissions' operation in AccessControlHandler"
	when
		ach : AccessControlHandler( overridden == false )
		
		not ( Operation ( name == "check permissions", eContainer == ach ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(ach, ach);
		handler.setName(op, "check permissions");
		queue.add(op, drools);

end

rule "Create contents of 'permissions check' operation in a Frame (session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )

		check : CompositeOperation ( eContainer == page, name == "permissions check", overridden == false )
		ach_check : Operation ( eContainer == ach, name == "check permissions" )
		
		not ( StartNode( eContainer == check ))	

	then
			
		StartNode start = handler.generatedStartNode(check, check);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(check, check);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(check, check);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Error: You do not have valid permissions. You may need to login.");
		queue.add(cancel, drools);
		
		# virtual operation call
		OperationCallNode opCall = handler.generatedOperationCallNode(check, check);
		handler.setName(opCall, "call permissions operation");
		queue.add(opCall, drools);
		
		# run wire to this call
		ActionEdge run = handler.generatedActionEdge(check, check, opCall, ach_check);
		handler.setName(run, "run");
		queue.add(run, drools); 
	
		ExecutionEdge edge1 = handler.generatedExecutionEdge(check, check);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, opCall);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge2, "pass");
		handler.setFrom(edge2, opCall);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);
		
		# not ok	
		ExecutionEdge edge3 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge3, "fail");
		handler.setFrom(edge3, opCall);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

rule "Create contents of 'permissions check' operation in a Frame (page)"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page )

		check : CompositeOperation ( eContainer == page, name == "page permissions check", overridden == false )
		ach_check : Operation ( eContainer == ach, name == "check permissions" )
		
		not ( StartNode( eContainer == check ))	

	then
			
		StartNode start = handler.generatedStartNode(check, check);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(check, check);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(check, check);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Error: You do not have valid permissions. You may need to login.");
		queue.add(cancel, drools);
		
		# virtual operation call
		OperationCallNode opCall = handler.generatedOperationCallNode(check, check);
		handler.setName(opCall, "call permissions operation");
		queue.add(opCall, drools);
		
		# run wire to this call
		ActionEdge run = handler.generatedActionEdge(check, check, opCall, ach_check);
		handler.setName(run, "run");
		queue.add(run, drools); 
	
		ExecutionEdge edge1 = handler.generatedExecutionEdge(check, check);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, opCall);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge2, "pass");
		handler.setFrom(edge2, opCall);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);
		
		# not ok	
		ExecutionEdge edge3 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge3, "fail");
		handler.setFrom(edge3, opCall);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

rule "An AccessControlHandler that creates a LoginHandler should have the created 'current instance' as an incoming parameter (session)"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session, overridden == false )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		instance : DomainIterator ( eContainer == session )
		setWire : SetWire ( from == login_handler, to == instance )
		
		not ( ParameterEdge ( from == instance, to == ach )) 

	then
		ParameterEdge param = handler.generatedParameterEdge(ach, ach, instance, ach);
		queue.add(param, drools);

end

rule "A separate AccessControlHandler that creates a LoginHandler should have the created 'current instance' as an incoming parameter (page within a session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == page, overridden == false )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		instance : DomainIterator ( eContainer == session )
		setWire : SetWire ( from == login_handler, to == instance )
		
		not ( ParameterEdge ( from == instance, to == ach )) 
	
	then
		ParameterEdge param = handler.generatedParameterEdge(ach, ach, instance, ach);
		queue.add(param, drools);

end

rule "Any role should extend the default User role"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root, overridden == false )
		
		another : Role ( this != user )
		
		not ( ExtendsEdge ( from == another, to == user ))
		
	then
		ExtendsEdge ext = handler.generatedExtendsEdge(user, root, another, user);
		queue.add(ext, drools);

end

rule "The generated default User has an identical DomainSource as the extended Role"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root, overridden == false )

		exists (
			original : DomainSource ( ) and
					 
			another : Role ( this != user ) and
			
			extends : ExtendsEdge ( from == another, to == user ) and
			
			# there's a schema edge from the original source to the subclassed role
			schemaEdge : SchemaEdge ( from == original, to == another )
		)
			
		not ( SchemaEdge ( to == user ))

	then
		DomainSource original = functions.getOriginalDomainSource(user);
	
		DomainSource source = handler.generatedDomainSource(user, root);
		handler.setFile(source, original.getFile());
		handler.setType(source, original.getType());
		handler.setUrl(source, original.getUrl());
		handler.setCache(source, original.getCache());
		queue.add(source, drools);
		
		SchemaEdge edge = handler.generatedSchemaEdge(user, root, source, user);
		queue.add(edge, drools);
	
end
