«IMPORT iaml»

/**
 * TODO clarify all the different event expansions: e.g.
 * EventTrigger for Javascript, server-side PHP, HTML, etc
 */
«EXTENSION template::GeneratorExtensions»

«DEFINE pageEvents FOR model::EventTrigger-»
	// Page EventTrigger «this»
	«IF name == "init" || name == "access"-»
		// RunInstanceWires sorted by priority
		«EXPAND callOperations(false, false) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire).sortBy(e|-e.priority)-»
	«ELSE-»
		// I don't know what to do with page event "«name»"
	«ENDIF-»
«ENDDEFINE»

«DEFINE sessionEvents FOR model::EventTrigger-»
	// Session EventTrigger «this»
	«IF name == "init" || name == "access"-»
		// RunInstanceWires sorted by priority
		«EXPAND callOperations(false, false) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire).sortBy(e|-e.priority)-»
	«ELSE-»
		// I don't know what to do with session event "«name»"
	«ENDIF-»
«ENDDEFINE»

/* this is a direct copy from Page.xpt */

/* expand out the operations for the page */
«DEFINE expandOperations FOR emf::EObject-»
	«ERROR "can't expand operations for something that has none!"»
«ENDDEFINE»

/* this includes Page and Session */
«DEFINE expandOperations FOR model::ContainsOperations-»
	«EXPAND expandOperation FOREACH operations-»
«ENDDEFINE»

«DEFINE expandOperations FOR model::ApplicationElementContainer-»
	// expanding operations for «this»
	«EXPAND expandOperation FOREACH allContainerOperations()-»
«ENDDEFINE»

«DEFINE expandOperation FOR model::Operation-»
	/* simple operation */
	function do_«safeName()»(«EXPAND expandParameters FOREACH parameters SEPARATOR ", "-») {
		log_message("simple operation: «name»");
	}
«ENDDEFINE»

«DEFINE expandOperation FOR model::CompositeOperation»
	/** composite operation "«name»" */
	$running_«safeName()» = false;
	function do_«safeName()»(«EXPAND expandParameters FOREACH parameters SEPARATOR ", "-») {
		«REM»here we would expand out the data flow of the operation, etc«ENDREM»
		// operation: «name»
		global $running_«safeName()-»;
		if ($running_«safeName()-» == false && !has_running_function("«safeName()-»")) {
			$running_«safeName()-» = true;		// prevent loops
			add_running_function("«safeName()-»");
			
			// has this operation got a fail handler?
			«IF getFailEdge() != null»
				// fail edge «getFailEdge()»
				try {
			«ENDIF»
			
			// temporary variables (if any)
			«EXPAND temporaryVariable FOREACH variables.typeSelect(model::TemporaryVariable)»			
			
			// execute the operation
			«EXPAND doExecutionFlow FOR startNode()-»

			// continue chained operations
			«EXPAND continueChainedOperations FOR this»
			
			«IF getFailEdge() != null»
				} catch (IamlRuntimeException $e) {
					log_message("Caught exception $e");
					«EXPAND expandFailEdge FOR getFailEdge()»
				}
			«ENDIF»
			
			$running_«safeName()-» = false;
			remove_running_function("«safeName()-»");
		}
	}
«ENDDEFINE»

«DEFINE temporaryVariable FOR model::TemporaryVariable»
	$temp_«safeName()-» = null;	/* temporary variable '«safeNameString(name)-»' */
«ENDDEFINE»

«DEFINE expandParameters FOR model::Parameter-»
	$«safeName()-»
«ENDDEFINE»

/* I don't know how in JS we are supposed to handle multiple out edges yet... but we'll get there ;) */
«DEFINE doExecutionFlow FOR model::operations::StartNode-»
	// flow starts here
	«FOREACH outExecutions AS e-»
		«EXPAND doExecutionFlowNext FOR e.to-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE doExecutionFlow FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/* an edge that is the end (both StartNode and FinishNode also fall into this) */
«DEFINE doExecutionFlowNext FOR model::ExecutionEdgeDestination-»
	// do nothing «this-»
«ENDDEFINE»

«DEFINE doExecutionFlowNext FOR model::operations::CancelNode-»
	«IF exceptionText.length > 0»
		throw new IamlRuntimeException("«exceptionText»");
	«ELSE»
		// ignored cancel node "«this»"
	«ENDIF»
«ENDDEFINE»

/* a chained operation: carry on */
«DEFINE doExecutionFlowNext FOR model::ChainedOperation-»
	// chained operation «name-»
	«EXPAND expandOperationContents FOR this-»
	«FOREACH outExecutions AS e-»
		«EXPAND doExecutionFlowNext FOR e.to-»
	«ENDFOREACH»
	
	// continue chained operations
	«EXPAND continueChainedOperations FOR this»
«ENDDEFINE»

/* a decision operation: expandOperationContents will continue the execution flow */
«DEFINE doExecutionFlowNext FOR model::operations::DecisionOperation-»
	// decision operation «name-»
	«EXPAND expandOperationContents FOR this-»

	// continue chained operations
	«EXPAND continueChainedOperations FOR this»
«ENDDEFINE»

«DEFINE expandOperationContents FOR model::Operation-»
	«ERROR "Unknown operation to expand: " + this»
«ENDDEFINE»

/* expand the definition of an operation, assumed to be called as part of an existing function call */
«DEFINE expandOperationContents FOR model::ChainedOperation-»
	«REM»special operation names«ENDREM»
	«IF name == "setPropertyToValue"-»
		«REM»outflowTarget == inflowTarget«ENDREM»
		// outFlows first to = «outFlows.first().to»
		«IF containingSession(outFlows.first().to) != null»
			$_SESSION["«safeName(containingSession(outFlows.first().to))»_«safeName(outFlows.first().to)-»"] = «EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-»;
		«ELSE»
			set_application_value("«outFlows.first().to.safeName()»", «EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-»);
		«ENDIF»

		«REM»
			in the future, we might want to make this into a function that is passed
			to ajax calls and executed once the call is successful.
		«ENDREM»
		«FOREACH outExecutions AS e-»
			«EXPAND doExecutionFlowNext FOR e.to-»
		«ENDFOREACH»
		
		«REM»
			here may be a good place to connect any chained EventTriggers
		«ENDREM»
		«IF shouldExpandEventTriggers(this)»
			«EXPAND expandEventTriggersInline FOR outFlows.first().to.eContainer-»
		«ELSE»
			// we don't call additional events for «eContainer» 
		«ENDIF»
	«ELSEIF name == "set"»
		«REM»set a temporary variable«ENDREM»
		$temp_«safeName(outFlows.first().to)» = «EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-»;

		«REM»continue«ENDREM»
		«FOREACH outExecutions AS e-»
			«EXPAND doExecutionFlowNext FOR e.to-»
		«ENDFOREACH»
	«ELSEIF name == "javascriptAlert"»
		«REM»how are we supposed to throw an alert on the client from the server?«ENDREM»
		throw new IamlRuntimeException("Cannot call a Javascript alert from server-side: " . «EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-»);

		«REM»continue«ENDREM»
		«FOREACH outExecutions AS e-»
			«EXPAND doExecutionFlowNext FOR e.to-»
		«ENDFOREACH»
	«ELSE»
		«REM»an existing function on this page«ENDREM»
		«EXPAND exception FOR throwException("Unknown server-side function to expand '" + name + "': " + this)»
	«ENDIF»
«ENDDEFINE»

/* expand the definition of an operation, assumed to be called as part of an existing function call */
«DEFINE expandOperationContents FOR model::operations::DecisionOperation-»
	«REM»compare operations«ENDREM»
	if (
	«IF name == "equal?"-»
		«REM»check all inflow targets are identical«ENDREM»
		«EXPAND expandCheckInflows FOREACH inFlows SEPARATOR " == "»
	«ELSE»
		«REM»??? who knows«ENDREM»
		«ERROR "Unknown decision operation '" + this + "'"»
	«ENDIF»
	) {
		// passed (exactly one pass)
		«EXPAND doExecutionFlowNext FOR passedExectionFlow().to»
	} else {
		// failed (exactly one fail)
		«EXPAND doExecutionFlowNext FOR failedExectionFlow().to»
	}
«ENDDEFINE»

/* data flows in */
«DEFINE setPropertyToValueInflowTarget FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow edge source for server setPropertyToValue: " + this)»
«ENDDEFINE»

// TODO need to wrap value in some sort of encoding algorithm
«DEFINE setPropertyToValueInflowTarget FOR model::StaticValue»
	"«value-»" /* static value "«safeName()-»" */ 
«ENDDEFINE»

«DEFINE setPropertyToValueInflowTarget FOR model::Parameter»
	$«safeName()»
«ENDDEFINE»

«DEFINE setPropertyToValueInflowTarget FOR model::TemporaryVariable»
	$temp_«safeName()»
«ENDDEFINE»

«DEFINE expandCheckInflows FOR model::DataFlowEdge-»
	«EXPAND expandCheckInflowsName FOR from-»
«ENDDEFINE»

/** get the data for the elements we are checking */
«DEFINE expandCheckInflowsName FOR model::DataFlowEdgesSource-»
	«EXPAND exception FOR throwException("Unknown data inflow source for server expandCheckInflowsName: " + this)»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::Parameter-»
	$«safeName()-»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::TemporaryVariable-»
	$temp_«safeName()-»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::ApplicationElementProperty-»
	«IF containingSession(this) != null»
		/* a property from our session */
		require_session("«safeName(containingSession(this))»_«safeName()-»")
	«ELSE»
		get_application_property("«safeName()-»")
	«ENDIF»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::StaticValue-»
	"«value-»"
«ENDDEFINE»

/** fail edges */
«DEFINE expandFailEdge FOR model::WireEdge-»
	«ERROR "Cannot expand the fail edge '" + this + "'"»
«ENDDEFINE»

«DEFINE expandFailEdge FOR model::wires::NavigateWire-»
	// we need to navigate to the fail page
	$url = "«safeName(to)».php?fail=" . urlencode($e->getMessage());
	log_message("Redirecting to '$url' (fail)");
	header("Location: $url");
	die;
«ENDDEFINE»

/** continue operation execution */
«DEFINE continueChainedOperations FOR model::ChainedOperation-»
	«EXPAND continueChainedOperations FOREACH outEdges»
«ENDDEFINE»

«DEFINE continueChainedOperations FOR model::WireEdge»
	«ERROR "Cannot continue a chained operation for " + this»
«ENDDEFINE»

«DEFINE continueChainedOperations FOR model::wires::NavigateWire»
	«IF name != "fail"»
		// navigate to another page
		$url = "«safeName(to)».php";
		log_message("Redirecting to '$url'");
		header("Location: $url");
		die;
	«ELSE»
		// ignoring fail wire
	«ENDIF»
«ENDDEFINE»

/* if we are expanding inline a function already */
«DEFINE expandEventTriggersInline FOR emf::EObject»
	// cannot expand for non-event object
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::ContainsEventTriggers»
	«EXPAND expandEventTriggersInline FOREACH eventTriggers»
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::EventTrigger»
	// expanding inline event trigger «name»
	«IF name=="edit"»
		«EXPAND callOperations(true, false) FOREACH outEdges»
	«ELSEIF name=="access"»
		// we don't expand 'access' events inline
	«ELSE»
		«EXPAND exception FOR throwException("Unknown client-side event trigger: " + this)»
	«ENDIF»
«ENDDEFINE»


/* default: don't know what to do with a wire */
«DEFINE callOperations(Boolean inline, Boolean inStoreDb) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Unknown wire edge connected to edit trigger: " + this)»
«ENDDEFINE»

/* 
 * run a command with some parameters. this could be in inline JS or a JS block.
 * RunInstanceWire: event --> operation 
 *
 * inStoreDb is set if we are calling operations as a result of storing a value
 * in the database. instead of defining a new function 'get_db_param(...)' and
 * using this as a parameter source,
 * we instead use '$arg0', which we expect will be set already.
 * @see callOperationsParameterSource() and StoreDbPhp::expandDomainAttributeEvents()
 */
«DEFINE callOperations(Boolean inline, Boolean inStoreDb) FOR model::wires::RunInstanceWire-»
	/* eContainer == «to.eContainer» */
	
	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		/* expand conditions */
		if («EXPAND Conditions::conditionWires(this, inline, inStoreDb) FOREACH inEdges.typeSelect(model::wires::ConditionWire) SEPARATOR " && "») {
	«ENDIF»

	«IF to.eContainer.metaType.superTypes.contains( model::VisibleThing )-»
		«REM»VisibleThing includes InputTextField and Page«ENDREM»
		«REM»
			is both source and target on the same page? NOTE this
			will also return true for Event-->Operation if they are
			both on the same page.
		«ENDREM»
		«IF availableInCurrentScript(from, to)-»
			«REM»// on current page (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND callOperationParameters(this, inline, inStoreDb) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current page (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingPage(to).id)»', '«operationName(to)-»'
				«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline, inStoreDb) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingPage(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF isDomainAttribute(to.eContainer)-»
		«REM»direct field --> abstract domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline, inStoreDb) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
		); 
	«ELSEIF isDomainAttributeInstance(to.eContainer)-»
		«REM»direct field --> domain attribute instance«ENDREM»
		store_domain_attribute_«safeNameString(((model::DomainAttributeInstance) to.eContainer).id)»(
			«EXPAND callOperationParameters(this, inline, inStoreDb) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»
			«IF inEdges.typeSelect(model::wires::ParameterWire).size > 1»
				«EXPAND exception FOR throwException("Cannot have more than one incoming parameter for a DomainAttributeInstance: " + this)»
			«ENDIF»
		); 
	«ELSE-»
		alert('unknown target operation type in «to.eContainer.metaType.name»');
		«EXPAND exception FOR throwException("Unknown target operation type in '" + to.eContainer.metaType.name + "' (this=" + this + ")")»
	«ENDIF-»

	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		}
	«ENDIF»
«ENDDEFINE»


/* ditto: check or error? */
«DEFINE callOperationParameters(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::wires::ParameterWire»
	«EXPAND callOperationParametersSource(wire, inline, inStoreDb) FOR from»
«ENDDEFINE»

/* ditto: check or error? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::WireEdgesSource»
	«EXPAND exception FOR throwException("Unknown parameter wire source: " + this)»
«ENDDEFINE»

/* what is the runtime value of the parameter? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::ApplicationElementProperty»
	«IF inStoreDb»
		$arg0 /* we assume the value is already in $arg0; see store_db.php::expandDomainAttributeEvents */
	«ELSE»
		«REM»
			values stored in sessions will not always be called 'fieldValue';
			perhaps fieldValue is only those stored as part of InputTextFields, etc.
		«ENDREM»
		«IF containingSession(this) != null»
			/* a property from our session */
			require_session("«safeName(containingSession(this))»_«safeName()-»")
		«ELSE»
			«IF name == "fieldValue"»
				get_application_value("«safeName()-»", null)		
			«ELSE»
				«REM»it's not in the current session, or a fieldValue; what could it be?!«ENDREM»
				throwJavascriptException("Unknown parameter source for parameter '«name»': «this-»") &&
				get_application_value("«safeName()-»", null)
			«ENDIF»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::visual::InputTextField»
	/* implicitly from InputTextField */
	«EXPAND callOperationParametersSource(wire, inline, inStoreDb) FOR properties.select( e | e.name == "fieldValue" ).first()-»
«ENDDEFINE»

«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::StaticValue»
	"«value-»" /* static value "«name-»" */
«ENDDEFINE»

/* we are in PHP mode. TODO document when we are switching in/out of it */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::DynamicApplicationElementSet»
	/* dynamic element set "«name-»" */
	get_dynamic_elements_«safeName()-»()
«ENDDEFINE»

/* we are in PHP mode. TODO document when we are switching in/out of it */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline, Boolean inStoreDb) FOR model::visual::Page»
	/* Page "«name-»" */
	new Visual_Page("«id-»", "«name-»")
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
