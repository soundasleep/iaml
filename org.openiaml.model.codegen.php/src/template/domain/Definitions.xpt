«IMPORT iaml»

/**
 * Method definitions for accessing Domain objects and attributes.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * Expand out all domain object, instance and attribute
 * information for this InternetApplication.
 * 
 * Expected to be in PHP mode.
 */
«DEFINE domainDefinitions FOR model::InternetApplication»
	«EXPAND domainObjectDefinitions(true)»
	«EXPAND domainAttributeDefinitions(true)»
«ENDDEFINE»

/**
 * Expand out all domain object instances.
 */
«DEFINE domainObjectDefinitions(Boolean php) FOR model::InternetApplication»
	«IF php»
		require_once(ROOT_PATH . "domain/all_domain_objects.php");
	«ELSE»
		<!-- empty -->
	«ENDIF»
«ENDDEFINE»

«DEFINE allDomainObjectDefinitions FOR model::InternetApplication»
	«FILE "output/domain/all_domain_objects.php"»
		<?php
		«EXPAND template::Template::phpCheck»
		
		«EXPAND template::domain::Includes::getInclude FOREACH getRoot().getAllDomainObjects()» 
		«EXPAND RemoteDefinitions::remoteDefinitions FOREACH getRoot().eAllContents.typeSelect(model::domain::RemoteDomainObject)»

		«EXPAND GetDefinitions::getDomainObject FOREACH getRoot().getAllDomainObjectInstances()»
		«EXPAND StoreDefinitions::storeDomainObject FOREACH getRoot().getAllDomainObjectInstances()»
		«EXPAND IterateDefinitions::iterateDefinitions FOREACH getRoot().getAllDomainObjectInstances()»

		/* offset definitions for attributes not contained within a domain iterator */
		«EXPAND IterateDefinitions::iterateDefinitions FOREACH getRoot().eAllContents.typeSelect(model::DomainAttributeInstance).select(e|!model::DomainObjectInstance.isInstance(e.eContainer))»

		/**
		 * Get all of the domain joins required in this generated
		 * application. This is used to properly compose
		 * select wires, etc.
		 *
		 * TODO put this into a separate include file
		 * TODO remove [issue 178] 
		 */
		function get_all_domain_joins_old() {
			$direct_joins = array();
			
			«EXPAND DomainInheritance::defineInheritanceJoins FOREACH getRoot().getAllDomainObjects()»
			
			return $direct_joins;
		}
		
		«EXPAND domainSchemaDefinition FOREACH getRoot().getAllDomainObjects()»
		«EXPAND domainAttributeDefinition FOREACH getRoot().eAllContents.typeSelect(model::DomainAttribute)»
		«EXPAND domainSourceDefinition FOREACH getRoot().eAllContents.typeSelect(model::DomainStore)»
		«EXPAND domainIteratorDefinition FOREACH getRoot().eAllContents.typeSelect(model::DomainObjectInstance)»
		
		/* domain iterators for attributes not contained within a domain iterator */
		«EXPAND domainIteratorDefinition FOREACH getRoot().eAllContents.typeSelect(model::DomainAttributeInstance).select(e|!model::DomainObjectInstance.isInstance(e.eContainer))»
	«ENDFILE»
«ENDDEFINE»

«DEFINE domainSchemaDefinition FOR model::DomainObject»
/**
 * Domain Schema '«escapeString(name)»'
 */
class DomainSchema_«safeName()» extends DomainSchema {
	private function __construct() {
		«FOREACH attributes.select(a2|a2.outExtendsEdges.to.typeSelect(model::DomainAttribute).select(a|!a.primaryKey).isEmpty) AS a»
			$this->addAttribute(DomainAttribute_«safeName(a)»::getInstance());
		«ENDFOREACH»
		
		$this->table_name = "«safeNameString(name)»";
		$this->source_id = $this->table_name . "_id";
	}
	
	// the current instance
	static $instance = null;
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new DomainSchema_«safeName()»();
		}
		return self::$instance;
	}
	
}
«ENDDEFINE»

«DEFINE domainAttributeDefinition FOR model::DomainAttribute»
«IF !outExtendsEdges.to.typeSelect(model::DomainAttribute).select(a|!a.primaryKey).isEmpty»
	/* ignoring DomainAttribute '«escapeString(name)»': it is an extension of a non-primary key (i.e. derived) */
«ELSE»
/**
 * Domain Attribute '«escapeString(name)»'
 */
class DomainAttribute_«safeName()» extends DomainAttribute {
	private function __construct() {
		$this->isPrimaryKey = «primaryKey ? "true" : "false"»;
		$this->type = "«escapePhpString(type.uRI)»";
		$this->name = "«safeNameString(name)»";
		
		«FOREACH outExtendsEdges AS extends»
			$this->extends = DomainAttribute_«safeName(extends.to)»::getInstance();
		«ENDFOREACH»		
		$this->table_name = "«safeNameString(name)»";
		$this->source_id = $this->table_name . "_id";
	}
	
	// the current instance
	static $instance = null;
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new DomainAttribute_«safeName()»();
		}
		return self::$instance;
	}
	
}
«ENDIF»
«ENDDEFINE»

«DEFINE domainSourceDefinition FOR model::DomainStore»
/**
 * Domain Source for Domain Object '«escapeString(name)»'
 */
class DomainSource_«safeName()» extends DomainSource {
	private function __construct() {
		$this->schemas = array(
		«FOREACH children.typeSelect(model::DomainObject) AS obj»
			DomainSchema_«safeName(obj)»::getInstance(),
		«ENDFOREACH»
		);
		$this->type = '«escapePhpString(type.toString())»';
		$this->file = 'sqlite:' . ROOT_PATH . '«safeNameString(id)».db';
	}
	
	// the current instance
	static $instance = null;
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new DomainSource_«safeName()»();
		}
		return self::$instance;
	}
	
}
«ENDDEFINE»

«DEFINE domainIteratorDefinition FOR model::DomainObjectInstance»
/**
 * Domain Iterator for Domain Object Instance '«escapeString(name)»'
 */
class DomainIterator_«safeName()» extends DomainIterator {
	«IF inWires.typeSelect(model::wires::NewInstanceWire).isEmpty»
		«IF inWires.typeSelect(model::wires::SelectWire).isEmpty»
			«throwException("No SelectWire or NewInstanceWire for: " + this)»
		«ELSE»
			«EXPAND domainIteratorDefFull(autosave, this) FOR inWires.typeSelect(model::wires::SelectWire).first()»
		«ENDIF»
	«ELSE»
		«EXPAND domainIteratorDefFull(autosave, this) FOR inWires.typeSelect(model::wires::NewInstanceWire).first()»
	«ENDIF»
	
	«EXPAND domainIteratorGetStoredValues FOR this»
	
	// the current instance
	static $instance = null;
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new DomainIterator_«safeName()»();
		}
		return self::$instance;
	}

}
«ENDDEFINE»

«DEFINE domainIteratorDefinition FOR model::DomainAttributeInstance»
/**
 * Domain Iterator for Domain Attribute Instance '«escapeString(name)»'
 */
class DomainIterator_Attribute_«safeName()» extends DomainIterator {
	«IF inWires.typeSelect(model::wires::NewInstanceWire).isEmpty»
		«IF inWires.typeSelect(model::wires::SelectWire).isEmpty»
			«throwException("No SelectWire or NewInstanceWire for: " + this)»
		«ELSE»
			«EXPAND domainIteratorDefFull(autosave, this) FOR inWires.typeSelect(model::wires::SelectWire).first()»
		«ENDIF»
	«ELSE»
		«EXPAND domainIteratorDefFull(autosave, this) FOR inWires.typeSelect(model::wires::NewInstanceWire).first()»
	«ENDIF»
	
	«EXPAND domainIteratorGetStoredValues FOR this»

	// the current instance
	static $instance = null;
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new DomainIterator_Attribute_«safeName()»();
		}
		return self::$instance;
	}
	
}
«ENDDEFINE»

«DEFINE domainIteratorSchemas FOR emf::EObject»
	«throwException("Unknown SelectWire source: " + this)»
«ENDDEFINE»

«DEFINE domainIteratorSchemas FOR model::DomainObject»
	$this->schema = DomainSchema_«safeName()»::getInstance();
	$this->source = DomainSource_«safeName(eContainer)»::getInstance();
«ENDDEFINE»

«DEFINE domainIteratorSchemas FOR model::DomainAttribute»
	«IF eContainer == null»
		«throwException("Container was null: " + this)»
	«ENDIF»
	«EXPAND domainIteratorSchemas FOR eContainer»
«ENDDEFINE»

«DEFINE domainIteratorDefFull(Boolean autosave, emf::EObject container) FOR model::wires::SelectWire»
	// a SelectWire

	private function __construct() {
		«EXPAND domainIteratorSchemas FOR from»	

		«IF orderBy != null»
			$this->order_by = DomainAttribute_«safeName(orderBy)»::getInstance();
			$this->order_ascending = «orderAscending ? "true" : "false"»;
		«ELSE»
			$this->order_by = null;
			$this->order_ascending = true;
		«ENDIF»

		$this->query = «EXPAND Select::getQuery»;
		$this->is_new = false;
		$this->autosave = «autosave ? "true" : "false"»;
	}
	
	public function constructArgs() {
		return array(«EXPAND template::operations::Parameters::callParameter(true, false, true) FOREACH inParameterEdges SEPARATOR ","»);
	}
	
	public function getOffset() {
		return get_current_offset_«safeName(container)»();		
	}
	
	public function setOffset($value) {
		set_current_offset_«safeName(container)»($value);
	}
	
	public function getNewInstanceID($key) {
		throw new IamlDomainException("Cannot get the new instance ID for a non-new object: " . get_class($this));
	}
	
	public function setNewInstanceID($key, $value) {
		throw new IamlDomainException("Cannot set the new instance ID for a non-new object: " . get_class($this));
	}
«ENDDEFINE»

«DEFINE domainIteratorDefFull(Boolean autosave, emf::EObject container) FOR model::wires::NewInstanceWire»
	// a NewInstanceWire

	private function __construct() {
		«EXPAND domainIteratorSchemas FOR from»

		$this->order_by = "";
		$this->order_ascending = true;
		$this->query = "";
		
		$this->is_new = true;
		$this->autosave = «autosave ? "true" : "false"»;
	}
	
	public function constructArgs() {
		return array(
			// no args
		);
	}
	
	public function getOffset() {
		throw new IamlDomainException("Cannot get the offset for a new object: " . get_class($this));		
	}
	
	public function setOffset($value) {
		throw new IamlDomainException("Cannot set the offset for a new object: " . get_class($this));
	}

	public function getNewInstanceID($key) {
		«IF containingSession() != null»
			$key2 = "new_object_«safeNameString(containingSession().id)-»_«safeNameString(id)-»";
			if (has_session($key2)) {
				return require_session($key2);
			}
			return null;
		«ELSE»
			$key2 = "new_object_«safeNameString(containingSession().id)-»_«safeNameString(id)-»";
			if (get_application_value($key2, false) !== false) {
				return get_application_value($key2, false);
			}
			return null;
		«ENDIF»
	}
	
	public function setNewInstanceID($key, $value) {
		«IF containingSession() != null»
			$key2 = "new_object_«safeNameString(containingSession().id)-»_«safeNameString(id)-»";
			$_SESSION[$key2] = $value;
		«ELSE»
			$key2 = "new_object_«safeNameString(containingSession().id)-»_«safeNameString(id)-»";
			set_application_value($key2, $value);
		«ENDIF»
	}

«ENDDEFINE»

«DEFINE domainIteratorGetStoredValues FOR emf::EObject»
	«IF containingSession() != null»
	/**
	 * Note that PHP's <code>is_set()</code> returns <code>false</code> for variables that are set to <code>NULL</code>
	 */
	public function getStoredValue($key, $default = null) {
		$target_key = "stored_value_«safeName()-»_" . $key;
		if (has_session($target_key)) {
			return require_session($target_key);
		}
		return $default;
	}

	public function setStoredValue($key, $value) {
		$target_key = "stored_value_«safeName()-»_" . $key;
		$_SESSION[$target_key] = $value;
	}
	«ELSE»
	/**
	 * Note that PHP's <code>is_set()</code> returns <code>false</code> for variables that are set to <code>NULL</code>
	 */
	public function getStoredValue($key, $default = null) {
		$target_key = "stored_value_«safeName()-»_" . $key;
		if (get_application_value($target_key, false) !== false) {
			return get_application_value($target_key, false);
		}
		return $default;
	}

	public function setStoredValue($key, $value) {
		$target_key = "stored_value_«safeName()-»_" . $key;
		set_application_value($target_key, $value);
	}
	«ENDIF»

«ENDDEFINE»

/**
 * Expand out all domain attribute instances.
 */
«DEFINE domainAttributeDefinitions(Boolean php) FOR model::InternetApplication»
	«IF php»
		require_once(ROOT_PATH . "domain/all_domain_attributes.php");
	«ELSE»
		<script language="Javascript" type="application/javascript" src="domain/all_domain_attributes_js.php"></script>
	«ENDIF»
«ENDDEFINE»

«DEFINE allDomainAttributeDefinitions FOR model::InternetApplication»
	«FILE "output/domain/all_domain_attributes.php"»
		<?php
		«EXPAND template::Template::phpCheck»
		
		«EXPAND Includes::getInclude FOREACH getAllDomainAttributeInstances()»
	«ENDFILE»

	«FILE "output/domain/all_domain_attributes_js.php"»
		<?php
			/**
			 * This operation needs to be executed by PHP first, to allow
			 * server-side variables (such as values from databases) to be included.
			 */

			«EXPAND template::Template::commonHeader("../", "all_domain_attributes (js)")»
			«EXPAND template::Template::typeJavascript»
		?>
		
		«EXPAND StoreDefinitions::storeDomainAttribute(false) FOREACH getAllDomainAttributeInstances()»
	«ENDFILE»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
