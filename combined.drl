/**
 * Combined set of rules.
 */
package org.openiaml.model.drools.rules.combined

#list any import classes here.
import org.openiaml.model.drools.*;
import org.openiaml.model.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.datatypes.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create a containing InputForm for Autocomplete list and input"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		
		not ( form : InputForm ( eContainer == container, name == iterator.name ) )
		
		eval ( handler.veto( wire ))
	
	then
		InputForm form = handler.generatedInputForm(wire, container);
		handler.setName(form, iterator.getName());
		queue.add(form, drools);
	
end

rule "Create an input field for Autocomplete"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		not ( VisibleThing ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) ) )
		
		eval ( handler.veto( wire ))
		
	then
		InputTextField text = handler.generatedInputTextField(wire, form);
		handler.setName(text, functions.getAutocompleteInputName(attribute));
		queue.add(text, drools);
		
end

rule "Connect parameter for input field for Autocomplete"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		text : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) ) 
		fieldValue : Property ( text.fieldValue == fieldValue )
		
		not ( ParameterEdge ( from == fieldValue, to == iterator ) )
		
		eval ( handler.veto( wire ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(wire, text, fieldValue, iterator);
		handler.setName(param, attribute.getName());
		queue.add(param, drools);
		
end

rule "Update DomainIterator query if it is not set"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
	
		eval ( !functions.getAutocompleteIteratorQuery(wire).equals(iterator.getQuery()) )
				
		eval ( handler.veto( wire ))
		
	then
		handler.setQuery(iterator, functions.getAutocompleteIteratorQuery(wire));
	
end

rule "Input field for Autocomplete should update instantly"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		text : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) ) 
	
		onInput : EventTrigger ( text.onInput == onInput )
		currentInput : Property ( text.currentInput == currentInput )
		
		updateOperation : Operation ( eContainer == text, name == "update" )
		
		not ( ActionEdge ( from == onInput, to == updateOperation ))
		
		eval ( handler.veto( wire ))
		
	then
		ActionEdge run = handler.generatedActionEdge(wire, text, onInput, updateOperation);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		// add a parameter
		ParameterEdge param = handler.generatedParameterEdge(wire, text, currentInput, run);
		queue.add(param, drools);
		
end

rule "Create IteratorList"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		not ( list : IteratorList ( eContainer == form, name == iterator.name ) )
		
		eval ( handler.veto( wire ))
	
	then
		IteratorList list = handler.generatedIteratorList(wire, form);
		handler.setName(list, iterator.getName());
		queue.add(list, drools);
		
		// connected by SetWire
		SetWire set = handler.generatedSetWire(wire, iterator, iterator, list);
		handler.setName(set, "autocomplete set");
		queue.add(set, drools);
	
end

rule "IteratorList labels update the target of the Autocomplete Wire"
	when
		attribute : DomainAttribute ( )
		container : Frame ( )
		iterator : DomainIterator ( )
		
		# VisibleThing with the same name as the given attribute
		target : VisibleThing ( name == attribute.name )
		updateOperation : Operation ( eContainer == target, name == "update" )
		
		wire : AutocompleteWire ( from == iterator, to == target ) 
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# the value of the given label
		targetLabel : VisibleThing ( eContainer == list, name == attribute.name )
		value : Property ( targetLabel.fieldValue == value )
			
		# for every label within (including target label)
		label : VisibleThing ( eContainer == list )
		onClick : EventTrigger ( label.onClick == onClick )
		
		not ( ActionEdge ( from == onClick, to == updateOperation ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, label, onClick, updateOperation);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(wire, label, value, run);
		queue.add(param, drools);
	
end

rule "InternetApplication has a StaticValue 'blank' created"
	when
		container : InternetApplication ( )
	
		not ( StaticValue ( eContainer == container, value == "" ))
		
		eval ( handler.veto( container ))
		
	then
		StaticValue blank = handler.generatedStaticValue(container, container);
		handler.setName(blank, "blank");
		handler.setType(blank, BuiltinDataTypes.getTypeString());
		handler.setValue(blank, "");
		queue.add(blank, drools);
			
end

rule "IteratorList labels clear the input onClick"
	when
		ia : InternetApplication ( )
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )

		attribute : DomainAttribute ( )

		wire : AutocompleteWire ( from == iterator, to == target ) 
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# input		
		input : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) )
		updateOperation : Operation ( eContainer == input, name == "update" )
		
		blank : StaticValue ( eContainer == ia, value == "" )
		
		# for every label within
		label : VisibleThing ( eContainer == list )
		onClick : EventTrigger ( label.onClick == onClick )
		
		not ( ActionEdge ( from == onClick, to == updateOperation ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, label, onClick, updateOperation);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(wire, label, blank, run);
		queue.add(param, drools);
	
end

rule "Frame.onAccess hides the IteratorList if the input is empty"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# input
		input : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) )
		condition : Condition ( eContainer == input, name == "empty" ) 
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# 'hide' operation
		hide : Operation ( eContainer == list, name == "hide" )
		
		# Frame.onAccess
		onAccess : EventTrigger ( container.onAccess == onAccess )
		
		not ( ActionEdge ( from == onAccess, to == hide ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, container, onAccess, hide);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# ConditionEdge
		ConditionEdge edge = handler.generatedConditionEdge(wire, container, condition, run);
		queue.add(edge, drools);
	
end

rule "Frame.onAccess shows the IteratorList if the input is not empty"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# input
		input : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) )
		condition : Condition ( eContainer == input, name == "not empty" ) 
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# 'hide' operation
		hide : Operation ( eContainer == list, name == "show" )
		
		# Frame.onAccess
		onAccess : EventTrigger ( container.onAccess == onAccess )
		
		not ( ActionEdge ( from == onAccess, to == hide ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, container, onAccess, hide);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# ConditionEdge
		ConditionEdge edge = handler.generatedConditionEdge(wire, container, condition, run);
		queue.add(edge, drools);
	
end

rule "Input.onChange hides the IteratorList if the input is empty"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# input
		input : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) )
		condition : Condition ( eContainer == input, name == "empty" ) 
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# 'hide' operation
		hide : Operation ( eContainer == list, name == "hide" )
		
		# Frame.onAccess
		onChange : EventTrigger ( input.onChange == onChange )
		
		not ( ActionEdge ( from == onChange, to == hide ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, container, onChange, hide);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# ConditionEdge
		ConditionEdge edge = handler.generatedConditionEdge(wire, container, condition, run);
		queue.add(edge, drools);
	
end


rule "Input.onChange shows the IteratorList if the input is not empty"
	when
		container : Frame ( )
		target : VisibleThing ( )
		iterator : DomainIterator ( )
		
		attribute : DomainAttribute ( )
		
		wire : AutocompleteWire ( from == iterator, to == target, match == attribute )
		form : InputForm ( eContainer == container, name == iterator.name )
		
		# input
		input : InputTextField ( eContainer == form, eval (functions.getAutocompleteInputName(attribute).equals(name)) )
		condition : Condition ( eContainer == input, name == "not empty" ) 
		
		# containing list
		list : IteratorList ( eContainer == form )
		set : SetWire ( eval ( functions.connectsSet( set, iterator, list ) ) )

		# 'hide' operation
		hide : Operation ( eContainer == list, name == "show" )
		
		# Frame.onAccess
		onChange : EventTrigger ( input.onChange == onChange )
		
		not ( ActionEdge ( from == onChange, to == hide ))
		
		eval ( handler.veto( wire ))
	
	then
		ActionEdge run = handler.generatedActionEdge(wire, container, onChange, hide);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# ConditionEdge
		ConditionEdge edge = handler.generatedConditionEdge(wire, container, condition, run);
		queue.add(edge, drools);
	
end

rule "Create empty domain schema for 'test' InternetApplication"
	when
		a : InternetApplication ( name == "test" )
		not (DomainSchema ( name=="test domain schema", eContainer == a ) )

		eval ( handler.veto( a ))

	then 
		#actions
		// DomainStore ds = (DomainStore) handler.createElement( a, ModelPackage.eINSTANCE.getDomainStore(), ModelPackage.eINSTANCE.getInternetApplication_DomainStores() );
		// ds.setIsGenerated(true);
		// ds.setGeneratedBy(a);
		
		DomainSchema ds = handler.generatedDomainSchema( a, a );
		handler.setName(ds, "test domain schema");
		
		queue.add(ds, drools); // possibly infer new knowledge (this is necessary)
		
		# a schema also requires a DomainSource
		DomainSource source = handler.generatedDomainSource(a, a);
		handler.setName(source, "test domain schema source");
		queue.add(source, drools);
		
		SchemaEdge edge = handler.generatedSchemaEdge(a, a, source, ds);
		queue.add(edge, drools); 
		
end

/**
 * Since an InputForm can not yet support having a fieldValue accessible at
 * runtime (although in the future, this could be something like the title 
 * of the InputForm: TODO), we prevent the fieldValue from even being created
 * to prevent a target onAccess.init using a fieldValue that can't ever be
 * completed.
 *
 * <p>A DomainIterator also can not have a fieldValue, because it doesn't make
 * any sense at the moment. Both DomainIterator and InputForm should have this
 * incorrect inheritance of Changeable removed.
 *
 * @inference Changeable,Property 
 *		A {@model Changeable} 
 * 		contains an untyped {@model Property property} named 'fieldValue'.
 * @inference Changeable,Property 
 *		If set, the {@model Changeable#defaultValue defaultValue}
 *		is used as the default value of the created {@model Changeable#fieldValue } {@model Property property}.
 * @inference InputForm
 *		{@model InputForm}s do <em>not</em> have a {@model Property property} 
 *		named 'fieldValue' created by default.
 * @inference DomainIterator
 *		{@model DomainIterator}s do <em>not</em> have a {@model Property property} 
 *		named 'fieldValue' created by default.
 */
rule "Create field value for Changeable (untyped)"
	when
		f : Changeable( )
		not ( InputForm ( this == f ))
		not ( DomainIterator ( this == f ))
		not (prop : Property( eContainer == f, f.fieldValue != null, f.fieldValue == prop ))
			
		eval ( handler.veto( f ))
		
	then
		Property fieldValue = handler.generatedPropertyFieldValue(f, f);
		handler.setName(fieldValue, "fieldValue");
		handler.setType(fieldValue, f.getType());
		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getDefaultValue() != null) {
			handler.setDefault(fieldValue, f.getDefaultValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference Property All {@model Property Properties}
 * 		will have a {@model CompositeCondition} in its container called "is set".
 */
rule "Properties will also have a related 'is set' condition"
	when
		container : ContainsConditions ( )
		containerGe : GeneratesElements ( eval(containerGe == container) )
		value : Property ( eContainer == container )
		
		not ( Condition( eval(name.equals(value.getName() + " is set")), eContainer == container ))
	
		eval ( handler.veto( containerGe ))
	
	then
		CompositeCondition cond = handler.generatedCompositeCondition(containerGe, container);
		handler.setName(cond, value.getName() + " is set");
		queue.add(cond, drools);

end

rule "Create contents of 'X is set' operation"
	when
		container : ContainsConditions ( )
		value : Property ( eContainer == container )
		
		o : CompositeCondition( eval(name.equals(value.getName() + " is set")), eContainer == container )
		
		not ( StartNode ( eContainer == o ))
		
		eval ( handler.veto( o ))
	
	then
		
		DecisionNode decision = handler.generatedDecisionNode(o, o);
		handler.setName(decision, "is set?");
		queue.add(decision, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);

		CancelNode cancel = handler.generatedCancelNode(o, o);
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, value);
		handler.setTo(data1, decision);
		queue.add(data1, drools);

		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, decision);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, decision);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, decision);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

/**
 * Similar to issue 210: Create PrimitiveConditions by default, but
 * allow later overriding using the same semantics if it was a CompositeCondition.
 *
 * @inference VisibleThing
 *		{@model VisibleThing}s will contain a {@model Condition} named 'can cast?'.
 */
rule "Create 'can cast?' condition for VisibleThings"
	when
		tf : VisibleThing( )
		not ( condition : Condition ( name == "can cast?", eContainer == tf ))
		
		eval ( handler.veto( tf ))
	
	then
		PrimitiveCondition condition = handler.generatedPrimitiveCondition(tf, tf);
		handler.setName(condition, "can cast?");
		queue.add(condition, drools);

end

rule "Create contents of 'can cast?' condition"
	when
		tf : VisibleThing( )
		fieldValue : Property ( tf.fieldValue == fieldValue )
		c : CompositeCondition ( name == "can cast?", eContainer == tf )
		
		not ( start : StartNode ( eContainer == c ))
		
		eval ( handler.veto( c ))
	
	then
		StartNode start = handler.generatedStartNode(c, c);		
		queue.add(start, drools);
		
		Parameter param = handler.generatedParameter(c, c);
		handler.setName(param, "value");
		queue.add(param, drools);
		
		CastNode cast = handler.generatedCastNode(c, c);
		queue.add(cast, drools);
		
		DecisionNode check = handler.generatedDecisionNode(c, c);
		handler.setName(check, "can cast?");
		queue.add(check, drools);
		
		CancelNode cancel = handler.generatedCancelNode(c, c);
		queue.add(cancel, drools);
		
		FinishNode finish = handler.generatedFinishNode(c, c);
		queue.add(finish, drools);
		
		DataFlowEdge castIn = handler.generatedDataFlowEdge(c, c, param, cast);
		queue.add(castIn, drools);

		DataFlowEdge castOut = handler.generatedDataFlowEdge(c, c, cast, fieldValue);
		queue.add(castOut, drools);

		DataFlowEdge castCheck = handler.generatedDataFlowEdge(c, c, cast, check);
		queue.add(castCheck, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(c, c, start, check);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(c, c, check, cancel);
		handler.setName(edge2, "no");
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(c, c, check, finish);
		handler.setName(edge3, "yes");
		queue.add(edge3, drools);

end

/**
 * @inference InputTextField,SyncWire
 *		A {@model SyncWire} connecting two elements with a {@model Condition} 'can sync?'
 *		will only {@model ConditionEdge permit} synchronisation if the value can be {@model CastNode cast successfully}.
 */
rule "Add 'can cast?' condition check for onChange connecting to Update"
	when
		source : Changeable ( )
		target : ContainsOperations ( )
		
		sw : SyncWire ( )
		eval ( functions.connects(sw, source, target) )
		
		fieldValue : Property ( source.fieldValue == fieldValue )		

		event : EventTrigger ( source.onChange == event )
		upd : Operation ( name == "update", eContainer == target )
		
		run : ActionEdge ( from == event, to == upd )
		
		condition : Condition ( name == "can cast?", eContainer == target )
		
		not ( ce : ConditionEdge ( from == condition, to == run )) 
		
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge ce = handler.generatedConditionEdge(sw, sw, condition, run);
		handler.setName(ce, "prevent incompatible types");
		queue.add(ce, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(sw, sw, fieldValue, ce);
		queue.add(param, drools);		
	
end

/**
 * @inference SyncWire
 *		For elements connected by a {@model SyncWire}, the 'onAccess' {@model EventTrigger} executing the 'init' {@model Operation}
 *		will {@model ConditionEdge only execute} if the source {@model Property fieldValue} can be {@model CastNode cast successfully}.  
 */
rule "Add 'can cast?' condition check for onAccess connecting to Init"
	when
		source : Accessible ( )
		target : CanBeSynced ( )
		targetc : Changeable ( eval(target.equals(targetc)) )
		
		sw : SyncWire ( )
		eval ( functions.connects(sw, source, target) )
		
		fieldValue : Property ( targetc.fieldValue == fieldValue )		

		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		p2 : ParameterEdge ( from == fieldValue, to == run )
		
		condition : Condition ( name == "can cast?", eContainer == source )
		
		not ( ce : ConditionEdge ( from == condition, to == run )) 
		
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge ce = handler.generatedConditionEdge(sw, sw, condition, run);
		handler.setName(ce, "prevent incompatible types");
		queue.add(ce, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(sw, sw, fieldValue, ce);
		queue.add(param, drools);		
	
end

/**
 * @inference SyncWire
 *		For elements connected by a {@model SyncWire}, the 'onAccess' {@model EventTrigger} executing the 'init' {@model Operation}
 *		will {@model ConditionEdge only execute} if the source {@model Property fieldValue} can be {@model CastNode cast successfully}.  
 */
rule "After 'init' has been called on a typed element, call 'validate'"
	when
		source : CanBeSynced ( )
		accessible : Accessible ( )
		eval ( source == accessible )
		
		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		
		validate : Operation ( name == "validate", eContainer == source )
		
		not ( runValidate : ActionEdge ( from == event, to == validate ))
		
		eval ( handler.veto( source ))
	
	then
		ActionEdge runValidate = handler.generatedActionEdge(source, source, event, validate);
		handler.setName(runValidate, "call validate after init");
		// must be a lower priority 		
		handler.setPriority(runValidate, run.getPriority() - 10);
		queue.add(runValidate, drools);

end

/**
 * onInit->Validate() is only called if the fieldValue has been set.
 */
rule "Only call 'validate' operation onAccess if fieldValue has been set"
	when
		source : CanBeSynced ( )
		accessible : Accessible ( )
		eval ( source == accessible )
		
		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		
		validate : Operation ( name == "validate", eContainer == source )
		runValidate : ActionEdge ( from == event, to == validate )
		
		isSet : Condition ( name == "fieldValue is set", eContainer == source )
		
		not ( edge : ConditionEdge ( from == isSet, to == runValidate) )
		
		eval ( handler.veto( runValidate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(runValidate, source, isSet, runValidate);
		handler.setName(edge, "only validate if set");
		queue.add(edge, drools);

end

# TODO can we put this function into something global?
function boolean connects(Wire wire, Object a, Object b) {
	return (wire.getFrom().equals(a) && wire.getTo().equals(b)) ||
		(wire.getFrom().equals(b) && wire.getTo().equals(a));
}

/**
 * TODO these rules should be refactored somehow.
 *
 * @inference SyncWire,ActionEdge,ConditionEdge 
 *		{@model ActionEdge ActionEdges} with incoming {@model ConditionEdge conditions} will be 
 *		copied to elements created by {@model SyncWire SyncWires}.
 */
rule "Connect ConditionEdges to ActionEdges created by SyncWires (edit/update) (onChange)"
	when
		# we have a sync wire
		sw : SyncWire( )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# which has a run wire between event and operation (generated)
		event : EventTrigger( source.onChange == event )
		operation : Operation( eContainer == target, name=="update" )		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		
		# and the sync wire had a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# but our run wire doesn't 
		not (ConditionEdge (from == condition, to == run )) 
			
		eval ( handler.veto( sourceCw ))
		
	then
		# copy the condition
		ConditionEdge cw = handler.generatedConditionEdge( sourceCw, sw, condition, run );
		handler.setName(cw, "copied condition: " + sourceCw.getId());
		queue.add(cw, drools);

end

rule "Connect ConditionEdges to ActionEdges created by SyncWires (access/init) (onAccess)"
	when
		# we have a sync wire
		sw : SyncWire( )
		source : Accessible( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# which has a run wire between event and operation (generated)
		event : EventTrigger( source.onAccess == event )
		operation : Operation( eContainer == source, name=="init" )		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		
		# and targets' value is being used for source's init
		fvalue : Property ( target.fieldValue == fvalue )
		param : ParameterEdge ( from == fvalue, to == run ) 
		
		# and the sync wire had a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# but our run wire doesn't 
		not (ConditionEdge (from == condition, to == run )) 
			
		eval ( handler.veto( sourceCw ))
		
	then
		# copy the condition
		ConditionEdge cw = handler.generatedConditionEdge( sourceCw, sw, condition, run );
		handler.setName(cw, "copied condition: " + sourceCw.getId());
		queue.add(cw, drools);

end

/**
 * @inference SyncWire,ActionEdge,ConditionEdge,ParameterEdge 
 *		{@model ActionEdge ActionEdges} with incoming {@model ConditionEdge conditions} 
 *		with {@model ParameterEdge parameters} will be copied to elements 
 *		created by {@model SyncWire SyncWires}.
 */
rule "Connect ParameterEdges to ConditionEdges connected to ActionEdges created by SyncWires (edit/update) (onChange)"
	when
		# we have a syncwire
		sw : SyncWire( )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# that has created a ActionEdge
		event : EventTrigger( source.onChange == event )
		operation : Operation( eContainer == target, name=="update" )
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )

		# and this SyncWire has a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# and the ActionEdge has the same condition 
		targetCw : ConditionEdge (from == condition, to == run ) 
		
		# and the SyncWire had a parameter
		param : ParameterEdgesSource ( )
		paramWire : ParameterEdge( from == param, to == sourceCw )

		# but this wire does not have it
		not (ParameterEdge (from == param, to == targetCw ))
			
		eval ( handler.veto( sourceCw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge( sourceCw, sw, param, targetCw );
		//cw.setName("copied parameter: " + paramWire.getName());
		handler.setName(pw, "[conditions] sync from: " + paramWire.getId() + " param=" + ((GeneratedElement) param).getId() + " run=" + run.getId() );
		queue.add(pw, drools);

end

rule "Connect ParameterEdges to ConditionEdges connected to ActionEdges created by SyncWires (access/init) (onAccess)"
	when
		# we have a syncwire
		sw : SyncWire( )
		source : Accessible( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# that has created a ActionEdge
		event : EventTrigger( source.onAccess == event )
		operation : Operation( eContainer == source, name=="init" )
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )

		# and targets' value is being used for source's init
		fvalue : Property ( target.fieldValue == fvalue ) 
		param2 : ParameterEdge ( from == fvalue, to == run ) 

		# and this SyncWire has a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# and the ActionEdge has the same condition 
		targetCw : ConditionEdge (from == condition, to == run ) 
		
		# and the SyncWire had a parameter
		param : ParameterEdgesSource ( )
		paramWire : ParameterEdge( from == param, to == sourceCw )

		# but this wire does not have it
		not (ParameterEdge (from == param, to == targetCw ))
			
		eval ( handler.veto( sourceCw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge( sourceCw, sw, param, targetCw );
		//cw.setName("copied parameter: " + paramWire.getName());
		handler.setName(pw, "[conditions] sync from: " + paramWire.getId() + " param=" + ((GeneratedElement) param).getId() + " run=" + run.getId() );
		queue.add(pw, drools);

end

/**
 * @inference SetWire,ActionEdge,ConditionEdge 
 *		{@model ActionEdge ActionEdges} with incoming {@model ConditionEdge conditions} will be 
 *		copied to elements created by {@model SetWire}s.
 */
rule "Connect ConditionEdges to ActionEdges created by SetWires (edit/update) (onChange)"
	when
		# we have a sync wire
		sw : SetWire( )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# which has a run wire between event and operation (generated)
		event : EventTrigger( source.onChange == event )
		operation : Operation( eContainer == target, name=="update" )		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		
		# and the sync wire had a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# but our run wire doesn't 
		not (ConditionEdge (from == condition, to == run )) 
			
		eval ( handler.veto( sourceCw ))
		
	then
		# copy the condition
		ConditionEdge cw = handler.generatedConditionEdge( sourceCw, sw, condition, run );
		handler.setName(cw, "copied condition: " + sourceCw.getId());
		queue.add(cw, drools);

end

rule "Connect ConditionEdges to ActionEdges created by SetWires (access/init) (onAccess)"
	when
		# we have a sync wire
		sw : SetWire( )
		source : Accessible( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# which has a run wire between event and operation (generated)
		event : EventTrigger( source.onAccess == event )
		operation : Operation( eContainer == source, name=="init" )		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		
		# and targets' value is being used for source's init
		fvalue : Property ( target.fieldValue == fvalue )
		param : ParameterEdge ( from == fvalue, to == run ) 
		
		# and the sync wire had a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# but our run wire doesn't 
		not (ConditionEdge (from == condition, to == run )) 
			
		eval ( handler.veto( sourceCw ))
		
	then
		# copy the condition
		ConditionEdge cw = handler.generatedConditionEdge( sourceCw, sw, condition, run );
		handler.setName(cw, "copied condition: " + sourceCw.getId());
		queue.add(cw, drools);

end

/**
 * @inference SetWire,ActionEdge,ConditionEdge,ParameterEdge 
 *		{@model ActionEdge ActionEdges} with incoming {@model ConditionEdge conditions} 
 *		with {@model ParameterEdge parameters} will be copied to elements 
 *		created by {@model SetWire}s.
 */
rule "Connect ParameterEdges to ConditionEdges connected to ActionEdges created by SetWires (edit/update) (onChange)"
	when
		# we have a syncwire
		sw : SetWire( )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# that has created a ActionEdge
		event : EventTrigger( source.onChange == event )
		operation : Operation( eContainer == target, name=="update" )
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )

		# and this SyncWire has a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# and the ActionEdge has the same condition 
		targetCw : ConditionEdge (from == condition, to == run ) 
		
		# and the SyncWire had a parameter
		param : ParameterEdgesSource ( )
		paramWire : ParameterEdge( from == param, to == sourceCw )

		# but this wire does not have it
		not (ParameterEdge (from == param, to == targetCw ))
			
		eval ( handler.veto( sourceCw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge( sourceCw, sw, param, targetCw );
		//cw.setName("copied parameter: " + paramWire.getName());
		handler.setName(pw, "[conditions] sync from: " + paramWire.getId() + " param=" + ((GeneratedElement) param).getId() + " run=" + run.getId() );
		queue.add(pw, drools);

end

rule "Connect ParameterEdges to ConditionEdges connected to ActionEdges created by SetWires (access/init) (onAccess)"
	when
		# we have a syncwire
		sw : SetWire( )
		source : Accessible( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))  
		
		# that has created a ActionEdge
		event : EventTrigger( source.onAccess == event )
		operation : Operation( eContainer == source, name=="init" )
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )

		# and targets' value is being used for source's init
		fvalue : Property ( target.fieldValue == fvalue ) 
		param2 : ParameterEdge ( from == fvalue, to == run ) 

		# and this SyncWire has a condition
		condition : Condition ( )
		sourceCw : ConditionEdge( from == condition, to == sw )
		
		# and the ActionEdge has the same condition 
		targetCw : ConditionEdge (from == condition, to == run ) 
		
		# and the SyncWire had a parameter
		param : ParameterEdgesSource ( )
		paramWire : ParameterEdge( from == param, to == sourceCw )

		# but this wire does not have it
		not (ParameterEdge (from == param, to == targetCw ))
			
		eval ( handler.veto( sourceCw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge( sourceCw, sw, param, targetCw );
		//cw.setName("copied parameter: " + paramWire.getName());
		handler.setName(pw, "[conditions] sync from: " + paramWire.getId() + " param=" + ((GeneratedElement) param).getId() + " run=" + run.getId() );
		queue.add(pw, drools);

end

rule "Create QueryParameter for target container of DetailWire"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( )
		
		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet(instanceSet, instance, source )) )

		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		pk : DomainAttribute ( eContainer == schema, primaryKey == true ) 

		not ( queryPk : QueryParameter ( eContainer == target, name == pk.name ) )
	
		eval ( handler.veto( detail ))
	
	then
		QueryParameter qp = handler.generatedQueryParameter(detail, target);
		handler.setName(qp, pk.getName());
		queue.add(qp, drools);
	
end

/**
 * @inference DetailWire
 *		When a {@model DetailWire} is connected from a {@model Frame} that uses a
 *		{@model SelectWire selected} {@model DomainIterator}, to an empty {@model Frame},
 *		the target {@model Frame} will obtain content to select an instance from a {@model QueryParameter}.
 */
rule "Create a relevant DomainIterator, with SelectWire, in the destination for the DetailWire"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		pk : DomainAttribute ( eContainer == schema, primaryKey == true )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		queryPk : QueryParameter ( eContainer == target, name == pk.name )
		
		not ( DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) ))
	
		eval ( handler.veto( detail ))
	
	then
		DomainIterator i2 = handler.generatedDomainIterator(detail, target);
		handler.setName(i2, "Current " + schema.getName() + " instance");
		// set the query
		handler.setLimit(i2, 1);
		handler.setQuery(i2, functions.safeNameString(pk.getName()) + " = :pk");				
		queue.add(i2, drools);
		
		// connect QueryParameter
		ParameterEdge param = handler.generatedParameterEdge(detail, target, queryPk, i2);
		handler.setName(param, "pk");
		queue.add(param, drools);
	
end

/**
 * @model DetailWire
 *		If a {@model VisibleThing} to view the selected {@model DomainIterator} from a
 *		{@model DetailWire} does not exist, a {@model InputForm} will be created.
 */
rule "Create a View Instance Form for target of DetailWire"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		i2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )

		not ( VisibleThing ( eContainer == target, eval( ("View " + schema.getName()).equals(name) ) ) )
	
		eval ( handler.veto( detail ))
	
	then
		InputForm form = handler.generatedInputForm(detail, target);
		handler.setName(form, "View " + schema.getName());
		queue.add(form, drools);

end

rule "Connect View Instance Form with a SetWire to the DomainIterator"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
				
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		i2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )

		form : VisibleThing ( eContainer == target, eval( ("View " + schema.getName()).equals(name) ) )
		
		not ( set : SetWire ( eval( functions.connectsSet( set, i2, form ) ) ) )
	
		eval ( handler.veto( detail ))
	
	then
		SetWire set = handler.generatedSetWire(detail, target, i2, form);
		handler.setName(set, "set");
		queue.add(set, drools);
	
end

/**
 * @inference DetailWire
 *		When a {@model DetailWire} is connecting from a {@model InputForm} that is populated
 *		by a {@model SelectWire}, a {@model Button} will be created in the {@model InputForm}
 *		to {@model ActionEdge view} the current instance in the target {@model Frame}.
 */
rule "Create a Link Button for the source of a DetailWire"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		not ( button : VisibleThing ( eContainer == source, name == "link" )) 
	
		eval ( handler.veto( detail ))
	
	then
		Button link = handler.generatedButton(detail, source);
		handler.setName(link, "link");
		queue.add(link, drools);
	
end

rule "Create a Link Button for the source of a DetailWire: Connect ActionEdge"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		
		not ( ActionEdge ( from == onClick, to == target )) 
	
		eval ( handler.veto( detail ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(detail, source, onClick, target);
		handler.setName(nav, "View detail");
		queue.add(nav, drools);
		
end

rule "Create a Link Button for the source of a DetailWire (not IteratorList): Add Parameter from AttributeInstance"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		# ignoring IteratorLists
		not ( IteratorList ( this == source )) 
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		nav : ActionEdge ( from == onClick, to == target )

		pkAttribute : DomainAttribute ( eContainer == schema, primaryKey == true )
		pkInstance : DomainAttributeInstance ( eContainer == instance )
		ExtendsEdge ( from == pkInstance, to == pkAttribute )
		
		pk : Property ( pkInstance.fieldValue == pk ) 
		
		not ( ParameterEdge ( from == pk, to == nav ))
	
		eval ( handler.veto( detail ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(detail, source, pk, nav);
		handler.setName(param, pkAttribute.getName());
		queue.add(param, drools);
	
end

rule "Create a Link Button for the source of a DetailWire (IteratorList): Add Parameter from AttributeInstance"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : IteratorList ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		nav : ActionEdge ( from == onClick, to == target )

		pkAttribute : DomainAttribute ( eContainer == schema, primaryKey == true )
		pkInstance : DomainAttributeInstance ( eContainer == instance )
		ExtendsEdge ( from == pkInstance, to == pkAttribute )
		
		# attribute instance is connected to the Container by a SetWire or SyncWire to a Hidden
		hidden : Hidden ( eContainer == source )
		set : SetWire ( eval(functions.connectsSet(set, pkInstance, hidden) ) )
		
		pk : Property ( hidden.fieldValue == pk ) 
		
		not ( ParameterEdge ( from == pk, to == nav ))
	
		eval ( handler.veto( detail ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(detail, source, pk, nav);
		handler.setName(param, pkAttribute.getName());
		queue.add(param, drools);
	
end

/**
 * @inference DetailWire,DomainIterator
 *		The generated {@model DomainIterator} used to select one instance of a
 *		{@model DetailWire} source is given the same {@model DomainSource} as the
 *		original {@model DomainIterator}.
 */
rule "The view one DomainIterator is connected to the same DomainSource as the view many DomainIterator"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		iterator2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )
		
		not ( SelectEdge ( from == iterator2 ))		
	
		eval ( handler.veto( detail ))
	
	then
		SelectEdge select = handler.generatedSelectEdge(detail, iterator2, iterator2, domainSource);
		queue.add(select, drools); 
	
end

rule "Create a default primary key for DomainObjects which do not have one"

	when
		object : DomainSchema ( )
		not (da : DomainAttribute ( eContainer == object, primaryKey == true ) )
	
		eval ( handler.veto( object ))
	
	then	
		// create a new one
		DomainAttribute da2 = handler.generatedDomainAttribute(object, object);
		handler.setName(da2, "generated primary key");
		handler.setValue(da2, ModelPackage.eINSTANCE.getDomainAttribute_PrimaryKey(), true);
		handler.setType(da2, BuiltinDataTypes.getTypeInteger());
		queue.add(da2, drools);

end 

rule "Domain objects that extend each other will also copy over attributes, connected by ExtendsEdges"
	when
		sourceObject : DomainSchema( )
		# don't copy primary keys
		sourceAttribute : DomainAttribute ( eContainer == sourceObject, primaryKey == false )
		
		targetObject : DomainSchema ( this != sourceObject )
		
		ext : ExtendsEdge ( from == targetObject, to == sourceObject )
		
		not ( DomainAttribute ( eContainer == targetObject, name == sourceAttribute.name )) 

		eval ( handler.veto( ext ))
	
	then
		DomainAttribute copy = handler.generatedDomainAttribute(ext, targetObject);
		handler.setName(copy, sourceAttribute.getName());
		handler.setValue(copy, ModelPackage.eINSTANCE.getDomainAttribute_PrimaryKey(), sourceAttribute.isPrimaryKey());
		handler.setType(copy, sourceAttribute.getType());		// copy over type
		queue.add(copy, drools);
		
		// extends wire to maintain relationship
		ExtendsEdge ext2 = handler.generatedExtendsEdge(ext, sourceAttribute, copy, sourceAttribute);
		queue.add(ext2, drools);

end

rule "Domain objects that extend each other should include an indexable reference to the source primary key"
	when
		sourceObject : DomainSchema( )
		
		targetObject : DomainSchema ( this != sourceObject )
		
		ext : ExtendsEdge ( from == targetObject, to == sourceObject )
		
		sourceId : DomainAttribute ( eContainer == sourceObject, primaryKey == true )
		
		not ( 
		da : DomainAttribute ( eContainer == targetObject, primaryKey == false )
		and 
		ExtendsEdge ( from == da, to == sourceId ) ) 

		eval ( handler.veto( ext ))

	then
		# create the target ID attribute
		DomainAttribute id_ref = handler.generatedDomainAttribute(ext, targetObject);
		handler.setName(id_ref, sourceObject.getName() + "." + sourceId.getName());
		handler.setType(id_ref, sourceId.getType());	// copy over type of ID
		queue.add(id_ref, drools);
		
		# and set it as extends to signify relationship
		ExtendsEdge ext2 = handler.generatedExtendsEdge(ext, sourceId, id_ref, sourceId);
		queue.add(ext2, drools);		

end		

rule "Connect SyncWires for a dynamic source, referenced by XPath"
		
	when
		container : InternetApplication ( )
		ds : DynamicApplicationElementSet( eval(functions.isXPath(query)), eContainer == container )
		source : Frame ( ) 
		sw : SyncWire ( eval(functions.connects(sw, ds, source)) )
		target : Frame ( eval(source != target), eval(functions.potentialXPathMatch(container, ds, target)) )
		not ( tw : SyncWire( eval(functions.connects(tw, source, target)) ) )
			
		eval ( handler.veto( container ))
		
	then 
		SyncWire sw2 = handler.generatedSyncWire( container, container, source, target );
		handler.setName(sw2, "dynamic sync");
		queue.add(sw2, drools);
		
end

rule "Create the Condition for an XPath set"

	when
		ds : DynamicApplicationElementSet( eval(functions.isXPath(query)) )
		not ( CompositeCondition(eContainer == ds, name == 'xpath' ) )
		
		eval ( handler.veto( ds ))
	
	then
		CompositeCondition c = handler.generatedCompositeCondition(ds, ds);
		handler.setName(c, "xpath");
		queue.add(c, drools);
	
end

rule "Create the contents of the XPath condition when connected to SyncWires"
	
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(functions.isXPath(query)), eContainer == container )
		o : CompositeCondition ( eContainer == ds, name == "xpath" )
		# limit to only creating one contents of the condition
		exists ( any_sync_wire : SyncWire( )
			and cw : ConditionEdge ( from == o, to == any_sync_wire ) )
		
		not ( StartNode( eContainer == o ))
		
		eval ( handler.veto( o ))
	
	then
		# create contents
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "element");
		queue.add(parameter, drools);

		Parameter xpath = handler.generatedParameter(o, o);
		handler.setName(xpath, "xpath");
		queue.add(xpath, drools);
		
		DecisionNode dc = handler.generatedDecisionNode(o, o);
		handler.setName(dc, "xpathMatch");
		queue.add(dc, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		CancelNode cancel = handler.generatedCancelNode(o, o);
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, parameter);
		handler.setTo(data1, dc);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, xpath);
		handler.setTo(data2, dc);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, dc);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, dc);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, dc);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

/**
 * This rule used to contain the following negative existential:
 *
 * not (
 *   tw_cw : ConditionEdge ( from == condition, to == tw ) and 
 *   tw_pw : ParameterEdge ( from == ds, to == tw_cw ) and
 *   tw_pw2 : ParameterEdge ( from == target, to == tw_cw )
 * )
 *
 * In order to satisfy our requirement that there are no more than
 * one negative existential in each rule [TODO see upcoming paper],
 * we can decompose this into two rules.
 */
rule "Create the XPath ConditionEdge for generated SyncWires"
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(functions.isXPath(query)), eContainer == container )
		source : Frame ( ) 
		sw : SyncWire ( eval(functions.connects(sw, ds, source)) )
		target : Frame ( eval(source != target), eval(functions.potentialXPathMatch(container, ds, target)) )
		tw : SyncWire ( eval(functions.connects(tw, source, target)) )
		condition : CompositeCondition ( eContainer == ds )
		not (
			tw_cw : ConditionEdge ( from == condition, to == tw ) 
		)
		
		eval ( handler.veto( ds ))
	
	then
		ConditionEdge cwt = handler.generatedConditionEdge( ds, ds, condition, tw );
		handler.setName(cwt, "xpath condition (target)");
		queue.add(cwt, drools);
		
		# Create the contents like normal

		ParameterEdge pwt = handler.generatedParameterEdge( cwt, ds, ds, cwt);
		handler.setName(pwt, "[xpath] from ds 2");
		queue.add(pwt, drools);		 

		ParameterEdge pwt2 = handler.generatedParameterEdge( cwt, ds, target, cwt);
		handler.setName(pwt2, "[xpath] from target");
		queue.add(pwt2, drools);

end

/**
 * This is a decomposition of the rule above.
 */
rule "Connect ParameterEdges to empty ConditionEdge for XPath"
	when
		container : InternetApplication( )
		ds : DynamicApplicationElementSet( eval(functions.isXPath(query)), eContainer == container )
		source : Frame ( ) 
		sw : SyncWire ( eval(functions.connects(sw, ds, source)) )
		target : Frame ( eval(source != target), eval(functions.potentialXPathMatch(container, ds, target)) )
		tw : SyncWire ( eval(functions.connects(tw, source, target)) )
		condition : CompositeCondition ( eContainer == ds )
		cwt : ConditionEdge ( from == condition, to == tw )
		not (
			#tw_cw : ConditionEdge ( from == condition, to == tw ) and
			tw_pw : ParameterEdge ( from == ds, to == cwt ) 
			#and
			#tw_pw2 : ParameterEdge ( from == target, to == tw_cw )
		)
		
		eval ( handler.veto( cwt ))
	
	then
		# We have a ConditionEdge that does not have any parameters:
		# connect the parameters up to the wire

		ParameterEdge pwt = handler.generatedParameterEdge( cwt, ds, ds, cwt);
		handler.setName(pwt, "[xpath] from ds 2");
		queue.add(pwt, drools);		 

		ParameterEdge pwt2 = handler.generatedParameterEdge( cwt, ds, target, cwt);
		handler.setName(pwt2, "[xpath] from target");
		queue.add(pwt2, drools);

end

/**
 * @inference Email An {@model Email} contains a {@model Property property} named
 *		'to', if no existing {@model Property} or {@model StaticValue} exists.
 */
rule "Create 'to' property for Email"
	when
		f : Email ( to != null )
		not ( Property ( eContainer == f, name == "to" ))
		not ( StaticValue ( eContainer == f, name == "to" ))
		
		eval ( handler.veto( f ))
			
	then
		Property p = handler.generatedProperty(f, f);
		handler.setName(p, "to");
		if (f.getTo() != null) {
			handler.setDefault(p, f.getTo());
		}
		queue.add(p, drools);
		
end

/**
 * @inference Email An {@model Email} contains a {@model Property property} named
 *		'toName', if no existing {@model Property} or {@model StaticValue} exists.
 */
rule "Create 'toName' property for Email"
	when
		f : Email ( toName != null )
		not ( Property ( eContainer == f, name == "toName" ))
		not ( StaticValue ( eContainer == f, name == "toName" ))
		
		eval ( handler.veto( f ))
			
	then
		Property p = handler.generatedProperty(f, f);
		handler.setName(p, "toName");
		if (f.getToName() != null) {
			handler.setDefault(p, f.getToName());
		}
		queue.add(p, drools);
		
end

/**
 * @inference Email An {@model Email} contains a {@model Property property} named
 *		'from', if no existing {@model Property} or {@model StaticValue} exists.
 */
rule "Create 'from' property for Email"
	when
		f : Email ( from != null )
		not ( Property ( eContainer == f, name == "from" ))
		not ( StaticValue ( eContainer == f, name == "from" ))
		
		eval ( handler.veto( f ))
			
	then
		Property p = handler.generatedProperty(f, f);
		handler.setName(p, "from");
		if (f.getFrom() != null) {
			handler.setDefault(p, f.getFrom());
		}
		queue.add(p, drools);
		
end

/**
 * @inference Email An {@model Email} contains a {@model Property property} named
 *		'fromName', if no existing {@model Property} or {@model StaticValue} exists.
 */
rule "Create 'fromName' property for Email"
	when
		f : Email ( fromName != null )
		not ( Property ( eContainer == f, name == "fromName" ))
		not ( StaticValue ( eContainer == f, name == "fromName" ))
		
		eval ( handler.veto( f ))
			
	then
		Property p = handler.generatedProperty(f, f);
		handler.setName(p, "fromName");
		if (f.getFromName() != null) {
			handler.setDefault(p, f.getFromName());
		}
		queue.add(p, drools);
		
end

/**
 * @inference Email An {@model Email} contains a {@model Property property} named
 *		'subject', if no existing {@model Property} or {@model StaticValue} exists.
 */
rule "Create 'subject' property for Email"
	when
		f : Email ( subject != null )
		not ( Property ( eContainer == f, name == "subject" ))
		not ( StaticValue ( eContainer == f, name == "subject" ))
		
		eval ( handler.veto( f ))
			
	then
		Property p = handler.generatedProperty(f, f);
		handler.setName(p, "subject");
		if (f.getSubject() != null) {
			handler.setDefault(p, f.getSubject());
		}
		queue.add(p, drools);
		
end

/*
 * @inference Changeable,DomainAttribute 
 *		A {@model Changeable} thing contains an {@model EventTrigger} named 'onChange'. 
 */
rule "Create 'onChange' event trigger for Changeable things"
	when
		f : Changeable( )
		g : GeneratesElements ( eval(f == g) )
		not (event : EventTrigger( f.onChange == event ))
				
		eval ( handler.veto( g ))
			
	then
		EventTrigger event = handler.generatedEventTriggerOnChange(g, f);
		queue.add(event, drools);
		
end

/**
 * @inference Accessible
 *		An {@model Accessible} thing contains an {@model EventTrigger} named 'onAccess'.
 */
rule "Create 'onAccess' event trigger for Accessible things"
	when
		f : Accessible( )
		g : GeneratesElements ( eval(f == g) )
		not (event : EventTrigger( f.onAccess == event ))
				
		eval ( handler.veto( g ))
			
	then
		handler.veto(g);
		EventTrigger event = handler.generatedEventTriggerOnAccess(g, f);
		queue.add(event, drools);
		
end

rule "Create the Properties file DomainSchema"
		
	when
		root : InternetApplication ( )
		$fds : DomainSource ( type == DomainStoreTypes.PROPERTIES_FILE )
		
		p : ExtendedProperties ( ) from $fds.propertiesFile
		not ( schema : DomainSchema ( name == "properties" )
			and exists ( 
				edge : SchemaEdge ( )
				and eval ( functions.connectsSchema(edge, $fds, schema ))
			)
		)

		eval ( handler.veto( $fds ))

	then
		DomainSchema fdo = handler.generatedDomainSchema($fds, root);
		//handler.setValue(fdo, ModelPackage.eINSTANCE.getNamedElement_Name(), "properties");
		handler.setName(fdo, "properties");
		queue.add(fdo, drools);
		
		// and connect with SchemaEdge
		SchemaEdge edge = handler.generatedSchemaEdge($fds, fdo, $fds, fdo);
		queue.add(edge, drools);

end

// unfortunately $p.stringPropertyNames() cannot be iterated over.
// this is either because Drools expects getFieldName(), or it cannot
// iterate over Set or Collection
rule "Create DomainAttributes for Properties File DomainSchema"
		
	when
		$fds : DomainSource ( type == DomainStoreTypes.PROPERTIES_FILE )
		$p : ExtendedProperties ( ) from $fds.propertiesFile
		$key : String ( ) from $p.propertyNames
		
		schema : DomainSchema ( name == "properties" )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, $fds, schema ))
		
		not ( DomainAttribute ( eContainer == schema, name == $key ))

		eval ( handler.veto( schema ))

	then
		DomainAttribute fda = handler.generatedDomainAttribute(schema, schema);
		//handler.setValue(fda, ModelPackage.eINSTANCE.getNamedElement_Name(), $key);
		handler.setName(fda, $key);
		handler.setType(fda, BuiltinDataTypes.getTypeString());	// all Properties attributes are strings
		queue.add(fda, drools);
		
end

rule "Create 'Continue' button for Frames connected with 'first' or 'last' or 'fail' ActionEdge"
	when
		gate : Gate ( )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" || name == "fail" )
		
		not (Button ( eContainer == target, name == "Continue" ))
		not (ActionEdge ( to == gate ))
		
		eval ( handler.veto( gate ))
	
	then
		Button button = handler.generatedButton(gate, target);
		handler.setName(button, "Continue");
		queue.add(button, drools);

end

rule "Connect 'click' on 'Continue' button to resume Gate"
	when
		gate : Gate ( )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" || name == "fail" ) 
		button : Button ( eContainer == target, name == "Continue" )
		
		click : EventTrigger ( button.onClick == click, eContainer == button )
		
		not (ActionEdge ( from == click, to == gate ))
		
		eval ( handler.veto( gate ))
	
	then
		ActionEdge wire = handler.generatedActionEdge(gate, target, click, gate);
		handler.setName(wire, "resume");
		queue.add(wire, drools);

end

rule "Create '(gate) flag' property when Gate is connected by 'first' or 'last'"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session )
		
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		not (Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) ))
		
		eval ( handler.veto( gate ))
	
	then
		Property prop = handler.generatedProperty(gate, session);
		handler.setName(prop, gate.getName() + " flag");
		handler.setValue(prop, ModelPackage.eINSTANCE.getProperty_DefaultValue(), "false");
		queue.add(prop, drools);
	
end

rule "Create 'set flag' operation for Frames connected with 'first' or 'last' ActionEdge"
	when
		gate : Gate ( )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		
		not (CompositeOperation ( eContainer == target, name == "Set gate flag" ))
			
		eval ( handler.veto( gate ))
		
	then
		CompositeOperation op = handler.generatedCompositeOperation(gate, target);
		handler.setName(op, "Set gate flag");
		queue.add(op, drools);

end

rule "Connect 'access' event with 'set flag' operation"
	when
		gate : Gate ( )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		op : CompositeOperation ( eContainer == target, name == "Set gate flag" )
		access : EventTrigger ( eContainer == target, target.onAccess == access )
		
		not (ActionEdge ( from == access, to == op ))
			
		eval ( handler.veto( gate ))
		
	then
		ActionEdge run = handler.generatedActionEdge(gate, target, access, op);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Create contents of 'set flag' operation"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		property : Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) )
		
		op : CompositeOperation ( eContainer == target, name == "Set gate flag" )
		
		not (StartNode ( eContainer == op ))
			
		eval ( handler.veto( gate ))
		
	then
		StartNode start = handler.generatedStartNode(gate, op);
		FinishNode finish = handler.generatedFinishNode(gate, op);
		PrimitiveOperation set = handler.generatedPrimitiveOperation(gate, op);
		handler.setName(set, "set");
		StaticValue value = handler.generatedStaticValue(gate, op);
		handler.setName(value, "true");
		handler.setValue(value, "true");
		
		queue.add(start, drools);
		queue.add(finish, drools);
		queue.add(set, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(gate, op, start, set);
		ExecutionEdge e2 = handler.generatedExecutionEdge(gate, op, set, finish);
		DataFlowEdge d1 = handler.generatedDataFlowEdge(gate, op, value, set);
		DataFlowEdge d2 = handler.generatedDataFlowEdge(gate, op, set, property);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		queue.add(d1, drools);
		queue.add(d2, drools);

end

rule "Create condition 'check (gate)'"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		not ( Condition ( eContainer == session, eval( name.equals("check " + gate.getName())) ))
		
		eval ( handler.veto( gate ))
	
	then
		CompositeCondition cond = handler.generatedCompositeCondition(gate, session);
		handler.setName(cond, "check " + gate.getName());
		queue.add(cond, drools);

end

rule "Connect condition 'check (gate)' with gate"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		cond : Condition ( eContainer == session, eval( name.equals("check " + gate.getName())) )
		
		not ( ConditionEdge ( from == cond, to == gate ))
		
		eval ( handler.veto( gate ))
	
	then
		ConditionEdge cw = handler.generatedConditionEdge(gate, session, cond, gate);
		handler.setName(cw, "condition");
		queue.add(cw, drools);

end

rule "Create contents of 'check (gate)' condition"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		property : Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) )
		
		cond : CompositeCondition ( eContainer == session, eval( name.equals("check " + gate.getName())) )
		cw : ConditionEdge ( from == cond, to == gate )
		
		not ( StartNode ( eContainer == cond ))
		
		eval ( handler.veto( gate ))
	
	then
		StartNode start = handler.generatedStartNode(gate, cond);
		FinishNode finish = handler.generatedFinishNode(gate, cond);
		CancelNode cancel = handler.generatedCancelNode(gate, cond);
		DecisionNode cmp = handler.generatedDecisionNode(gate, cond);
		handler.setName(cmp, "true?");
		
		queue.add(start, drools);
		queue.add(finish, drools);
		queue.add(cancel, drools);
		queue.add(cmp, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(gate, cond, start, cmp);
		ExecutionEdge e2 = handler.generatedExecutionEdge(gate, cond, cmp, finish);
		handler.setName(e2, "y");
		ExecutionEdge e3 = handler.generatedExecutionEdge(gate, cond, cmp, cancel);
		handler.setName(e3, "n");
		DataFlowEdge d1 = handler.generatedDataFlowEdge(gate, cond, property, cmp);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		queue.add(e3, drools);
		queue.add(d1, drools);

end

/**
 * TODO Should the Provides page be placed into a separate Session if the protected
 * Scope by the Gate is also a Session? The current implementation requires that if the
 * data entered is to be unique, the protected Session will also have to be contained
 * within a Session itself, otherwise the generated Provides Frame will allow access
 * to the private data explicitly.
 */
rule "If an EntryGate requires a Label value, then a Page should be created outside the Scope to enter it"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		not ( provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) ) ) 
	
		eval ( handler.veto( gate ))
	
	then
		Frame provide = handler.generatedFrame(gate, container);
		handler.setName(provide, functions.getEntryGateFrameNameForProvides(label));
		queue.add(provide, drools);
	
end

rule "For EntryGates that require Label values, connect a NavigateWire to the provides Frame"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
		
		# allow other ActionEdges to override this one
		not ( ActionEdge ( from == gate )) 
	
		eval ( handler.veto( gate ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(gate, gate, gate, provide);
		handler.setName(nav, "fail");
		queue.add(nav, drools);
	
end

rule "Create TextFields for all Labels required by an EntryGate"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		not ( VisibleThing ( eContainer == provide, name == label.name ) )
		
		eval ( handler.veto( gate ))
	
	then
		InputTextField text = handler.generatedInputTextField(gate, provide);
		handler.setName(text, label.getName());
		handler.setType(text, label.getType());
		queue.add(text, drools);
	
end

rule "If an EntryGate requires a Label value, then the 'is set?' Condition in the Label is used as the Gate Condition"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		cond : Condition ( eContainer == label, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == cond, to == gate ))

		eval ( handler.veto( gate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, cond, gate);
		queue.add(edge, drools);
	
end

rule "If an EntryGate requires a Label, get the containing Scope to update the Label from the expected external source"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )
		value : Property ( field.fieldValue == value )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		not ( ActionEdge ( from == onAccess, to == op ))

		eval ( handler.veto( gate ))
	
	then
		ActionEdge run = handler.generatedActionEdge(gate, gate, onAccess, op);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# connect with Parameter
		ParameterEdge param = handler.generatedParameterEdge(gate, gate, value, run);
		queue.add(param, drools);
	
end

rule "If an EntryGate requires a Label, the Label is only updated externally if the given value has been set"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		# Scope.onAccess --> Label.update()
		run : ActionEdge ( from == onAccess, to == op )
		
		# Text.isSet?
		condition : Condition ( eContainer == field, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == condition, to == run ))

		eval ( handler.veto( gate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, condition, run);
		queue.add(edge, drools);
	
end

rule "If an EntryGate requires a Label, the Label is only updated externally if the given value can be cast to the target type"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )
		value : Property ( field.fieldValue == value )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		# Scope.onAccess --> Label.update()
		run : ActionEdge ( from == onAccess, to == op )
		
		# Label.can cast?
		condition : Condition ( eContainer == label, name == "can cast?" )
		
		not ( ConditionEdge ( from == condition, to == run ))

		eval ( handler.veto( gate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, condition, run);
		queue.add(edge, drools);
		
		# connect with fieldValue
		ParameterEdge param = handler.generatedParameterEdge(gate, gate, value, edge);
		queue.add(param, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveOperation} 
 *		called '{@model DomainIterator#previous}'.
 */
rule "Create 'previous' PrimitiveOperation"
	when
		instance : DomainIterator( )
		not ( op : Operation ( instance.previous == op ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Previous());
		handler.setName(op, "previous");
		queue.add(op, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveOperation} 
 *		called '{@model DomainIterator#next}'.
 */
rule "Create 'next' PrimitiveOperation"
	when
		instance : DomainIterator( )
		not ( op : Operation ( instance.next == op ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Next());
		handler.setName(op, "next");
		queue.add(op, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveOperation} 
 *		called '{@model DomainIterator#reset}'.
 */
rule "Create 'reset' PrimitiveOperation"
	when
		instance : DomainIterator( )
		not ( op : Operation ( instance.reset == op ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Reset());
		handler.setName(op, "reset");
		queue.add(op, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveOperation} 
 *		called '{@model DomainIterator#skip}'.
 */
rule "Create 'skip' PrimitiveOperation"
	when
		instance : DomainIterator( )
		not ( op : Operation ( instance.skip == op ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Skip());
		handler.setName(op, "skip");
		queue.add(op, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveOperation} 
 *		called '{@model DomainIterator#jump}'.
 */
rule "Create 'jump' PrimitiveOperation"
	when
		instance : DomainIterator( )
		not ( op : Operation ( instance.jump == op ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Jump());
		handler.setName(op, "jump");
		queue.add(op, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveCondition} 
 *		called '{@model DomainIterator#hasNext}'.
 */
rule "Create 'hasNext' PrimitiveCondition"
	when
		instance : DomainIterator( )
		not ( cond : Condition ( instance.hasNext == cond ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveCondition cond = handler.generatedPrimitiveCondition(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_HasNext());
		handler.setName(cond, "has next");
		queue.add(cond, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveCondition} 
 *		called '{@model DomainIterator#hasPrevious}'.
 */
rule "Create 'hasPrevious' PrimitiveCondition"
	when
		instance : DomainIterator( )
		not ( cond : Condition ( instance.hasPrevious == cond ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveCondition cond = handler.generatedPrimitiveCondition(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_HasPrevious());
		handler.setName(cond, "has previous");
		queue.add(cond, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model PrimitiveCondition} 
 *		called '{@model DomainIterator#hasNext}'.
 */
rule "Create 'empty' PrimitiveCondition"
	when
		instance : DomainIterator( )
		not ( cond : Condition ( instance.empty == cond ) )

		eval ( handler.veto( instance ))
	
	then
		PrimitiveCondition cond = handler.generatedPrimitiveCondition(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Empty());
		handler.setName(cond, "empty");
		queue.add(cond, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model Property} 
 *		called '{@model DomainIterator#results}'.
 */
rule "Create 'results' Property"
	when
		instance : DomainIterator( )
		not ( property : Property ( instance.results == property ) )

		eval ( handler.veto( instance ))
	
	then
		Property property = handler.generatedProperty(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_Results());
		handler.setName(property, "results count");
		queue.add(property, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} has a {@model EventTrigger} 
 *		called '{@model DomainIterator#onIterate}'.
 */
rule "Create 'onIterate' EventTrigger"
	when
		instance : DomainIterator( )
		not ( event : EventTrigger ( instance.onIterate == event ) )

		eval ( handler.veto( instance ))
	
	then
		EventTrigger event = handler.generatedEventTrigger(instance, instance, 
			DomainPackage.eINSTANCE.getDomainIterator_OnIterate());
		handler.setName(event, "on iterate");
		queue.add(event, drools);
	
end

/**
 * @inference DomainIterator
 *		A {@model DomainIterator} will contain a generated {@model CompositeCondition}
 *		named 'not empty' - the inverse of the '{@model Condition#empty}' condition.
 */
rule "Create 'not empty' composite condition"
	when
		instance : DomainIterator( )
		not ( condition : Condition ( eContainer == instance, name == "not empty" ) )

		eval ( handler.veto( instance ))
	
	then
		CompositeCondition condition = handler.generatedCompositeCondition(instance, instance);
		handler.setName(condition, "not empty");
		queue.add(condition, drools);
	
end

rule "Create contents of 'not empty' condition"
	when
		instance : DomainIterator( )
		isEmpty : Condition ( instance.empty == isEmpty )
		condition : CompositeCondition ( eContainer == instance, name == "not empty" )
		
		not ( StartNode ( eContainer == condition ))

		eval ( handler.veto( condition ))
	
	then
		StartNode start = handler.generatedStartNode(condition, condition);
		FinishNode finish = handler.generatedFinishNode(condition, condition);
		CancelNode cancel = handler.generatedCancelNode(condition, condition);
		queue.add(start, drools);
		queue.add(finish, drools);
		queue.add(cancel, drools);
		
		DecisionNode decision = handler.generatedDecisionNode(condition, condition);
		queue.add(decision, drools);
		
		ConditionEdge edge = handler.generatedConditionEdge(condition, condition, isEmpty, decision);
		queue.add(edge, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(condition, condition, start, decision);
		ExecutionEdge e2 = handler.generatedExecutionEdge(condition, condition, decision, finish);
		handler.setName(e2, "n");
		ExecutionEdge e3 = handler.generatedExecutionEdge(condition, condition, decision, cancel);
		handler.setName(e3, "y");
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		queue.add(e3, drools);
	
end

// issue 118
/**
 * @inference LoginHandler
 *		A {@model LoginHandler} contained within a {@model InternetApplication} will
 *		generate a {@model Session new login session} for the new {@model Frame login page}.
 */
rule "Create separate 'login' scope for LoginHandlers [InternetApplication]"
	when
		container : InternetApplication( )
		scope : Scope( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		
		not ( login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) ))
			
		eval ( handler.veto( login_handler ))
	
	then
		Session login_session = handler.generatedSession(login_handler, container);
		handler.setName(login_session, login_handler.getName() + " login");
		queue.add(login_session, drools);	
	
end

rule "Create default 'login' page for LoginHandlers"
	when
		container : InternetApplication( )
		scope : Scope( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		not ( ActionEdge ( from == login_handler, name == "login" ))
			
		eval ( handler.veto( login_handler ))
		
	then

		Frame login = handler.generatedFrame(login_handler, login_session);
		handler.setName(login, "login");
		queue.add(login, drools);
		
end

rule "Connect default 'login' page to LoginHandler"
	when
		container : InternetApplication( )
		scope : Scope( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login_page : Frame ( eContainer == login_session, name == "login" )
		
		not ( ActionEdge ( from == login_handler, to == login_page, name == "login" ))
			
		eval ( handler.veto( login_handler ))
		
	then
	
		ActionEdge edge = handler.generatedActionEdge(login_handler, login_session, login_handler, login_page);
		handler.setName(edge, "login");
		queue.add(edge, drools);
		
end

rule "Create 'logout' page for LoginHandlers"
	when
		scope : Session( ) 
		login_handler : LoginHandler( eContainer == scope )
		
		not (Frame (eContainer == scope, name=="logout" ))
				
		eval ( handler.veto( login_handler ))
		
	then

		Frame logout = handler.generatedFrame(login_handler, scope);
		handler.setName(logout, "logout");
		queue.add(logout, drools);
		
end

rule "Instruct 'logout' page to follow to the actual logout destination if set"
	when
		scope : Session( ) 
		login_handler : LoginHandler( eContainer == scope )
		
		logout : Frame (eContainer == scope, name=="logout" )
		
		destination : Frame ( this != logout )
		navigate : ActionEdge ( from == login_handler, to == destination, name == "logout")

		access : EventTrigger ( eContainer == logout, logout.onAccess == access )
		not (ActionEdge ( from == access, to == destination ))
		
		eval ( handler.veto( login_handler ))
	
	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, logout, access, destination);
		handler.setName(wire, "redirect to intended logout page");
		queue.add(wire, drools);

end

rule "Create 'key attribute' property for LoginHandler[type = key]s"
	when
		scope : Session( ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )

		not (Property (eContainer == scope, 
			name=="current login key" ) )

		# the value may not be called "current login key"
		not (
			exists ( actual_key : Property ( )
				and SetWire ( name == "set", from == login_handler, to == actual_key )
			)
		) 
		
		eval ( handler.veto( login_handler ))
		
	then

		Property key = handler.generatedProperty(login_handler, scope);
		handler.setName(key, "current login key");
		# need to set a default value, or else require_session(this) will throw an exception before we can catch it to redirect
		handler.setValue(key, ModelPackage.eINSTANCE.getProperty_DefaultValue(), "");
		queue.add(key, drools);
		
end

rule "Connect 'key' property to LoginHandler"
	when
		scope : Session( ) 
		login_handler : LoginHandler( eContainer == scope )
		key : Property (eContainer == scope,
			name == "current login key")
		not (SetWire( from == login_handler, to == key, name == "set") )
		
		eval ( handler.veto( login_handler ))

	then

		SetWire wire = handler.generatedSetWire(login_handler, scope, login_handler, key);
		handler.setName(wire, "set");
		queue.add(wire, drools);
		
end

rule "Create 'check key' operation for LoginHandler[type = key]"
	when
		scope : Session( ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )
		not (Operation( eContainer == scope, name == "check key") )
					
		eval ( handler.veto( login_handler ))
					
	then
		CompositeOperation op = handler.generatedCompositeOperation( login_handler, scope );
		handler.setName(op, "check key");
		queue.add(op, drools);
		
end

rule "Connect 'access' event to 'check' operations"
	when
		scope : Session( )
		page : Frame( eContainer == scope )
		access : EventTrigger( page.onAccess == access, eContainer == page )
		check : CompositeOperation( name == "check key" || name == "check instance", eContainer == scope )
		not (ActionEdge( from == access, to == check ))
				
		eval ( handler.veto( scope ))
		
	then
		ActionEdge wire = handler.generatedActionEdge(scope, page, access, check);
		handler.setName(wire, "run");
		handler.setPriority(wire, 100); // high priority
		queue.add(wire, drools);	
	
end

rule "Connect 'login key' parameter to 'check key' operation run wire"
	when
		scope : Session( )
		page : Frame( eContainer == scope )
		access : EventTrigger( page.onAccess == access, eContainer == page )
		check : CompositeOperation( name == "check key", eContainer == scope )
		
		login_handler : LoginHandler( eContainer == scope )
		value : Property( )
		mySetWire : SetWire( from == login_handler, to == value, name == "set" )
		
		wire : ActionEdge( from == access, to == check )
		not (ParameterEdge( from == value, to == wire ))
				
		eval ( handler.veto( scope ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(scope, page, value, wire);
		handler.setName(param, "[sessions] 'login key' parameter to 'check key'");
		queue.add(param, drools);

end

rule "Connect 'fail' wire from 'check key' or 'check instance' operation to Login Frame"
	when
		container : ContainsWires( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		check : CompositeOperation( name == "check key" || name == "check instance", eContainer == scope )
		not (ActionEdge( from == check, to == login, name == "fail") )
			
		eval ( handler.veto( scope ))
	
	then
		ActionEdge fail = handler.generatedActionEdge(scope, scope, check, login);
		handler.setName(fail, "fail");
		queue.add(fail, drools);
		
end

rule "Create contents of 'check key' operation [type=secret_key]"
	when
		scope : Session( )
		o : CompositeOperation( name == "check key", eContainer == scope )
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )
		
		expected : StaticValue( ) 
		expected_param : ParameterEdge( from == expected, to == login_handler )
		
		not (StartNode( eContainer == o))
		# not (FinishNode( eContainer == o)) - not necessary
			
		eval ( handler.veto( o ))
	
	then
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "current key value");
		queue.add(parameter, drools);
		
		DecisionNode op = handler.generatedDecisionNode(o, o);
		handler.setName(op, "equal?");
		queue.add(op, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(o, o);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Error: Key check failed. You may need to login.");
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, parameter);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, expected);
		handler.setTo(data2, op);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, op);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);
		
		# not ok	
		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, op);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

rule "Create contents of 'check instance' operation [type=domain_object or user]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		instance : DomainIterator ( eContainer == scope )
		setWire : SetWire ( from == login_handler, to == instance, name == "set" )
		
		ex : Condition ( instance.empty == ex )
				
		checkOperation : CompositeOperation ( eContainer == scope, name == "check instance" )

		not ( StartNode ( eContainer == checkOperation ))
		
		eval ( handler.veto( checkOperation ))

	then
		StartNode start = handler.generatedStartNode(checkOperation, checkOperation);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(checkOperation, checkOperation);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(checkOperation, checkOperation);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Invalid domain instance, you need to login.");
		queue.add(cancel, drools);
		
		# a conditional check		
		DecisionNode check = handler.generatedDecisionNode(checkOperation, checkOperation);
		handler.setName(check, "true?");
		queue.add(check, drools);
		
		# connect with a ConditionEdge
		ConditionEdge ce = handler.generatedConditionEdge(checkOperation, checkOperation, ex, check);
		queue.add(ce, drools);
		
		ExecutionEdge edge0 = handler.generatedExecutionEdge(checkOperation, checkOperation);
		handler.setFrom(edge0, start);
		handler.setTo(edge0, check);		
		queue.add(edge0, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(checkOperation, checkOperation);
		handler.setName(edge1, "no");
		handler.setFrom(edge1, check);
		handler.setTo(edge1, finish);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(checkOperation, checkOperation);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, check);
		handler.setTo(edge2, cancel);
		queue.add(edge2, drools);

end

/*
We don't want the expected login key to connect to the operation: it is already
explicitly defined in the Operation itself.
rule "Connect expected login key as parameter to check key operation"
	when 
		scope : Session( )
		page : Frame( eContainer == scope )
		access : EventTrigger( name == "access", eContainer == page )
		check : CompositeOperation( name == "check key", eContainer == scope )
		wire : ActionEdge( from == access, to == check )
		login_handler : LoginHandler( eContainer == scope )
		
		expected : StaticValue( ) 
		expected_param : ParameterEdge( from == expected, to == login_handler )
		
		not (ParameterEdge(from == expected, to == check ))	
	
	then
		ParameterEdge param = handler.generatedParameterEdge(login_handler, page, expected, wire);
		queue.add(param, drools);
	
end
*/

rule "Create login form for 'login' pages"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		not (InputForm( eContainer == login ))
				
		eval ( handler.veto( login_handler ))
		
	then
		InputForm form = handler.generatedInputForm(login_handler, login);
		handler.setName(form, "login form");
		queue.add(form, drools);
		
end

rule "Create 'Login' button for login form"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		
		form : InputForm ( name == "login form", eContainer == login )

		not (Button( name == "Login", eContainer == form ))
				
		eval ( handler.veto( login_handler ))
		
	then
		Button button = handler.generatedButton(form, form);
		handler.setName(button, "Login");
		handler.setRenderOrder(button, 60);		// at the end of the form
		queue.add(button, drools);
		
end

rule "Connect 'Login' button to 'do login' operation"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		form : InputForm ( eContainer == login, name == "login form" )
		button : Button ( eContainer == form, name == "Login" )
		
		operation : Operation ( eContainer == login_session, name == "do login" )
		
		not (ActionEdge ( from == button, to == operation, name == "onClick"))
		
		eval ( handler.veto( login_handler ))

	then
		ActionEdge run = handler.generatedActionEdge(login_handler, login, button, operation);
		handler.setName(run, "onClick");
		queue.add(run, drools);

end

rule "Create text fields for login form of 'login' pages [type=secret_key]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		form : InputForm( eContainer == login, name == "login form" )
		
		not ( InputTextField ( eContainer == form, name == "login key" ))
					
		eval ( handler.veto( form ))
		
	then

		InputTextField field = handler.generatedInputTextField(form, form);
		handler.setName(field, "login key");		# login field name
		queue.add(field, drools);

end

rule "Create contents of 'do login' operation [type=secret_key]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		value : Property( )
		mySetWire : SetWire( from == login_handler, to == value, name == "set" )

		expected : StaticValue( ) 
		expected_param : ParameterEdge( from == expected, to == login_handler )

		form : InputForm( eContainer == login, name == "login form" )
		button : Button ( eContainer == form, name == "Login" )
		
		field : InputTextField ( eContainer == form, name == "login key" )
		fieldValue : Property( field.fieldValue == fieldValue )
		
		loginOperation : CompositeOperation ( eContainer == login_session, name == "do login" )
		runClick : ActionEdge ( from == button, to == loginOperation, name == "onClick" )
		
		not ( StartNode ( eContainer == loginOperation ))
		
		eval ( handler.veto( loginOperation ))
			
	then
		
		# connect field value as parameter
		ParameterEdge clickParam = handler.generatedParameterEdge(loginOperation, login, fieldValue, runClick);
		handler.setName(clickParam, "[sessions] field value as param");
		queue.add(clickParam, drools);
		
		# create contents of login operation
		Parameter parameter = handler.generatedParameter(loginOperation, loginOperation);
		handler.setName(parameter, "provided key");
		queue.add(parameter, drools);
		
		DecisionNode op = handler.generatedDecisionNode(loginOperation, loginOperation);
		handler.setName(op, "equal?");
		queue.add(op, drools);
		
		StartNode start = handler.generatedStartNode(loginOperation, loginOperation);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(loginOperation, loginOperation);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(loginOperation, loginOperation);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Invalid key.");
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(loginOperation, loginOperation);
		handler.setFrom(data1, parameter);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(loginOperation, loginOperation);
		handler.setFrom(data2, expected);
		handler.setTo(data2, op);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);
		
		# not ok	
		ExecutionEdge edge2 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge2, "no");
		handler.setFrom(edge2, op);
		handler.setTo(edge2, cancel);
		queue.add(edge2, drools);

		# ok: set value operation
		PrimitiveOperation setProperty = handler.generatedPrimitiveOperation(loginOperation, loginOperation);
		handler.setName(setProperty, "set");
		queue.add(setProperty, drools);
		
		DataFlowEdge data3 = handler.generatedDataFlowEdge(loginOperation, loginOperation);
		handler.setFrom(data3, parameter);
		handler.setTo(data3, setProperty);
		queue.add(data3, drools);

		DataFlowEdge data4 = handler.generatedDataFlowEdge(loginOperation, loginOperation);
		handler.setFrom(data4, setProperty);
		handler.setTo(data4, value);
		queue.add(data4, drools);

		# ok
		ExecutionEdge edge3 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge3, "yes");
		handler.setFrom(edge3, op);
		handler.setTo(edge3, setProperty);
		queue.add(edge3, drools);

		# finish
		ExecutionEdge edge4 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge4, setProperty);
		handler.setTo(edge4, finish);
		queue.add(edge4, drools);
				
end

rule "Create text fields for login form of 'login' pages [type=domain_object]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		form : InputForm( eContainer == login, name == "login form" )
		
		# from a domain object
		attribute : DomainAttribute ( )
		param : ParameterEdge ( from == attribute, to == login_handler )
		
		not ( InputTextField ( eContainer == form, name == attribute.name ))
		
		eval ( handler.veto( form ))

	then
		InputTextField field = handler.generatedInputTextField(form, form);
		# login field name
		handler.setName(field, attribute.getName());		
		queue.add(field, drools);		
		
end

/**
 * A LoginHandler[user] uses all of the fields from the given
 * DomainObject parameter as input fields, except for 
 * any generated primary keys.
 */
rule "Create text fields for login form of 'login' pages [type=user]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.USER )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )

		form : InputForm( eContainer == login, name == "login form" )

		# from a role		
		role : Role ( )
		param : ParameterEdge ( from == role, to == login_handler )
		
		# an attribute in that role
		attribute : DomainAttribute ( eContainer == role, eval(functions.notPrimaryKey(attribute)) )
		
		not ( InputTextField ( eContainer == form, name == attribute.name ))
		
		eval ( handler.veto( form ))

	then
		InputTextField field = handler.generatedInputTextField(form, form);
		# login field name
		handler.setName(field, attribute.getName());
		
		# if password, this should always be last
		if ("password".equals(attribute.getName())) {
			handler.setRenderOrder(field, 20);
		}
				
		queue.add(field, drools);
		
end

rule "Connect text fields for login form of 'login' pages to 'do login' run wire [type=domain_object]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		
		operation : Operation( eContainer == login_session, name == "do login" )

		form : InputForm( eContainer == login, name == "login form" )
		
		# from a domain object
		attribute : DomainAttribute ( )
		param : ParameterEdge ( from == attribute, to == login_handler )
		
		field : InputTextField ( eContainer == form, name == attribute.name )
		fieldValue : Property ( field.fieldValue == fieldValue )
		
		button : Button ( eContainer == form, name == "Login" )
		run : ActionEdge ( from == button, to == operation, name == "onClick" )
		
		not ( ParameterEdge ( from == fieldValue, to == run, name == attribute.name )) 
		
		eval ( handler.veto( login_handler ))

	then
		ParameterEdge param2 = handler.generatedParameterEdge(login_handler, fieldValue, fieldValue, run);
		handler.setName(param2, attribute.getName());
		queue.add(param2, drools); 
		
end

rule "Connect text fields for login form of 'login' pages to 'do login' run wire [type=user]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.USER )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		
		operation : Operation( eContainer == login_session, name == "do login" )

		form : InputForm( eContainer == login, name == "login form" )
		
		# from a role
		role : Role ( )
		attribute : DomainAttribute ( eContainer == role )
		param : ParameterEdge ( from == role, to == login_handler )
		
		field : InputTextField ( eContainer == form, name == attribute.name )
		fieldValue : Property ( field.fieldValue == fieldValue )		
		
		button : Button ( eContainer == form, name == "Login" )
		run : ActionEdge ( from == button, to == operation, name == "onClick" )
		
		not ( ParameterEdge ( from == fieldValue, to == run, name == attribute.name )) 
		
		eval ( handler.veto( login_handler ))

	then
		ParameterEdge param2 = handler.generatedParameterEdge(login_handler, fieldValue, fieldValue, run);
		handler.setName(param2, attribute.getName());
		queue.add(param2, drools); 
		
end

/**
 * The 'do login' page must be OUTSIDE the Scope, otherwise it might
 * not be possible to actually call it from outside (since Session.onAccess
 * may require a valid domain instance, for example - even though it hasn't been
 * set yet).
 *
 * @implementation Operation,OperationCallNode,Scope
 *		All {@model OperationCallNode operation calls} to {@model Operation}s contained
 *		within {@model Scope}s are first evaluated for any
 * 		{@model Scope#onAccess} {@model EventTrigger events}.
 * @implementation LoginHandler
 *		The generated {@model Property} containing the current password
 *		for a {@model LoginHandler} is set before it is evaluated whether
 *		the instance actually exists, thus the Property may not be
 *		valid.
 */
rule "Create 'do login' operation within all login_handlers"
	when
		container : InternetApplication( )
		session : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == session )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		not ( Operation ( eContainer == login_session, name == "do login" ))
		
		eval ( handler.veto( login_handler ))

	then
		CompositeOperation loginOperation = handler.generatedCompositeOperation(login_handler, login_session);
		handler.setName(loginOperation, "do login");
		queue.add(loginOperation, drools);
		
end

rule "Create contents of 'do login' operation [type=domain_object]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		instance : DomainIterator ( eContainer == scope )
		setWire : SetWire ( from == login_handler, to == instance, name == "set" )
		
		ex : Condition ( instance.empty == ex )
				
		loginOperation : CompositeOperation ( eContainer == login_session, name == "do login" )

		not ( StartNode ( eContainer == loginOperation ))
		
		eval ( handler.veto( loginOperation ))

	then
		StartNode start = handler.generatedStartNode(loginOperation, loginOperation);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(loginOperation, loginOperation);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(loginOperation, loginOperation);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "No such instance found.");
		queue.add(cancel, drools);
		
		// make a split/join
		SplitNode split = handler.generatedSplitNode(loginOperation, loginOperation);
		queue.add(split, drools);
		JoinNode join = handler.generatedJoinNode(loginOperation, loginOperation);
		queue.add(join, drools);
				
		ExecutionEdge edge0 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge0, start);
		handler.setTo(edge0, split);		
		queue.add(edge0, drools);
		
		// we will leave the other rules to generate the contents

		# a conditional check		
		DecisionNode check = handler.generatedDecisionNode(loginOperation, loginOperation);
		handler.setName(check, "true?");
		queue.add(check, drools);
		
		# connect with a ConditionEdge
		ConditionEdge ce = handler.generatedConditionEdge(loginOperation, loginOperation, ex, check);
		queue.add(ce, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge1, join);
		handler.setTo(edge1, check);
		queue.add(edge1, drools);
		
		# not ok	
		ExecutionEdge edge2 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, check);
		handler.setTo(edge2, cancel);
		queue.add(edge2, drools);

		# ok
		ExecutionEdge edge3 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, check);
		handler.setTo(edge3, finish);
		queue.add(edge3, drools);

end

rule "Create parameter for 'do login' operation inside login handler[type=domain_object]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		attribute : DomainAttribute ( )
		paramWire : ParameterEdge( from == attribute, to == login_handler )
		
		instance : DomainIterator ( eContainer == scope )
		setWire : SetWire ( from == login_handler, to == instance, name == "set" )

		operation : CompositeOperation ( eContainer == login_session, name == "do login" )
		split : SplitNode ( eContainer == operation )
		join : JoinNode ( eContainer == operation )
		
		target : Property ( eContainer == scope, eval(functions.loginAttributeMatches(target, attribute)))

		not ( Parameter ( eContainer == operation, name == attribute.name ))
		
		eval ( handler.veto( operation ))

	then
		Parameter param = handler.generatedParameter(operation, operation);
		handler.setName(param, attribute.getName());
		queue.add(param, drools);
		
		CompositeOperation setValue = handler.generatedCompositeOperation(operation, operation);
		handler.setName(setValue, "set");
		queue.add(setValue, drools);
		
		// split to set value
		ExecutionEdge edge1 = handler.generatedExecutionEdge(operation, operation);
		handler.setFrom(edge1, split);
		handler.setTo(edge1, setValue);
		queue.add(edge1, drools);
		
		// set value to join
		ExecutionEdge edge2 = handler.generatedExecutionEdge(operation, operation);
		handler.setFrom(edge2, setValue);
		handler.setTo(edge2, join);
		queue.add(edge2, drools);
		
		// flow from param to value
		DataFlowEdge data1 = handler.generatedDataFlowEdge(operation, operation);
		handler.setFrom(data1, param);
		handler.setTo(data1, setValue);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(operation, operation);
		handler.setFrom(data2, setValue);
		handler.setTo(data2, target);
		queue.add(data2, drools);

end

rule "Create contents of 'do login' operation [type=user]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.USER )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		instance : DomainIterator ( eContainer == scope )
		setWire : SetWire ( from == login_handler, to == instance, name == "set" )
		
		ex : Condition ( instance.empty == ex )
				
		loginOperation : CompositeOperation ( eContainer == login_session, name == "do login" )

		not ( StartNode ( eContainer == loginOperation ))
		
		eval ( handler.veto( loginOperation ))

	then
		StartNode start = handler.generatedStartNode(loginOperation, loginOperation);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(loginOperation, loginOperation);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(loginOperation, loginOperation);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "No such user found.");
		queue.add(cancel, drools);
		
		// make a split/join
		SplitNode split = handler.generatedSplitNode(loginOperation, loginOperation);
		queue.add(split, drools);
		JoinNode join = handler.generatedJoinNode(loginOperation, loginOperation);
		queue.add(join, drools);
				
		ExecutionEdge edge0 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge0, start);
		handler.setTo(edge0, split);		
		queue.add(edge0, drools);
		
		// we will leave the other rules to generate the contents

		# a conditional check		
		DecisionNode check = handler.generatedDecisionNode(loginOperation, loginOperation);
		handler.setName(check, "true?");
		queue.add(check, drools);
		
		# connect with a ConditionEdge
		ConditionEdge ce = handler.generatedConditionEdge(loginOperation, loginOperation, ex, check);
		queue.add(ce, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setFrom(edge1, join);
		handler.setTo(edge1, check);
		queue.add(edge1, drools);
		
		# not ok	
		ExecutionEdge edge2 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, check);
		handler.setTo(edge2, cancel);
		queue.add(edge2, drools);

		# ok
		ExecutionEdge edge3 = handler.generatedExecutionEdge(loginOperation, loginOperation);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, check);
		handler.setTo(edge3, finish);
		queue.add(edge3, drools);

end

rule "Create parameter for 'do login' operation inside login handler[type=user]"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.USER )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		
		role : Role ( )
		attribute : DomainAttribute ( eContainer == role )
		paramWire : ParameterEdge( from == role, to == login_handler )
		
		operation : CompositeOperation ( eContainer == login_session, name == "do login" )
		split : SplitNode ( eContainer == operation )
		join : JoinNode ( eContainer == operation )
		
		target : Property ( eContainer == scope, eval(functions.loginAttributeMatches(target, attribute)))

		not ( Parameter ( eContainer == operation, name == attribute.name ))
		
		eval ( handler.veto( operation ))

	then
		Parameter param = handler.generatedParameter(operation, operation);
		handler.setName(param, attribute.getName());
		queue.add(param, drools);
		
		CompositeOperation setValue = handler.generatedCompositeOperation(operation, operation);
		handler.setName(setValue, "set");
		queue.add(setValue, drools);
		
		// split to set value
		ExecutionEdge edge1 = handler.generatedExecutionEdge(operation, operation);
		handler.setFrom(edge1, split);
		handler.setTo(edge1, setValue);
		queue.add(edge1, drools);
		
		// set value to join
		ExecutionEdge edge2 = handler.generatedExecutionEdge(operation, operation);
		handler.setFrom(edge2, setValue);
		handler.setTo(edge2, join);
		queue.add(edge2, drools);
		
		// flow from param to value
		DataFlowEdge data1 = handler.generatedDataFlowEdge(operation, operation);
		handler.setFrom(data1, param);
		handler.setTo(data1, setValue);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(operation, operation);
		handler.setFrom(data2, setValue);
		handler.setTo(data2, target);
		queue.add(data2, drools);

end

/* it's possible in the future that this method should be split up. */
rule "Connect successful login operation ('success') to navigate to final 'login' page"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		
		login_operation : CompositeOperation( eContainer == login_session, name == "do login" )		
		login_target : Frame ( ) 
		login_wire : ActionEdge( from == login_handler, to == login_target, name == "success" )

		not (ActionEdge(from == login_operation, to == login_target))
		
		eval ( handler.veto( login_handler ))
			
	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, scope, login_operation, login_target);
		handler.setName(wire, "navigate on successful login");
		queue.add(wire, drools);
				
end

rule "Connect failed login operation ('fail') to navigate back to 'login'"
	when
		container : InternetApplication( )
		scope : Session( eContainer == container ) 
		login_handler : LoginHandler( eContainer == scope )
		login_session : Session ( eContainer == container, eval(functions.loginHandlerScopeMatches( login_session, login_handler )) )
		login : Frame ( )
		login_edge : ActionEdge ( from == login_handler, to == login, name == "login" )
		login_operation : CompositeOperation( eContainer == login_session, name == "do login" )		

		not (ActionEdge(from == login_operation, to == login, name == "fail"))
		
		eval ( handler.veto( login_handler ))
			
	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, scope, login_operation, login);
		handler.setName(wire, "fail");
		queue.add(wire, drools);
		
end

rule "Create 'do logout' operation in session"
	when
		container : InternetApplication( )
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		logout : Frame ( eContainer == scope, name == "logout" )
	
		not (CompositeOperation ( eContainer == scope, name == "do logout" ))
		
		eval ( handler.veto( login_handler ))

	then
		CompositeOperation operation = handler.generatedCompositeOperation(login_handler, scope);
		handler.setName(operation, "do logout");
		queue.add(operation, drools); 
		
end 

rule "Connect 'access' operation for logout page to 'do logout' operation"
	when
		container : InternetApplication( )
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		
		logout : Frame ( )
		wire : ActionEdge ( from == login_handler, to == logout, name == "logout" )
		
		logout_operation : Operation ( eContainer == scope, name == "do logout" )
		access : EventTrigger ( eContainer == logout, logout.onAccess == access )
		# we can't add it to the end of the 'check key' operation, because then
		# all operations will have to run it as well.
		# add it to the end of the access operation chain
		
		not (ActionEdge( from == access, to == logout_operation ))
		
		eval ( handler.veto( login_handler ))
	
	then 
		ActionEdge run = handler.generatedActionEdge(login_handler, logout, access, logout_operation);
		handler.setName(run, "run logout operation");
		queue.add(run, drools);

end 

rule "Connect new navigate wire from logout to logout destination"
	when
		container : InternetApplication( )
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		logout : Frame ( eContainer == scope, name == "logout" )
		logout_operation : CompositeOperation ( eContainer == scope, name == "do logout" )
		# add it at the end of the operation chain (final_operation may == logout_operation)
		# in this case, we want all accesses to "do logout" to always redirect to "home" (for example)
		final_operation : CompositeOperation ( eval(final_operation.equals(functions.lastChainedOperation(logout_operation))) )
		destination : Frame ( )
		logout_wire : ActionEdge( from == login_handler, to == destination, name == "logout" )
		
		not (ActionEdge( from == final_operation, to == destination ))
		
		eval ( handler.veto( login_handler ))
	
	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, scope, final_operation, destination);
		handler.setName(wire, "navigate on successful logout");
		queue.add(wire, drools);
		
end

rule "Create contents of 'do logout' operation [type=secret_key]"
	when
		scope : Session( )
		o : CompositeOperation( name == "do logout", eContainer == scope )
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.SECRET_KEY )

		value : Property( )
		mySetWire : SetWire( from == login_handler, to == value, name == "set" )
		
		not (StartNode( eContainer == o))
		not (FinishNode( eContainer == o))
		
		eval ( handler.veto( o ))
	
	then
		# create a 'null' value
		StaticValue myNull = handler.generatedStaticValue(o, o);
		handler.setName(myNull, "reset value");
		handler.setValue(myNull, ModelPackage.eINSTANCE.getStaticValue_Value(), "null");
		queue.add(myNull, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		# set
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "set");
		queue.add(op, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, myNull);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, op);
		handler.setTo(data2, value);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, op);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

end

rule "Create contents (initial) of 'do logout' operation [type=object or user]"
	when
		scope : Session( )
		o : CompositeOperation( name == "do logout", eContainer == scope )
		login_handler : LoginHandler( eContainer == scope, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )

		not (StartNode( eContainer == o))
		not (FinishNode( eContainer == o))
		
		eval ( handler.veto( o ))
	
	then
		# create a 'null' value
		StaticValue myNull = handler.generatedStaticValue(o, o);
		handler.setName(myNull, "reset value");
		handler.setValue(myNull, ModelPackage.eINSTANCE.getStaticValue_Value(), "null");
		queue.add(myNull, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		SplitNode split = handler.generatedSplitNode(o, o);
		queue.add(split, drools);
		
		JoinNode join = handler.generatedJoinNode(o, o);
		queue.add(join, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, split);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, join);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

end

rule "Create contents (specific keys) of 'do logout' operation [type=object]"
	when
		session : Session( )
		o : CompositeOperation( name == "do logout", eContainer == session )
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )

		attribute : DomainAttribute ( )
		paramWire : ParameterEdge ( from == attribute, to == login_handler )
		
		key : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(key, attribute) ) )

		myNull : StaticValue ( eContainer == o, name == "reset value" )
		split : SplitNode ( eContainer == o )
		join : JoinNode ( eContainer == o )
			
		not (DataFlowEdge ( eContainer == o, from == key ))
		
		eval ( handler.veto( o ))
	
	then
	
		# set
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "set");
		queue.add(op, drools);
	
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, myNull);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, op);
		handler.setTo(data2, key);
		queue.add(data2, drools);

		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, split);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, op);
		handler.setTo(edge2, join);
		queue.add(edge2, drools);

end

rule "Create contents (specific keys) of 'do logout' operation [type=user]"
	when
		session : Session( )
		o : CompositeOperation( name == "do logout", eContainer == session )
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.USER )

		role : Role ( )
		attribute : DomainAttribute ( eContainer == role, eval(functions.notPrimaryKey(attribute)) )
		paramWire : ParameterEdge ( from == role, to == login_handler )
		
		key : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(key, attribute) ) )

		myNull : StaticValue ( eContainer == o, name == "reset value" )
		split : SplitNode ( eContainer == o )
		join : JoinNode ( eContainer == o )
			
		not (DataFlowEdge ( eContainer == o, from == key ))
		
		eval ( handler.veto( o ))
	
	then
	
		# set
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "set");
		queue.add(op, drools);
	
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, myNull);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, op);
		handler.setTo(data2, key);
		queue.add(data2, drools);
	
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, split);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, op);
		handler.setTo(edge2, join);
		queue.add(edge2, drools);

end

rule "Create default login successful page"
	when
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		
		not ( Frame ( eContainer == scope, name == "Login Successful" ) )
		not ( wire : ActionEdge (from == login_handler, name == "success" ))
		
		eval ( handler.veto( login_handler ))

	then
		Frame page = handler.generatedFrame(login_handler, scope);
		handler.setName(page, "Login Successful");
		queue.add(page, drools);

end

rule "Connect default login successful page to LoginHandler"
	when
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		
		success : Frame ( eContainer == scope, name == "Login Successful" )
		
		not ( wire : ActionEdge (from == login_handler, name == "success" ))
		
		eval ( handler.veto( login_handler ))

	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, login_handler, login_handler, success);
		handler.setName(wire, "success");
		queue.add(wire, drools);

end

rule "Create default logout successful page"
	when
		container : InternetApplication( )
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		
		not ( wire : ActionEdge (from == login_handler, name == "logout" ))
		not ( Frame ( eContainer == container, name == "Logout Successful" ) )
				
		eval ( handler.veto( login_handler ))

	then
		Frame page = handler.generatedFrame(login_handler, container);
		handler.setName(page, "Logout Successful");
		queue.add(page, drools);

end

rule "Connect default logout successful page to LoginHandler"
	when
		container : InternetApplication( )
		scope : Session ( )
		login_handler : LoginHandler( eContainer == scope )
		
		logout : Frame ( eContainer == container, name == "Logout Successful" )
		
		not ( wire : ActionEdge (from == login_handler, name == "logout" ))
		
		eval ( handler.veto( login_handler ))

	then
		ActionEdge wire = handler.generatedActionEdge(login_handler, login_handler, login_handler, logout);
		handler.setName(wire, "logout");
		queue.add(wire, drools);

end

/**
 * If we have multiple incoming ParameterEdges, we need special logic to
 * only instantiate this rule once (thanks to queued insertions).
 *
 * Essentially, we create only SelectWire for each DomainObject
 * linked by a ParameterEdge, and then use Java to generate the
 * actual query from the Attributes.
 */
rule "Update query parameters for LoginHandler [object]"
	when
		scope : Session ( )
		dobj : DomainSchema ( )
		
		# with at least one attribute
		exists ( DomainAttribute ( eContainer == dobj ))
		
		login_handler : LoginHandler( 
			eContainer == scope, 
			type == LoginHandlerTypes.DOMAIN_OBJECT,
			eval(functions.hasIncomingParameterEdgesFrom(login_handler, dobj)) 
		)
		
		instance : DomainIterator ( query == null )
		setWire : SetWire ( from == login_handler, to == instance )
		
		eval ( handler.veto( login_handler ))
		
	then
		// find all the attributes as incoming parameter wires for the
		// given DomainObject
		String q = functions.getQueryString(login_handler, dobj);
		
		handler.setQuery(instance, q);

end

rule "Create Query from a DomainAttribute [user]"
	when
		scope : Session ( )
		role : Role ( )

		login_handler : LoginHandler( 
			eContainer == scope, 
			type == LoginHandlerTypes.USER,
			eval(functions.hasIncomingParameterEdgesFrom(login_handler, role)) 
		)

		# with at least one attribute
		exists ( DomainAttribute ( eContainer == role ))

		instance : DomainIterator ( query == null )
		setWire : SetWire ( from == login_handler, to == instance )
			
		eval ( handler.veto( login_handler ))
		
	then
		// find all the attributes as incoming parameter wires for the
		// given DomainObject (including superclasses)
		String q = functions.getUserQueryString(role);
		handler.setQuery(instance, q);

end

# if the attributes have changed, we need to update the
# query string
rule "Update Query from a DomainAttribute [user]"
	when
		scope : Session ( )
		dobj : Role ( )
		
		login_handler : LoginHandler( 
			eContainer == scope, 
			type == LoginHandlerTypes.USER,
			eval(functions.hasIncomingParameterEdgesFrom(login_handler, dobj)) 
		)
		
		# with at least one attribute
		exists ( DomainAttribute ( eContainer == dobj ))
		
		instance : DomainIterator ( query != null )
		setWire : SetWire ( from == login_handler, to == instance )
		
		eval ( !functions.getUserQueryString(dobj).equals(instance.getQuery()))
		
		eval ( handler.veto( login_handler ))
		
	then
		String q = functions.getUserQueryString(dobj);
		handler.setQuery(instance, q);

end

rule "Create Query from a DomainSchema [user]"
	when
		scope : Session ( )
		role : Role ( )

		login_handler : LoginHandler( 
			eContainer == scope, 
			type == LoginHandlerTypes.USER
		)
		
		# the Role is the incoming parameter, not just a DomainAttribute
		param : ParameterEdge ( from == role, to == login_handler )

		# with at least one attribute
		exists ( DomainAttribute ( eContainer == role ))

		instance : DomainIterator ( query == null )
		setWire : SetWire ( from == login_handler, to == instance )
			
		eval ( handler.veto( login_handler ))
		
	then
		// find all the attributes as incoming parameter wires for the
		// given DomainObject (including superclasses)
		String q = functions.getUserQueryString(role);
		handler.setQuery(instance, q);

end

# if the attributes have changed, we need to update the
# query string
rule "Update Query from a DomainSchema [user]"
	when
		scope : Session ( )
		dobj : Role ( )
		
		login_handler : LoginHandler( 
			eContainer == scope, 
			type == LoginHandlerTypes.USER
		)
		
		# the Role is the incoming parameter, not just a DomainAttribute
		param : ParameterEdge ( from == dobj, to == login_handler )

		# with at least one attribute (trigger)
		DomainAttribute ( eContainer == dobj )
		
		instance : DomainIterator ( )
		setWire : SetWire ( from == login_handler, to == instance )
		
		eval ( !functions.getUserQueryString(dobj).equals(instance.getQuery()))
		
		eval ( handler.veto( login_handler ))
		
	then
		String q = functions.getUserQueryString(dobj);
		handler.setQuery(instance, q);

end

rule "Create 'key attribute' property for LoginHandler[type = object]s"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )
		
		attribute : DomainAttribute ( )
		paramWire : ParameterEdge ( from == attribute, to == login_handler )
		
		not ( p : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(p, attribute) ) ) )
		
		eval ( handler.veto( login_handler ))
				
	then
		Property key = handler.generatedProperty(login_handler, session);
		handler.setName(key, "current " + attribute.getName());
		# need to set a default value, or else require_session(this) will throw an exception before we can catch it to redirect
		handler.setValue(key, ModelPackage.eINSTANCE.getProperty_DefaultValue(), "");
		queue.add(key, drools);
		
end

rule "Create 'key attribute' property for LoginHandler[type = user]s"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.USER )
		
		role : Role ( )
		attribute : DomainAttribute ( eContainer == role, eval(functions.notPrimaryKey(attribute)) )
		paramWire : ParameterEdge ( from == role, to == login_handler )
		
		not ( p : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(p, attribute) ) ) )
		
		eval ( handler.veto( login_handler ))
				
	then
		Property key = handler.generatedProperty(login_handler, session);
		handler.setName(key, "current " + attribute.getName());
		# need to set a default value, or else require_session(this) will throw an exception before we can catch it to redirect
		handler.setValue(key, ModelPackage.eINSTANCE.getProperty_DefaultValue(), "");
		queue.add(key, drools);
		
end

rule "Connect key properties to LoginHandler for LoginHandler[type = object]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )
		
		object : DomainSchema ( )
		attribute : DomainAttribute ( eContainer == object )
		paramWire : ParameterEdge ( from == attribute, to == login_handler )
		
		instance : DomainIterator ( )
		setWire : SetWire ( from == login_handler, to == instance )
		
		# select : SelectWire ( from == object, to == instance )
		
		key : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(key, attribute) ) )
			
		not ( SetWire ( from == login_handler, to == key ))
		
		eval ( handler.veto( login_handler ))
		
	then
		SetWire wire = handler.generatedSetWire(login_handler, session, login_handler, key);
		handler.setName(wire, "set");
		queue.add(wire, drools); 
	
end

rule "Connect key properties to SelectWire for LoginHandler[type = object]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )
		
		object : DomainSchema ( )
		attribute : DomainAttribute ( eContainer == object )
		paramWire : ParameterEdge ( from == attribute, to == login_handler )
		
		instance : DomainIterator ( )
		setWire : SetWire ( from == login_handler, to == instance )
		
		# select : SelectWire ( from == object, to == instance )
		
		key : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(key, attribute) ) )
			
		not ( ParameterEdge ( from == key, to == instance ))
		
		eval ( handler.veto( login_handler ))
		
	then
		ParameterEdge wire = handler.generatedParameterEdge(login_handler, session, key, instance);
		handler.setName(wire, attribute.getName());
		queue.add(wire, drools); 
	
end

rule "Connect key properties to SelectWire for LoginHandler[type = user]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.USER )
		
		role : Role ( )
		attribute : DomainAttribute ( eContainer == role )
		paramWire : ParameterEdge ( from == role, to == login_handler )
		
		instance : DomainIterator ( )
		setWire : SetWire ( from == login_handler, to == instance )
		
		# select : SelectWire ( from == role, to == instance )
		
		key : Property ( eContainer == session, 
			eval(functions.loginAttributeMatches(key, attribute) ) )
			
		not ( ParameterEdge ( from == key, to == instance ))
		
		eval ( handler.veto( login_handler ))
		
	then
		ParameterEdge wire = handler.generatedParameterEdge(login_handler, session, key, instance);
		handler.setName(wire, attribute.getName());
		queue.add(wire, drools); 
	
end

rule "Create 'check instance' operation for LoginHandler[type = object or user]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		not (Operation( eContainer == session, name == "check instance") )
		
		eval ( handler.veto( login_handler ))
					
	then
		CompositeOperation op = handler.generatedCompositeOperation( login_handler, session );
		handler.setName(op, "check instance");
		queue.add(op, drools);
		
end

# TODO merge these two rules (object, user) together
rule "Create 'current instance' for LoginHandler[type=object]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )
		
		not (DomainIterator ( eContainer == session ))
		
		eval ( handler.veto( login_handler ))
		
	then
		DomainIterator instance = handler.generatedDomainIterator( login_handler, session );
		handler.setName(instance, "current instance");
		queue.add(instance, drools);

end

rule "Create 'current instance' for LoginHandler[type=object] - connect SetWire"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT )
		
		instance : DomainIterator ( eContainer == session, name == "current instance" )
		
		not (set : SetWire ( eval (functions.connectsSet(set, login_handler, instance )) ) )
		
		eval ( handler.veto( login_handler ))
		
	then	
		SetWire setWire = handler.generatedSetWire(login_handler, session, login_handler, instance);
		handler.setName(setWire, "set");
		queue.add(setWire, drools);

end

rule "Create 'current instance' for LoginHandler[type=user]"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.USER )
		
		not (DomainIterator ( eContainer == session ))
		
		eval ( handler.veto( login_handler ))
		
	then
		DomainIterator instance = handler.generatedDomainIterator( login_handler, session );
		handler.setName(instance, "current instance");
		queue.add(instance, drools);

end

rule "Create 'current instance' for LoginHandler[type=user] - connect SetWire"
	when
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.USER )
		
		instance : DomainIterator ( eContainer == session, name == "current instance" )
		
		not (set : SetWire ( eval (functions.connectsSet(set, login_handler, instance )) ) )
		
		eval ( handler.veto( login_handler ))
		
	then
		// connect with SetWire
		SetWire setWire = handler.generatedSetWire(login_handler, session, login_handler, instance);
		handler.setName(setWire, "set");
		queue.add(setWire, drools);

end

rule "Connect a default DomainSource for LoginHandlers that do not specify a SelectEdge [domain and user] (DomainAttribute)"
	when
		root : InternetApplication ( )
	
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		iterator : DomainIterator ( eContainer == session )
		set : SetWire ( from == login_handler, to == iterator )
		
		schema : DomainSchema ( )
		
		# LoginHandler selecting from a DomainAttribute
		exists (
			sourceAttribute : DomainAttribute ( eContainer == schema ) and
			param : ParameterEdge ( from == sourceAttribute, to == login_handler )
		)
		
		source : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, source, schema ) )
		
		not ( selectEdge : SelectEdge ( ) and 
			eval ( functions.connectsSelect( selectEdge, iterator, source ))
		) 

		# and this source isn't being used for anything else
		not ( s2 : SelectEdge ( to == source ) )
		
		eval ( handler.veto( login_handler ))

	then
		SelectEdge select = handler.generatedSelectEdge(login_handler, source, iterator, source);
		queue.add(select, drools);
	
end	

rule "Connect a default DomainSource for LoginHandlers that do not specify a SelectEdge [domain and user] (DomainSchema)"
	when
		root : InternetApplication ( )
	
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		iterator : DomainIterator ( eContainer == session )
		set : SetWire ( from == login_handler, to == iterator )
		
		schema : DomainSchema ( )
		
		# LoginHandler selecting from a DomainSchema
		param : ParameterEdge ( from == schema, to == login_handler )
		
		source : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, source, schema ) )
		
		not ( selectEdge : SelectEdge ( ) and 
			eval ( functions.connectsSelect( selectEdge, iterator, source ))
		) 

		# and this source isn't being used for anything else
		not ( s2 : SelectEdge ( to == source ) )
		
		# but will not be provided by the ACH later
		not (
			ach : AccessControlHandler ( eContainer == session )
		)
		
		eval ( handler.veto( login_handler ))

	then
		SelectEdge select = handler.generatedSelectEdge(login_handler, source, iterator, source);
		queue.add(select, drools);
	
end	

/**
 * The above rule will only connect the created Instance if there is no extension, i.e. the LoginHandler and the
 * AccessControlHandler both point to the same Schema. However, if the AccessControlHandler requires [role],
 * the LoginHandler has an incoming parameter from the root User, because the permission check is actually
 * handled by the method call. But the 'current instance' is expected to be of type '[role]'; thus, we 
 * use this as the expected schema.
 */
rule "Connect the DomainSource for the AccessControlHandler to the Current Instance (inherited)"
	when
		root : InternetApplication ( )
	
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		ach : AccessControlHandler ( eContainer == session )
		
		expected_schema : DomainSchema ( )
		requires : RequiresEdge ( from == ach, to == expected_schema )
		
		iterator : DomainIterator ( eContainer == session )
		set : SetWire ( from == login_handler, to == iterator )
	
		# this will also cover if there is a Role and a Permission

		# but a <em>different</em> schema is connected		
		other_schema : DomainSchema ( )
		param : ParameterEdge ( from == other_schema, to == login_handler )
		eval ( other_schema != expected_schema )
		
		# and our expected schema has a source
		source : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, source, expected_schema ) )

		not ( selectEdge : SelectEdge ( ) and 
			eval ( functions.connectsSelect( selectEdge, iterator, source ))
		) 
		
		eval ( handler.veto( ach ))

	then
		SelectEdge select = handler.generatedSelectEdge(ach, source, iterator, source);
		queue.add(select, drools);
	
end	

rule "Connect the DomainSource for the AccessControlHandler to the Current Instance (direct)"
	when
		root : InternetApplication ( )
	
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		ach : AccessControlHandler ( eContainer == session )
		
		expected_schema : DomainSchema ( )
		requires : RequiresEdge ( from == ach, to == expected_schema )
		
		iterator : DomainIterator ( eContainer == session )
		set : SetWire ( from == login_handler, to == iterator )
	
		# this will also cover if there is a Role and a Permission

		# but the same schema is selected		
		param : ParameterEdge ( from == expected_schema, to == login_handler )
		
		# and our expected schema has a source
		source : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, source, expected_schema ) )

		not ( selectEdge : SelectEdge ( ) and 
			eval ( functions.connectsSelect( selectEdge, iterator, source ))
		) 
		
		eval ( handler.veto( ach ))

	then
		SelectEdge select = handler.generatedSelectEdge(ach, source, iterator, source);
		queue.add(select, drools);
	
end

rule "Connect the DomainSource for the AccessControlHandler to the Current Instance (Permission)"
	when
		root : InternetApplication ( )
	
		session : Session( ) 
		login_handler : LoginHandler( eContainer == session, type == LoginHandlerTypes.DOMAIN_OBJECT || type == LoginHandlerTypes.USER )
		
		ach : AccessControlHandler ( eContainer == session )
		
		# the ACH requires at least one permission
		exists (
			permission : Permission ( ) and
			requires : RequiresEdge ( from == ach, to == permission )
		)
		
		# and this isn't using a DomainSchema
		not ( exists (
			role : DomainSchema ( ) and
			requires : RequiresEdge ( from == ach, to == role )
		) )
		
		# we select against the default schema
		default_schema : Role ( name == "User", eContainer == root )
			
		iterator : DomainIterator ( eContainer == session )
		set : SetWire ( from == login_handler, to == iterator )
		
		# the expected schema is connected		
		param : ParameterEdge ( from == default_schema, to == login_handler )
		
		# and our expected schema has a source
		source : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, source, default_schema ) )

		not ( selectEdge : SelectEdge ( ) and 
			eval ( functions.connectsSelect( selectEdge, iterator, source ))
		) 
		
		
		eval ( handler.veto( ach ))

	then
		SelectEdge select = handler.generatedSelectEdge(ach, source, iterator, source);
		queue.add(select, drools);
	
end	

rule "Refresh Iterator Object mappings"
	when
		schema : DomainSchema ( )
		source : DomainSource ( )
		iterator : DomainIterator ( )
		
		schemaEdge : SchemaEdge ( ) and
		eval ( functions.connectsSchema(schemaEdge, source, schema ))
		
		selectEdge : SelectEdge ( ) and
		eval ( functions.connectsSelect(selectEdge, iterator, source ))
		
		attribute : DomainAttribute ( eContainer == schema )
		
		not ( DomainAttributeInstance( eContainer == iterator, name == attribute.name ))

		eval ( handler.veto( iterator ))
		
	then
		# create a new one
		DomainAttributeInstance attr = handler.generatedDomainAttributeInstance(iterator, iterator);
		handler.setName(attr, attribute.getName());
		# set type
		handler.setType(attr, attribute.getType());
		queue.add(attr, drools);
		
		# mark it as an extension
		ExtendsEdge ex = handler.generatedExtendsEdge(iterator, attr, attr, attribute);
		queue.add(ex, drools); 

end

rule "Mark AttributeInstances as extensions of the identically-named Attributes (NewInstanceWire)"
	when
		schema : DomainSchema ( )
		source : DomainSource ( )
		iterator : DomainIterator ( )
		
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema(schemaEdge, source, schema ))
		
		selectEdge : SelectEdge ( )
		eval ( functions.connectsSelect(selectEdge, iterator, source ))

		attribute : DomainAttribute ( eContainer == schema )
		attrinst : DomainAttributeInstance( eContainer == iterator, name == attribute.name ) 
		
		not ( ExtendsEdge ( from == attrinst, to == attribute ) )
		
		eval ( handler.veto( attrinst ))
		
	then
		# mark it as an extension
		ExtendsEdge w = handler.generatedExtendsEdge(attrinst, attrinst, attrinst, attribute);
		queue.add(w, drools);
	
end

rule "Create 'save' operation for DomainIterators"
	when
		instance : DomainIterator ( )
		
		not ( Operation( eContainer == instance, name == "save" ))
		
		eval ( handler.veto( instance ))
		
	then
		# create a new one
		PrimitiveOperation op = handler.generatedPrimitiveOperation(instance, instance);
		handler.setName(op, "save");
		queue.add(op, drools);

end

/**
 * Issue 210: Create PrimitiveOperations rather than CompositeOperations.
 *
 * @inference VisibleThing
 *		All {@model VisibleThing}s (except {@model IteratorList}s and {@model InputForm}s) will have an {@model Operation} called "update".
 */
rule "Create 'update' operation for VisibleThings"
	when
		f : VisibleThing( )
		not ( IteratorList ( this == f )) # not IteratorLists
		not ( InputForm ( this == f )) # not InputForms
		not (Operation( eContainer == f, name=="update" ))
		
		eval ( handler.veto( f ))
			
	then
		PrimitiveOperation operation = handler.generatedPrimitiveOperation(f, f);
		handler.setName(operation, "update");
		queue.add(operation, drools);
		
end

rule "Create 'update' operation for domain attribute"
	when
		f : DomainAttribute( )
		not (Operation( eContainer == f, name=="update" ))
				
		eval ( handler.veto( f ))
			
	then
		PrimitiveOperation operation = handler.generatedPrimitiveOperation(f, f);
		handler.setName(operation, "update");
		queue.add(operation, drools);
		
end

rule "Create 'update' operation for domain attribute instance"
	when
		f : DomainAttributeInstance( )
		not (Operation( eContainer == f, name=="update" ))
				
		eval ( handler.veto( f ))
			
	then
		PrimitiveOperation operation = handler.generatedPrimitiveOperation(f, f);
		handler.setName(operation, "update");
		queue.add(operation, drools);
		
end

/**
 * Issue 210: Create PrimitiveOperations rather than CompositeOperations.
 *
 * @inference VisibleThing
 *		All {@model VisibleThing}s (except {@model IteratorList}s and {@model InputForm}s) will have an {@model Operation} called "init".
 */
rule "Create 'init' operation for VisibleThings"
	when
		f : VisibleThing( )
		not ( IteratorList ( this == f )) # not IteratorLists
		not ( InputForm ( this == f )) # not InputForms
		not (Operation( eContainer == f, name=="init" ))
				
		eval ( handler.veto( f ))
			
	then
		PrimitiveOperation operation = handler.generatedPrimitiveOperation(f, f);
		handler.setName(operation, "init");
		queue.add(operation, drools);
		
end

/**
 * @inference SetWire,Property
 *		An {@model Operation} 'set property XXX' is created for all {@model Property Properties}
 *		that are the target of {@model SetWire}s.
 */
rule "Create 'set property XXX' Operation for all Properties, except fieldValue"
	when
		container : ContainsOperations ( )
		gen : GeneratesElements ( this == container )
		p : Property ( eContainer == container, name != "fieldValue" )
		
		exists ( setWire : SetWire ( to == p ) )

		not ( op : Operation ( eContainer == container, name != null, eval( ("set property " + p.getName()).equals(op.getName()) ) ) )
		
		eval ( handler.veto( gen ))
		
	then
		CompositeOperation op = handler.generatedCompositeOperation(gen, container);
		handler.setName(op, "set property " + p.getName());
		queue.add(op, drools); 
	
end 

/**
 * @inference Changeable
 *		A {@model Changeable} that also contains a {@model CompositeOperation} named
 *		'update', 'refresh' or 'init' will automatically be completed.
 */
rule "Create components of 'update', 'refresh', 'init' operations"
	when
		c : Changeable ( )
		o : CompositeOperation((name == "update" || name == "refresh" || name == "init"), eContainer == c)
		field : Property( c.fieldValue == field )
		
		not ( StartNode ( eContainer == o ))
		
		eval ( handler.veto( o ))

	then
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "setValueTo");
		queue.add(parameter, drools);
		
		// need to add 'cast' node
		CastNode cast = handler.generatedCastNode(o, o);
		queue.add(cast, drools);
		
		DecisionNode check = handler.generatedDecisionNode(o, o);
		handler.setName(check, "can cast?");
		queue.add(check, drools);
		
		DataFlowEdge castIn = handler.generatedDataFlowEdge(o, o, parameter, cast);
		queue.add(castIn, drools);

		DataFlowEdge castOut = handler.generatedDataFlowEdge(o, o, cast, field);
		queue.add(castOut, drools);

		DataFlowEdge castCheck = handler.generatedDataFlowEdge(o, o, cast, check);
		queue.add(castCheck, drools);
		
		CancelNode cancel = handler.generatedCancelNode(o, o);
		handler.setExceptionText(cancel, "Could not cast successfully.");
		queue.add(cancel, drools);
		// end add 'cast' node
		
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "set");
		queue.add(op, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, cast);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, op);
		handler.setTo(data2, field);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o, start, check);
		queue.add(edge1, drools);
		
		ExecutionEdge checkFail = handler.generatedExecutionEdge(o, o, check, cancel);
		handler.setName(checkFail, "no");
		queue.add(checkFail, drools);

		ExecutionEdge checkPass = handler.generatedExecutionEdge(o, o, check, op);
		handler.setName(checkPass, "yes");
		queue.add(checkPass, drools);
		
		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o, op, finish);
		queue.add(edge2, drools);

end

rule "Create components of 'set property XXX' operations"
	when
		container : ContainsOperations ( )
		field : Property ( eContainer == container, name != "fieldValue" )

		o : CompositeOperation ( eContainer == container, name != null, eval( ("set property " + field.getName()).equals(o.getName()) ) )
		
		not ( StartNode ( eContainer == o ))
		
		eval ( handler.veto( o ))

	then
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "setValueTo");
		queue.add(parameter, drools);
		
		// need to add 'cast' node
		CastNode cast = handler.generatedCastNode(o, o);
		queue.add(cast, drools);
		
		DecisionNode check = handler.generatedDecisionNode(o, o);
		handler.setName(check, "can cast?");
		queue.add(check, drools);
		
		DataFlowEdge castIn = handler.generatedDataFlowEdge(o, o, parameter, cast);
		queue.add(castIn, drools);

		DataFlowEdge castOut = handler.generatedDataFlowEdge(o, o, cast, field);
		queue.add(castOut, drools);

		DataFlowEdge castCheck = handler.generatedDataFlowEdge(o, o, cast, check);
		queue.add(castCheck, drools);
		
		CancelNode cancel = handler.generatedCancelNode(o, o);
		handler.setExceptionText(cancel, "Could not cast successfully.");
		queue.add(cancel, drools);
		// end add 'cast' node
		
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "set");
		queue.add(op, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, cast);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		DataFlowEdge data2 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data2, op);
		handler.setTo(data2, field);
		queue.add(data2, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o, start, check);
		queue.add(edge1, drools);
		
		ExecutionEdge checkFail = handler.generatedExecutionEdge(o, o, check, cancel);
		handler.setName(checkFail, "no");
		queue.add(checkFail, drools);

		ExecutionEdge checkPass = handler.generatedExecutionEdge(o, o, check, op);
		handler.setName(checkPass, "yes");
		queue.add(checkPass, drools);
		
		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o, op, finish);
		queue.add(edge2, drools);

end

rule "Create components of 'alert' operation"
	when
		o : CompositeOperation(name == "alert")
		
		eval ( handler.veto( o ))

	then
		Parameter parameter = handler.generatedParameter(o, o);
		handler.setName(parameter, "alertText");
		queue.add(parameter, drools);
		
		PrimitiveOperation op = handler.generatedPrimitiveOperation(o, o);
		handler.setName(op, "alert");
		queue.add(op, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, parameter);
		handler.setTo(data1, op);
		queue.add(data1, drools);

		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, op);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge2, op);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

end

/**
 * @inference DomainIterator,InputForm,SelectWire
 *		An {@model InputForm} connected to a {@model DomainIterator},
 *		populated by a {@model SelectWire} that will return {@model SelectWire#limit many results},
 *		will contain {@model Button}s named 'Next', 'Previous', 'First' and 'Last'.
 */
rule "Create navigation buttons for InputForms when connected to DomainIterators with many results"
	when
		object : DomainSchema ( )
		instance : DomainIterator ( limit != 1 )
		
		// TODO Drools fails with a NullPointerException if we put the eval() in the 
		// condition selector for SchemaEdge??
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval(functions.connectsSchema(schemaEdge, domainSource, object )) 
		
		select : SelectEdge ( )
		eval(functions.connectsSelect(select, instance, domainSource ))
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		not ( button : VisibleThing ( eContainer == form, name == "Next" ) )
		not ( button : VisibleThing ( eContainer == form, name == "Previous" ) )
		not ( button : VisibleThing ( eContainer == form, name == "First" ) )
		not ( button : VisibleThing ( eContainer == form, name == "Last" ) )

		eval ( handler.veto( select ))
		
	then
		Button next = handler.generatedButton(select, form);
		handler.setName(next, "Next");
		queue.add(next, drools);

		Button previous = handler.generatedButton(select, form);
		handler.setName(previous, "Previous");
		queue.add(previous, drools);

		Button first = handler.generatedButton(select, form);
		handler.setName(first, "First");
		queue.add(first, drools);

		Button last = handler.generatedButton(select, form);
		handler.setName(last, "Last");
		queue.add(last, drools);

end

/**
 * @inference DomainIterator,InputForm,SelectWire
 *		An {@model InputForm} connected to a {@model DomainIterator},
 *		populated by a {@model SelectWire} that will return {@model SelectWire#limit many results},
 *		will contain a {@model Label} named 'Results'.
 */
rule "Create 'Results' Label for InputForms when connected to DomainIterators with many results"
	when
		object : DomainSchema ( )
		instance : DomainIterator ( limit != 1 )
		
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval(functions.connectsSchema(schemaEdge, domainSource, object ))
		
		select : SelectEdge ( )
		eval(functions.connectsSelect(select, instance, domainSource ))
				
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		not ( button : VisibleThing ( eContainer == form, name == "Results" ) )

		eval ( handler.veto( select ))
		
	then
		Label label = handler.generatedLabel(select, form);
		handler.setName(label, "Results");
		queue.add(label, drools);

end

rule "Connect Next button to 'next' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		next : Button ( eContainer == form, name == "Next" )
		onClick : EventTrigger ( next.onClick == onClick )
		
		nextOp : Operation ( instance.next == nextOp )
	
		not ( run : ActionEdge ( from == onClick, to == nextOp ))  
		
		eval ( handler.veto( next ))

	then
		ActionEdge run = handler.generatedActionEdge(next, next, onClick, nextOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'hasNext' condition to Next button action"
	when
		instance : DomainIterator (  )
		hasNext : Condition ( instance.hasNext == hasNext )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		next : Button ( eContainer == form, name == "Next" )
		onClick : EventTrigger ( next.onClick == onClick )
		
		nextOp : Operation ( instance.next == nextOp )
		run : ActionEdge ( from == onClick, to == nextOp )
	
		not ( ce : ConditionEdge ( from == hasNext, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, next, hasNext, run);
		queue.add(ce, drools);

end

rule "Connect Previous button to 'previous' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		prev : Button ( eContainer == form, name == "Previous" )
		onClick : EventTrigger ( prev.onClick == onClick )
		
		prevOp : Operation ( instance.previous == prevOp )
	
		not ( run : ActionEdge ( from == onClick, to == prevOp ))  
		
		eval ( handler.veto( prev ))

	then
		ActionEdge run = handler.generatedActionEdge(prev, prev, onClick, prevOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'hasPrevious' condition to Previous button action"
	when
		instance : DomainIterator (  )
		hasPrevious : Condition ( instance.hasPrevious == hasPrevious )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		prev : Button ( eContainer == form, name == "Previous" )
		onClick : EventTrigger ( prev.onClick == onClick )
		
		prevOp : Operation ( instance.previous == prevOp )
		run : ActionEdge ( from == onClick, to == prevOp )
	
		not ( ce : ConditionEdge ( from == hasPrevious, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, prev, hasPrevious, run);
		queue.add(ce, drools);

end

rule "Connect First button to 'reset' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		first : Button ( eContainer == form, name == "First" )
		onClick : EventTrigger ( first.onClick == onClick )
		
		resetOp : Operation ( instance.reset == resetOp )
	
		not ( run : ActionEdge ( from == onClick, to == resetOp ))  
		
		eval ( handler.veto( first ))

	then
		ActionEdge run = handler.generatedActionEdge(first, first, onClick, resetOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'not empty' condition to First button action"
	when
		instance : DomainIterator (  )
		notEmpty : Condition ( eContainer == instance, name == "not empty" ) 
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		first : Button ( eContainer == form, name == "First" )
		onClick : EventTrigger ( first.onClick == onClick )
		
		resetOp : Operation ( instance.reset == resetOp )
		run : ActionEdge ( from == onClick, to == resetOp )
	
		not ( ce : ConditionEdge ( from == notEmpty, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, first, notEmpty, run);
		queue.add(ce, drools);

end

rule "Connect Last button to 'jump' operation on DomainIterator"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		
		jumpOp : Operation ( instance.jump == jumpOp )
	
		not ( run : ActionEdge ( from == onClick, to == jumpOp ))  
		
		eval ( handler.veto( last ))

	then
		ActionEdge run = handler.generatedActionEdge(last, last, onClick, jumpOp);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Connect 'not empty' condition to Last button action"
	when
		instance : DomainIterator (  )
		notEmpty : Condition ( eContainer == instance, name == "not empty" ) 
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
	
		not ( ce : ConditionEdge ( from == notEmpty, to == run ) )  
		
		eval ( handler.veto( run ))

	then
		ConditionEdge ce = handler.generatedConditionEdge(run, last, notEmpty, run);
		queue.add(ce, drools);

end

rule "Create 'target' property in Last button"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		
		not ( property : Property ( eContainer == last, name == "target" ))
		
		eval ( handler.veto( last ))

	then
		Property property = handler.generatedProperty(last, last);
		handler.setName(property, "target");
		queue.add(property, drools);
		
end

rule "Connect 'target' property to ActionEdge in Last button"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		property : Property ( eContainer == last, name == "target" )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( run ))

	then
		ParameterEdge param = handler.generatedParameterEdge(run, last, property, run);
		queue.add(param, drools);
		
end

rule "'Last' button will have a CompositeOperation named 'update target'"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		
		not ( op : Operation ( eContainer == last, name == "update target" )) 
		
		eval ( handler.veto( last ))

	then
		CompositeOperation op = handler.generatedCompositeOperation(last, last);
		handler.setName(op, "update target");
		queue.add(op, drools);
		
end

rule "'Last' button needs to call 'update target' before calling 'reset'"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		onClick : EventTrigger ( last.onClick == onClick )
		property : Property ( eContainer == last, name == "target" )
		
		jumpOp : Operation ( instance.jump == jumpOp )
		run : ActionEdge ( from == onClick, to == jumpOp )
		
		op : Operation ( eContainer == last, name == "update target" )
		
		not ( run2 : ActionEdge ( from == onClick, to == op ) ) 
		
		eval ( handler.veto( last ))

	then
		ActionEdge run2 = handler.generatedActionEdge(last, last, onClick, op);
		handler.setName(run2, "update target");
		handler.setPriority(run2, run.getPriority() + 100); 	// higher = run earlier
		queue.add(run2, drools);
		
end

rule "Create contents of 'update target' operation"
	when
		instance : DomainIterator (  )
		results : Property ( instance.results == results )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
		
		last : Button ( eContainer == form, name == "Last" )
		target : Property ( eContainer == last, name == "target" )

		op : CompositeOperation ( eContainer == last, name == "update target" )
		
		not ( StartNode ( eContainer == op ))

	then
		StartNode start = handler.generatedStartNode(op, op);
		FinishNode finish = handler.generatedFinishNode(op, op);
		queue.add(start, drools);
		queue.add(finish, drools);
		
		PrimitiveOperation setOp = handler.generatedPrimitiveOperation(op, op);
		handler.setName(setOp, "set");
		queue.add(setOp, drools);
		
		StaticValue one = handler.generatedStaticValue(op, op);
		handler.setName(one, "one");
		handler.setValue(one, "1");
		handler.setType(one, BuiltinDataTypes.getTypeInteger());
		queue.add(one, drools);
		
		Arithmetic subtract = handler.generatedArithmetic(op, op);
		handler.setType(subtract, ArithmeticOperationTypes.SUBTRACT);
		queue.add(subtract, drools);
		
		DataFlowEdge d1 = handler.generatedDataFlowEdge(op, op, results, subtract);
		DataFlowEdge d2 = handler.generatedDataFlowEdge(op, op, one, subtract);
		DataFlowEdge d3 = handler.generatedDataFlowEdge(op, op, subtract, setOp);
		DataFlowEdge d4 = handler.generatedDataFlowEdge(op, op, setOp, target);
		
		queue.add(d1, drools);
		queue.add(d2, drools);
		queue.add(d3, drools);
		queue.add(d4, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(op, op, start, setOp);
		ExecutionEdge e2 = handler.generatedExecutionEdge(op, op, setOp, finish);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		
end

/**
 * @implementation EventTrigger,DomainIterator
 *		The '{@model Changeable#onChange}' event for a {@model DomainIterator}
 *		is executed when the results, that the {@model DomainIterator} represent, change.
 */
rule "Connect Instance.onChange to Results.update"
	when
		instance : DomainIterator (  )
		event : EventTrigger ( instance.onChange == event )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		not ( run : ActionEdge ( from == event, to == updateOp ) )
		
		eval ( handler.veto( set ))
		
	then
		ActionEdge run = handler.generatedActionEdge(set, set, event, updateOp);
		handler.setName(run, "update");
		queue.add(run, drools);
		
end

rule "Connect results parameter to Results label update (onChange)"
	when
		instance : DomainIterator (  )
		event : EventTrigger ( instance.onChange == event )
		
		form : InputForm ( )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		run : ActionEdge ( from == event, to == updateOp )
		property : Property ( instance.results == property )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( set ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(set, set, property, run);
		queue.add(param, drools);
		
end

/**
 * @implementation InputForm,DomainIterator
 *		The '{@model Accessible#onAccess}' event for a paginated {@model InputForm}
 *		is executed when the {@model DomainIterator} is accessed for the first time.
 */
rule "Connect Instance.onAccess to Results.update"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		event : EventTrigger ( form.onAccess == event )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		not ( run : ActionEdge ( from == event, to == updateOp ) )
		
		eval ( handler.veto( set ))
		
	then
		ActionEdge run = handler.generatedActionEdge(set, set, event, updateOp);
		handler.setName(run, "update");
		queue.add(run, drools);
		
end

rule "Connect results parameter to Results label update (onAccess)"
	when
		instance : DomainIterator (  )
		
		form : InputForm ( )
		event : EventTrigger ( form.onAccess == event )
		set : SetWire ( )
		eval ( functions.connectsSet ( set, instance, form ))
				
		label : VisibleThing ( eContainer == form, name == "Results" )
		updateOp : Operation ( eContainer == label, name == "update" )
		
		run : ActionEdge ( from == event, to == updateOp )
		property : Property ( instance.results == property )
		
		not ( param : ParameterEdge ( from == property, to == run ))
		
		eval ( handler.veto( set ))
		
	then
		ParameterEdge param = handler.generatedParameterEdge(set, set, property, run);
		queue.add(param, drools);
		
end

/**
 * @inference Scope
 *    A {@model Scope} contains an 'onInit' {@model EventTrigger}.
 */
rule "Create 'init' event for Sessions"
	when
		session : Scope( )
		not (event : EventTrigger( eContainer == session, session.onInit == event ))
				
		eval ( handler.veto( session ))
		
	then
		EventTrigger event = handler.generatedEventTriggerOnInit(session, session);
		queue.add(event, drools);
	
end

/**
 * If a Session contains an Operation, but not a Frame, then the target Operation
 * can never be called. Consequently, we add a new Frame to all empty Sessions
 * to permit these Operations to be called.
 *
 * <p>TODO This should NOT be put as part of the inference rules, but rather the
 * code generation logic - however, this is a quicker hack ;)
 */
rule "Create an empty Frame for an empty Session, for Operation callbacks"
	when
		session : Session( )
		not ( Frame ( eContainer == session) )
				
		eval ( handler.veto( session ))
		
	then
		Frame frame = handler.generatedFrame(session, session);
		handler.setName(frame, "Empty frame for session");		
		queue.add(frame, drools);
	
end

rule "Set wires between objects should create set wires between all elements inside each object that matches [set]"
	when
		# source : SetWire(, eval(functions.connectsSet(source, p1, p2)) )
		source : SetWire( overriddenNames not contains "set" )
		p1 : CanBeSynced( )
		p2 : CanBeSynced( )
		eval( p1 != p2 )
		eval(functions.connectsSet(source, p1, p2))
		
		e1 : CanBeSynced( eContainer == p1 )
		e2 : CanBeSynced( eContainer == p2, eval(functions.nameMatches(e1, e2)) )
	
		not (sw : SetWire( eContainer == source, eval(functions.connectsSet( sw, e1, e2)) ))
				
		eval ( handler.veto( source ))
		
	then
		SetWire sw = handler.generatedSetWire(source, source, e1, e2);
		handler.setName(sw, "set");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Set wires from DomainSchema to CanBeSynced"
	when
		# source : SyncWire(, eval(connects(source, p1, p2)) )
		source : SetWire( overriddenNames not contains "set" )
		
		# we put in these to prevent multiple wires being generated for two connects
		domainSource : DomainSource ( )
		p2 : CanBeSynced ( )
		eval ( functions.connectsSet( source, domainSource, p2 ))

		eval ( domainSource != p2)
		
		domainSchema : DomainSchema ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, domainSource, domainSchema ))
		
		e1 : CanBeSynced ( eContainer == domainSchema )
		e2 : CanBeSynced( eContainer == p2 )

		eval(functions.nameMatches(e1, e2))
	
		not (sw : SetWire( eContainer == source, eval(functions.connectsSet( sw, e1, e2)) ))
		
		eval ( handler.veto( source ))
						
	then
		SyncWire sw = handler.generatedSyncWire(source, source, e1, e2);
		handler.setName(sw, "set");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Run instance wire from edit to update (onChange)"
	when
		sw : SetWire( overriddenNames not contains "run" )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

/**
 * Solves issue 209: Allow Properties to be set directly by SetWires or SyncWires.
 *
 * @inference Changeable,SetWire
 *		A {@model SetWire} connecting a {@model Changeable} to a {@model Property}
 *		directly will update the target {@model Property} when the
 *		source element is {@model Changeable#onChange changed}.
 */
rule "Run instance wire from edit to Property update (onChange)"
	when
		sw : SetWire( overriddenNames not contains "run" )
		source : Changeable( )
		
		targetContainer : ContainsOperations ( )
		target : Property ( eContainer == targetContainer )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == targetContainer, 
			name != null, 
			eval( ("set property " + target.getName()).equals(operation.getName()) ) )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from edit to update, instant SetWire (onInput)"
	when
		sw : SetWire( executeOnInput == true, overriddenNames not contains "run" ) 
		source : InputTextField( )
		target : ContainsOperations( )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation, name == "run" ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

# Ideally, these two commands would be joined together into one
rule "Connect parameter wire to: run instance wire from source.edit to target.update [set]"
	when
		sw : SetWire( overriddenNames not contains "[set] run instance parameter (source.edit)" )
		source : CanBeSynced( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
	
		event : EventTrigger( eContainer == source, name=="edit" )
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
				
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: run instance wire from source.edit to target.update [set] (onChange)"
	when
		sw : SetWire( overriddenNames not contains "[set] run instance parameter (source.edit)" )
		source : Changeable( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
	
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: Run instance wire from edit to Property update (onChange)"
	when
		sw : SetWire( overriddenNames not contains "[set] run instance parameter (source.edit)" )
		source : Changeable( )
		
		targetContainer : ContainsOperations ( )
		target : Property ( eContainer == targetContainer )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == targetContainer, 
			name != null, 
			eval( ("set property " + target.getName()).equals(operation.getName()) ) )

		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
				
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
				
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);


end

rule "Connect parameter wire to: run instance wire from source.edit to target.update [set], instant SetWire (onInput)"
	when
		sw : SetWire( overriddenNames not contains "[set] run instance parameter, instant SetWire (source.edit)" )
		source : InputTextField( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
	
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.currentInput == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter, instant SetWire (source.edit)"); 
		queue.add(pw, drools);

end

# Ideally, these two commands would be joined together into one
rule "Run instance wire from target.access to target.init, when we have a value to provide as a parameter [set] (onAccess)"
	when
		sw : SetWire( overriddenNames not contains "run" )
		source : ContainsOperations( )
		target : Accessible( )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( target.onAccess == event )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation, name == "run" ))
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from target.access to target.init, adding ConditionEdge to check it is set [set] (onAccess)"
	when
		sw : SetWire()
		source : ContainsOperations( )
		target : Accessible( )
		eval(functions.connectsSet(sw, source, target))
		
		event : EventTrigger( target.onAccess == event )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		param : ParameterEdge( from == field, to == run )
		
		# condition check
		condition : Condition ( eContainer == source, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == condition, to == run ))
					
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge cw = handler.generatedConditionEdge(sw, sw, condition, run);
		queue.add(cw, drools);
		
end	

# Ideally, these two commands would be joined together into one
rule "Connect parameter wire to: run instance wire from target.access to target.init [set]"
	when
		sw : SetWire( overriddenNames not contains "[sync] run instance parameter (source.access)" )
		source : CanBeSynced( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
	
		event : EventTrigger( eContainer == target, name=="access" )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[sync] run instance parameter (source.access)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: run instance wire from target.access to target.init [set] (onAccess)"
	when
		sw : SetWire( overriddenNames not contains "[set] run instance parameter (source.access)" )
		source : CanBeSynced( )
		target : Accessible( )
		eval(functions.connectsSet(sw, source, target))
	
		event : EventTrigger( target.onAccess == event ) 
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.access)"); 
		queue.add(pw, drools);

end

/**
 * I think that chained SetWires are generally impossible. Consider:
 * 
 *   page1 <--> page2 <--> unrelated
 *   condition on both SetWires, matching (page1, page2)
 * 
 * If we allow for chaining, then the condition 
 *   condition[page2, unrelated]
 * will be copied onto
 *   condition[page1, page2]
 * which means the SetWires will never satisfy all its conditions.
 *
 * --
 *
 * I think that chained SetWires are only possible *when* each
 * SetWires has identical Conditions, so we don't have to combine
 * the two conditions together into something impossible.
 *
 * However, trying to implement this did nothing. I think it is because
 * without adding more information to the model, you cannot chain.
 * The information you'd be adding is stuff like ChainedSetWire, but
 * this defeats the purpose of having it in the model, because this should
 * be handled by the code generation instead.
 */

rule "Cascaded SetWires: Conditions from parent to child [set]"
	when

		# the containing elements	
		sw : SetWire (  )
		source : CanBeSynced( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
		
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SetWire( name == "set", eval(functions.connectsSet(esw, e1, e2)) )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )

		# and there isn't one on the element sync wire
		not (ecw : ConditionEdge( from == condition, to == esw )) 
						
		eval ( handler.veto( cw ))
		
	then
		ConditionEdge ecw = handler.generatedConditionEdge( cw, sw, condition, esw );
		handler.setName(ecw, "[copied] from: " + cw.getId());
		queue.add(ecw, drools);

end

rule "Cascaded SetWires: Parameters from parent to child [set]"
	when

		# the containing elements
		sw : SetWire (  )
		source : CanBeSynced( )
		target : CanBeSynced( )
		eval(functions.connectsSet(sw, source, target))
		
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SetWire( name == "set", eval(functions.connectsSet(esw, e1, e2)) )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )
		
		# the generated condition wire
		ecw : ConditionEdge( from == condition, to == esw )
		
		# there is a parameter on the condition wire
		parameter : ParameterEdgesSource( )
		pw : ParameterEdge( from == parameter, to == cw )

		# and there isn't one on the element sync wire
		not (epw : ParameterEdge( from == parameter, to == ecw )) 
						
		eval ( handler.veto( cw ))
		
	then
		# create it
		ParameterEdge epw = handler.generatedParameterEdge( cw, sw, parameter, ecw );
		handler.setName(epw, "[copied] from: " + pw.getId());
		queue.add(epw, drools);

end

# SetWires do not connect the fields together; they can _also_
# connect the Frames together.
rule "Connect Session.init to incoming SetWires (contained in Frames) [set] (onChange 2)"
	when
		session : Session (  )
		sw : SetWire(  )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connectsSet(sw, sourceFrame, targetFrame ))

		sw2 : SetWire ( eContainer == sw, overriddenNames not contains "run" )
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connectsSet(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect Session.init to incoming SetWires (contained in Frames) [set] (onChange 3)"
	when
		session : Session (  )
		sw : SetWire(  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connectsSet(sw, sourceFrame, targetFrame ))

		sw2 : SetWire ( eContainer == sw, overriddenNames not contains "run" )
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connectsSet(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect parameter for Session.init to incoming SetWires (contained in Frames) [set] (onChange 2)"
	when
		session : Session (  )
		sw : SetWire(  )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connectsSet(sw, sourceFrame, targetFrame ))

		sw2 : SetWire ( eContainer == sw)
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connectsSet(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event )
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

rule "Connect parameter for Session.init to incoming SetWires (contained in Frames) [set] (onChange 3)"
	when
		session : Session (  )
		sw : SetWire(  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connectsSet(sw, sourceFrame, targetFrame ))

		sw2 : SetWire ( eContainer == sw)
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connectsSet(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event )
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

rule "Refresh New Instance Object mappings (except for generated primary keys) when Form sets an Instance: create text fields"
	when
		sync : SetWire(  )
		form : InputForm (  )
		instance : DomainIterator (  )
		
		eval(functions.connectsSet(sync, form, instance))
		
		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : InputTextField( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )
		
		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (except for generated primary keys) when Form sets an Instance: create text fields"
	when
		sync : SetWire(  )
		form : InputForm (  )
		object : DomainSchema (  )
		
		eval(functions.connectsSet(sync, form, object))
		
		attribute : DomainAttribute( eContainer == object, primaryKey == false || isGenerated == false )
		
		not ( tf : InputTextField( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		queue.add(text, drools);

end

/**
 * @inference InputForm,SetWire
 *		When two {@model InputForm}s are connected by a {@model SetWire} and the
 *		source {@model InputForm} contains a {@model InputTextField}, a <em>{@model Label}</em>
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing InputTextFields"
	when
		sync : SetWire(  )
		source : InputForm (  )
		target : InputForm (  )
		
		eval(functions.connectsSet(sync, source, target))
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )
		
		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When two {@model InputForm}s are connected by a {@model SetWire} and the
 *		source {@model InputForm} contains a {@model Label}, another label
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing Labels"
	when
		sync : SetWire(  )
		source : InputForm (  )
		target : InputForm (  )
		
		eval(functions.connectsSet(sync, source, target))
		
		sf : Label ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )
						
		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to an
 *		{@model Email}, all contained {@model InputTextField}s in the form will
 *		be copied to the Email as {@model Label}s.
 */
rule "Refresh mappings between InputForms connected to Emails containing InputTextFields"
	when
		sync : SetWire(  )
		source : InputForm (  )
		target : Email (  )
		
		eval(functions.connectsSet(sync, source, target))
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to an
 *		{@model Email}, all contained {@model Label}s in the form will
 *		be copied to the Email as {@model Label}s.
 */
rule "Refresh mappings between InputForms connected to Emails containing Labels"
	when
		sync : SetWire(  )
		source : InputForm (  )
		target : Email (  )
		
		eval(functions.connectsSet(sync, source, target))
		
		sf : Label ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to a
 *		{@model Map}, all contained {@model InputTextField}s in the form will
 *		be copied to the Email as {@model MapPoint}s.
 */
rule "Refresh mappings between InputForms connected to Maps containing InputTextFields"
	when
		sync : SetWire(  )
		source : InputForm (  )
		target : Map (  )
		
		eval(functions.connectsSet(sync, source, target))
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		MapPoint tf = handler.generatedMapPoint(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end


/**
 * <strong>Depending on the orientation of a SetWire</strong>,
 * SyncWires create InputTextFields; SetWires should create Labels, because they cannot
 * be edited.
 *
 * @inference SetWire,Label
 *		When a {@model DomainIterator} is connected to a {@model InputForm} by a {@model SetWire},
 *		{@model Label}s will be generated for its non-generated, non-primary key attributes.
 */
rule "Refresh New Instance Object mappings (except for generated primary keys) when Instance sets a Form: create labels"
	when
		sync : SetWire(  )
		form : InputForm (  )
		instance : DomainIterator (  )
		
		eval(functions.connectsSet(sync, instance, form))	// backwards
		
		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

# TODO is this rule even used anymore? consider removing.
rule "Refresh Domain Object mappings (except for generated primary keys) when Instance sets a Form: create labels"
	when
		sync : SetWire(  )
		form : InputForm (  )
		object : DomainSchema (  )
		
		eval(functions.connectsSet(sync, object, form))		// backwards
		
		attribute : DomainAttribute( eContainer == object, primaryKey == false || isGenerated == false )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (except for generated primary keys) when Instance sets a IteratorList: create labels"
	when
		sync : SetWire(  )
		form : IteratorList (  )
		instance : DomainIterator (  )
		
		eval(functions.connectsSet(sync, instance, form))	// backwards
		
		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (primary keys) when Instance sets a IteratorList: create hiddens"
	when
		sync : SetWire(  )
		form : IteratorList (  )
		instance : DomainIterator (  )
		
		eval(functions.connectsSet(sync, instance, form))	// backwards
		
		// only generated primary keys
		originalAttribute : DomainAttribute ( primaryKey == true )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new Hidden
		Hidden text = handler.generatedHidden(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "A SetWire between Attributes passed to a DomainIterator need to check that the attribute exists before initialising (onAccess)"
	when
		sync : SetWire( )
		form : VisibleThing ( )		# InputForm, IteratorList
		instance : DomainIterator ( )
		
		# form -> Iterator
		eval(functions.connectsSet(sync, form, instance))
		
		# the instance is created through a NewInstanceWire
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, domainSource, schema ))
		
		selectEdge : SelectEdge ( )
		eval ( functions.connectsSelect( selectEdge, instance, domainSource ))		
		
		# contained attribute/field
		attribute : DomainAttributeInstance( eContainer == instance )
		tf : Label ( eContainer == form )
		sync2 : SetWire ( overriddenNames not contains "check new instance exists" )
		
		# Label -> attribute
		eval(functions.connectsSet(sync2, tf, attribute))
		
		# text field access/init events
		access : EventTrigger ( tf.onAccess == access ) 
		initOp : Operation ( eContainer == tf, name == "init" )
		run : ActionEdge ( from == access, to == initOp )
		
		attributeValue : Property ( attribute.fieldValue == attributeValue )
		
		param : ParameterEdge ( from == attributeValue, to == run )  
		
		# 'not empty' condition in the instance
		existsCondition : Condition ( eContainer == instance, name == "not empty" )
		
		# but not connected		
		not (ConditionEdge ( from == existsCondition, to == run ))
						
		eval ( handler.veto( sync2 ))
		
	then
		# connect it
		ConditionEdge cw = handler.generatedConditionEdge(sync2, sync2, existsCondition, run);
		handler.setName(cw, "check new instance exists");
		queue.add(cw, drools);

end

rule "A SetWire between Attributes selected from a DomainIterator need to check that the attribute exists before initialising (onChange)"
	when
		sync : SetWire( )
		form : VisibleThing ( )		# InputForm, IteratorList
		instance : DomainIterator ( )
		
		# Iterator -> Form
		eval(functions.connectsSet(sync, instance, form))
		
		# the instance is created through a NewInstanceWire
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, domainSource, schema ))
		
		selectEdge : SelectEdge ( )
		eval ( functions.connectsSelect( selectEdge, instance, domainSource ))		
		
		# contained attribute/field
		attribute : DomainAttributeInstance( eContainer == instance )
		tf : Label ( eContainer == form )
		sync2 : SetWire ( overriddenNames not contains "check new instance exists" )
		
		# Attribute -> Label
		eval(functions.connectsSet(sync2, attribute, tf))
		
		# text field access/init events
		onChange : EventTrigger ( attribute.onChange == onChange ) 
		initOp : Operation ( eContainer == tf, name == "update" )
		run : ActionEdge ( from == onChange, to == initOp )
		
		attributeValue : Property ( attribute.fieldValue == attributeValue )
		
		param : ParameterEdge ( from == attributeValue, to == run )  
		
		# 'not empty' condition in the instance
		existsCondition : Condition ( eContainer == instance, name == "not empty" )
		
		# but not connected		
		not (ConditionEdge ( from == existsCondition, to == run ))
						
		eval ( handler.veto( sync2 ))
		
	then
		# connect it
		ConditionEdge cw = handler.generatedConditionEdge(sync2, sync2, existsCondition, run);
		handler.setName(cw, "check new instance exists");
		queue.add(cw, drools);

end

rule "Sync wires between objects should create sync wires between all elements inside each object that matches"
	when
		# source : SyncWire(, eval(connects(source, p1, p2)) )
		source : SyncWire( overriddenNames not contains "sync" )
		
		# we put in these to prevent multiple wires being generated for two connects
		p1 : CanBeSynced ( )
		p2 : CanBeSynced ( )
		eval ( functions.connectsSync1( source, p1, p2 ))

		eval (p1 != p2)
		
		e1 : CanBeSynced( eContainer == p1 )
		e2 : CanBeSynced( eContainer == p2 )

		eval(functions.nameMatches(e1, e2))
	
		not (sw : SyncWire( eContainer == source, eval(functions.connects( sw, e1, e2)) ))
		
		eval ( handler.veto( source ))
		
	then
		SyncWire sw = handler.generatedSyncWire(source, source, e1, e2);
		handler.setName(sw, "sync");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Sync wires from DomainSchema to CanBeSynced"
	when
		# source : SyncWire(, eval(connects(source, p1, p2)) )
		source : SyncWire( overriddenNames not contains "sync" )
		
		# we put in these to prevent multiple wires being generated for two connects
		domainSource : DomainSource ( )
		p2 : CanBeSynced ( )
		eval ( functions.connects( source, domainSource, p2 ))

		eval ( domainSource != p2)
		
		domainSchema : DomainSchema ( )
		schemaEdge : SchemaEdge ( )
		eval ( functions.connectsSchema( schemaEdge, domainSource, domainSchema ))
		
		e1 : CanBeSynced ( eContainer == domainSchema )
		e2 : CanBeSynced( eContainer == p2 )

		eval(functions.nameMatches(e1, e2))
	
		not (sw : SyncWire( eContainer == source, eval(functions.connects( sw, e1, e2)) ))
		
		eval ( handler.veto( source ))
						
	then
		SyncWire sw = handler.generatedSyncWire(source, source, e1, e2);
		handler.setName(sw, "sync");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Run instance wire from edit to update (onChange) x"
	when
		sw : SyncWire( overriddenNames not contains "run" )
		source : Changeable( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( from == event, to == operation, name == "run", eContainer == sw ))
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from edit to update, instant SyncWire (onInput)"
	when
		sw : SyncWire( executeOnInput == true, overriddenNames not contains "run" )
		source : InputTextField( )
		target : ContainsOperations( )
		eval(functions.connects(sw, source, target))
		
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( from == event, to == operation, name == "run", eContainer == sw ))
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Connect parameter wire to: run instance wire from source.edit to target.update (onChange)"
	when
		sw : SyncWire( overriddenNames not contains "[sync] run instance parameter (source.edit)" )
		source : Changeable( )
		target : ContainsOperations( )
		eval( functions.connects(sw, source, target))
	
		event : EventTrigger( source.onChange == event )
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[sync] run instance parameter (source.edit)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: run instance wire from source.edit to target.update, instant SyncWire (onInput)"
	when
		sw : SyncWire( executeOnInput == true, overriddenNames not contains "[sync] run instance parameter instant (source.edit)" )
		source : InputTextField( )
		target : ContainsOperations( )
		eval( functions.connects(sw, source, target))
	
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.currentInput == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[sync] run instance parameter instant (source.edit)"); 
		queue.add(pw, drools);

end

# Ideally, these two commands would be joined together into one
rule "Run instance wire from source.access to source.init, when we have a value to provide as a parameter (onAccess)"
	when
		sw : SyncWire( overriddenNames not contains "run" )
		source : Accessible( )  
		target : ContainsOperations( )
		eval ( functions.connects(sw, source, target ))
		
		event : EventTrigger( source.onAccess == event ) 
		operation : Operation( eContainer == source, name=="init" )
		field : Property( target.fieldValue == field )
		
		not (ActionEdge( from == event, to == operation, name == "run", eContainer == sw ))
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from source.access to source.init, adding ConditionEdge to check it is set (onAccess)"
	when
		sw : SyncWire()
		source : Accessible( )  
		target : ContainsOperations( )
		eval ( functions.connects(sw, source, target))
		
		event : EventTrigger( source.onAccess == event ) 
		operation : Operation( eContainer == source, name=="init" )
		field : Property( target.fieldValue == field )
		
		run : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		# condition check
		condition : Condition ( eContainer == target, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == condition, to == run ))
					
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge cw = handler.generatedConditionEdge(sw, sw, condition, run);
		queue.add(cw, drools);
		
end	

# Ideally, these two commands would be joined together into one
rule "Connect parameter wire to: run instance wire from source.access to source.init"
	when
		sw : SyncWire( overriddenNames not contains "[sync] run instance parameter (source.access)" )
		source : Accessible( )
		target : ContainsOperations( )
		eval ( functions.connects(sw, source, target))
	
		event : EventTrigger( source.onAccess == event )
		operation : Operation( eContainer == source, name=="init" )
		field : Property( target.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[sync] run instance parameter (source.access)"); 
		queue.add(pw, drools);

end

/**
 * I think that chained SyncWires are generally impossible. Consider:
 * 
 *   page1 <--> page2 <--> unrelated
 *   condition on both SyncWires, matching (page1, page2)
 * 
 * If we allow for chaining, then the condition 
 *   condition[page2, unrelated]
 * will be copied onto
 *   condition[page1, page2]
 * which means the SyncWire will never satisfy all its conditions.
 *
 * --
 *
 * I think that chained SyncWires are only possible *when* each
 * SyncWire has identical Conditions, so we don't have to combine
 * the two conditions together into something impossible.
 *
 * However, trying to implement this did nothing. I think it is because
 * without adding more information to the model, you cannot chain.
 * The information you'd be adding is stuff like ChainedSyncWire, but
 * this defeats the purpose of having it in the model, because this should
 * be handled by the code generation instead.
 */

rule "Cascaded SyncWires: Conditions from parent to child"
	when

		# the containing elements	
		sw : SyncWire (  )
		source : CanBeSynced( )  
		// cannot use 'sw.to == target, target != source'
		// can NOT use 'sw.to == target, this != source'
		// can NOT use 'sw.to == this, this != source'
		target : CanBeSynced( )
		eval ( target != source )
		
		eval ( functions.connectsSync1(sw, source, target ))
				
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SyncWire( name == "sync", eval(functions.connects(esw, e1, e2)) )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )

		# and there isn't one on the element sync wire
		not (ecw : ConditionEdge( from == condition, to == esw )) 
						
		eval ( handler.veto( cw ))
		
	then
		ConditionEdge ecw = handler.generatedConditionEdge( cw, sw, condition, esw );
		handler.setName(ecw, "[copied] from: " + cw.getId());
		queue.add(ecw, drools);

end

rule "Cascaded SyncWires: Parameters from parent to child"
	when

		# the containing elements
		sw : SyncWire (  )
		source : CanBeSynced( )  
		target : CanBeSynced( )
		eval ( target != source )

		eval ( functions.connectsSync1(sw, source, target ))
		
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SyncWire( name == "sync", eval(functions.connects(esw, e1, e2)) )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )
		
		# the generated condition wire
		ecw : ConditionEdge( from == condition, to == esw )
		
		# there is a parameter on the condition wire
		parameter : ParameterEdgesSource( )
		pw : ParameterEdge( from == parameter, to == cw )

		# and there isn't one on the element sync wire
		not (epw : ParameterEdge( from == parameter, to == ecw )) 
						
		eval ( handler.veto( cw ))
		
	then
		# create it
		ParameterEdge epw = handler.generatedParameterEdge( cw, sw, parameter, ecw );
		handler.setName(epw, "[copied] from: " + pw.getId());
		queue.add(epw, drools);

end

# SyncWires do not connect the fields together; they can _also_
# connect the Frames together.
rule "Connect Session.init to incoming SyncWires (contained in Frames) (onChange 2)"
	when
		session : Session (  )
		sw : SyncWire( )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connects(sw, sourceFrame, targetFrame ))

		sw2 : SyncWire ( eContainer == sw, overriddenNames not contains "run" )
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connects(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect Session.init to incoming SyncWires (contained in Frames) (onChange 3)"
	when
		session : Session (  )
		sw : SyncWire(  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connects(sw, sourceFrame, targetFrame ))

		sw2 : SyncWire ( eContainer == sw, overriddenNames not contains "run" )
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connects(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect parameter for Session.init to incoming SyncWires (contained in Frames) (onChange) (2)"
	when
		session : Session (  )
		sw : SyncWire(  )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connects(sw, sourceFrame, targetFrame ))

		sw2 : SyncWire ( eContainer == sw)
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connects(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

rule "Connect parameter for Session.init to incoming SyncWires (contained in Frames) (onChange) (3)"
	when
		session : Session (  )
		sw : SyncWire(  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		eval( functions.connects(sw, sourceFrame, targetFrame ))

		sw2 : SyncWire ( eContainer == sw)
		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		eval( functions.connects(sw2, sourceElement, targetElement ))

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

/**
 * @inference DomainAttributeInstance,SyncWire
 *		A {@model DomainAttributeInstance} which eventually {@model ExtendsEdge extends} a {@model DomainAttribute#primaryKey primary key}
 *		will not generate a {@model InputTextField} to edit it.
 * @implementation DomainAttributeInstance
 *		Currently, it is not possible to modify a {@model DomainAttributeInstance}
 *		that is {@model ExtendsEdge derived} or directly a {@model DomainAttribute#primaryKey primary key}.
 */
rule "Refresh New Instance Object mappings (except for generated primary keys) when sync connected to Forms: create text fields"
	when
		sync : SyncWire(  )
		form : InputForm (  )
		instance : DomainIterator (  )
		
		eval(functions.connects(sync, form, instance))
		
		originalAttribute : DomainAttribute ( )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		# at the top of the attribute inheritance heirarchy, not
		# a generated primary key
		eval( functions.notExtendingGeneratedPrimaryKey( originalAttribute ) )

		# or ANY type of primary key
		eval( functions.notExtendingPrimaryKey( originalAttribute ) )
		
		not ( tf : InputTextField( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )
		
		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (except for generated primary keys) when sync connected to Forms: create text fields"
	when
		sync : SyncWire(  )
		form : InputForm (  )
		domainSource : DomainSource (  )
		
		eval(functions.connects(sync, form, domainSource))

		# traverse the connections
		domainSchema : DomainSchema ( )		
		schemaEdge : SchemaEdge ( eval(functions.connectsSchema(schemaEdge, domainSource, domainSchema )) )  
				
		attribute : DomainAttribute( eContainer == domainSchema )
		
		# at the top of the attribute inheritance heirarchy, not
		# a generated primary key
		eval( functions.notExtendingGeneratedPrimaryKey( attribute ) )
		
		not ( tf : InputTextField( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

/**
 * @inference InputForm,SyncWire
 *		When two {@model InputForm}s are connected by a {@model SyncWire} and the
 *		source {@model InputForm} contains a {@model InputTextField}, another text field
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing InputTextFields x"
	when
		sync : SyncWire(  )
		source : InputForm (  )
		target : InputForm (  )
		
		eval(functions.connects(sync, source, target))
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )
						
		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField tf = handler.generatedInputTextField(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SyncWire
 *		When two {@model InputForm}s are connected by a {@model SyncWire} and the
 *		source {@model InputForm} contains a {@model Label}, another label
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing Labels x"
	when
		sync : SyncWire(  )
		source : InputForm (  )
		target : InputForm (  )
		
		eval(functions.connects(sync, source, target))
		
		sf : Label ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

rule "A SyncWire between Attributes selected from a NewInstanceWire need to check that the attribute exists before initialising"
	when
		sync : SyncWire(  )
		form : InputForm (  )
		instance : DomainIterator ( query == "new" )
		
		eval(functions.connects(sync, form, instance))
		
		# contained attribute/field
		attribute : DomainAttributeInstance( eContainer == instance )
		tf : InputTextField ( eContainer == form )
		sync2 : SyncWire ( overriddenNames not contains "check new instance exists" )
		
		eval(functions.connects(sync2, tf, attribute))
		
		# text field access/init events
		access : EventTrigger ( tf.onAccess == access ) 
		initOp : Operation ( eContainer == tf, name == "init" )
		run : ActionEdge ( from == access, to == initOp )
		
		attributeValue : Property ( attribute.fieldValue == attributeValue )
		
		param : ParameterEdge ( from == attributeValue, to == run )  
		
		# 'not empty' condition in the instance
		existsCondition : Condition ( eContainer == instance, name == "not empty" )
		
		# but not connected		
		not (ConditionEdge ( from == existsCondition, to == run ))
						
		eval ( handler.veto( sync2 ))
		
	then
		# connect it
		ConditionEdge cw = handler.generatedConditionEdge(sync2, sync2, existsCondition, run);
		handler.setName(cw, "check new instance exists");
		queue.add(cw, drools);

end


rule "When a session is protected by an AccessControlHandler with no login handler[type=user], add it"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session )
		
		not (LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session ))
				
		eval ( handler.veto( ach ))

	then
		LoginHandler lh = handler.generatedLoginHandler(ach, session);
		handler.setValue(lh, ComponentsPackage.eINSTANCE.getLoginHandler_Type(), LoginHandlerTypes.USER);
		handler.setName(lh, "role-based login handler");
		queue.add(lh, drools);

end

rule "When a page is protected by an AccessControlHandler with no login handler[type=user], add it"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == page )
		
		not (LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session ))
		
		# no AccessControlHandler within the session too (the above rule will create one)
		not (AccessControlHandler ( eContainer == session ))
				
		eval ( handler.veto( ach ))

	then
		LoginHandler lh = handler.generatedLoginHandler(ach, session);
		handler.setValue(lh, ComponentsPackage.eINSTANCE.getLoginHandler_Type(), LoginHandlerTypes.USER);
		handler.setName(lh, "role-based login handler");
		queue.add(lh, drools);

end

/**
 * Issue 206: Allow AccessControlHandlers to specify target Login pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'login' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the login Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Login page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "login" )
		
		not ( ActionEdge( from == login_handler, name == "login" ))
		
		eval ( handler.veto( ach ))

	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "login");
		queue.add(edge, drools);

end

/**
 * Allow AccessControlHandlers to specify target Logout pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'logout' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the logout Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Logout page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "logout" )
		
		not ( ActionEdge( from == login_handler, name == "logout" ))
		
		eval ( handler.veto( ach ))

	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "logout");
		queue.add(edge, drools);

end

/**
 * Allow AccessControlHandlers to specify target Success pages.
 *
 * @inference AccessControlHandler
 *		If a {@model AccessControlHandler} specifies a 'success' {@model ActionEdge}
 *		that goes to a {@model Frame}, the same Frame will be used as the successful login Frame
 *		for the generated {@model LoginHandler}.
 */
rule "If an AccessControlHandler specifies a Success page, connect this to the generated LoginHandler"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		login_page : Frame ( )
		login_edge : ActionEdge ( from == ach, to == login_page, name == "success" )
		
		not ( ActionEdge( from == login_handler, name == "success" ))
		
		eval ( handler.veto( ach ))

	then
		ActionEdge edge = handler.generatedActionEdge(ach, session, login_handler, login_page);
		handler.setName(edge, "success");
		queue.add(edge, drools);

end

rule "A page within a session protected by an ACH should have a 'permissions check' operation"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )

		not ( Operation ( eContainer == page, name == "permissions check" ))
					
		eval ( handler.veto( ach ))
	
	then
		CompositeOperation check = handler.generatedCompositeOperation(ach, page);
		handler.setName(check, "permissions check");
		queue.add(check, drools);	

end

rule "A page protected by an ACH should have a 'permissions check' operation"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page )

		not ( Operation ( eContainer == page, name == "page permissions check" ))
					
		eval ( handler.veto( ach ))
	
	then
		CompositeOperation check = handler.generatedCompositeOperation(ach, page);
		handler.setName(check, "page permissions check");
		queue.add(check, drools);	

end

rule "Connect 'permissions check' up to the 'access' event of the session (ACH in session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )
		access : EventTrigger ( eContainer == page, page.onAccess == access ) 
		check : Operation ( eContainer == page, name == "permissions check" )
		
		not ( ActionEdge ( from == access, to == check ))
					
		eval ( handler.veto( ach ))
	
	then
		ActionEdge run = handler.generatedActionEdge(ach, page, access, check);
		handler.setName(run, "run");
		queue.add(run, drools); 	

end 

rule "Connect 'permissions check' up to the 'access' event of the page (ACH in page)"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : Operation ( eContainer == page, name == "page permissions check" )
		
		not ( ActionEdge ( from == access, to == check ))
					
		eval ( handler.veto( ach ))
	
	then
		ActionEdge run = handler.generatedActionEdge(ach, page, access, check);
		handler.setName(run, "run");
		queue.add(run, drools); 	

end 

rule "Connect fail wire from 'permissions check' to 'login page'"
	when
		root : InternetApplication ( )
		session : Session ( eContainer == root )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : CompositeOperation ( eContainer == page, name == "permissions check" )
		lh : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		login : Frame ( name == "login", eContainer == root ) 
		
		not ( ActionEdge ( from == check, to == login, name == "fail" ))
					
		eval ( handler.veto( ach ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(ach, page, check, login);
		handler.setName(nav, "fail");
		queue.add(nav, drools);

end

rule "Connect fail wire from 'permissions check' to 'login page' (in separate login session)"
	when
		root : InternetApplication ( )
		session : Session ( eContainer == root )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )
		access : EventTrigger ( eContainer == page, page.onAccess == access )
		check : CompositeOperation ( eContainer == page, name == "permissions check" )
		lh : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		login_session : Session ( eContainer == root, eval(functions.loginHandlerScopeMatches( login_session, lh )) )
		login : Frame ( name == "login", eContainer == login_session ) 
		
		not ( ActionEdge ( from == check, to == login, name == "fail" ))
					
		eval ( handler.veto( ach ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(ach, page, check, login);
		handler.setName(nav, "fail");
		queue.add(nav, drools);

end

rule "If a Role is defined, a default role User is also defined"
	when
		root : InternetApplication ( )
		exists ( r : Role ( eContainer == root ))
		
		not ( Role ( name == "User", eContainer == root ))
					
		eval ( handler.veto( root ))
	
	then
		Role user = handler.generatedRole(root, root);
		handler.setName(user, "User");
		queue.add(user, drools);

end

rule "'User' role contains a default attribute 'email'"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root )
		
		not ( DomainAttribute ( name == "email", eContainer == user ))
					
		eval ( handler.veto( user ))
	
	then
		DomainAttribute attr = handler.generatedDomainAttribute(user, user);
		handler.setName(attr, "email");
		handler.setType(attr, BuiltinDataTypes.getTypeEmail());
		queue.add(attr, drools);

end

rule "'User' role contains a default attribute 'password'"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root )
		
		not ( DomainAttribute ( name == "password", eContainer == user ))
					
		eval ( handler.veto( user ))
	
	then
		DomainAttribute attr = handler.generatedDomainAttribute(user, user);
		handler.setName(attr, "password");
		// TODO set type to iamlPassword
		queue.add(attr, drools);

end

# TODO can we refactor these from [User/Session] pairs into an abstract 'Scope'?
/**
 * It doesn't matter whether the ACH is in the Session or in a Frame; 
 * the LoginHandler will always have the same input class (User role),
 * as the actual check logic is handled by the 'permissions check'
 * method.
 */
rule "A LoginHandler of type 'user' should have an incoming Role as a parameter, defaulting to User"
	when
		root : InternetApplication ( )
		session : Session( ) 
		login_handler : LoginHandler ( eContainer == session, type == LoginHandlerTypes.USER )
		
		exists ( 
			// it doesn't matter if the ACH is in the session or the page
			ach : AccessControlHandler ( eContainer == session 
				|| eval(functions.containingSession(ach).equals(session)) ) and

			// the store contains either the roles or the permissions
			// referenced by the ACH; we only want one
			obj : NamedElement ( ) and
			/*
				TODO This code doesn't work - it allows two incoming Permission/Roles to create
				multiple outgoing ParameterEdges.
				
				(( p : Permission ( ) and eval (obj == p) ) or
				( r : Role ( ) and eval (obj == r )) ) and
				*/

			RequiresEdge ( from == ach, to == obj )
		)
		
		# default Role
		user : Role ( eContainer == root, name == "User" )
	
		# if there is already an incoming parameter wire, don't connect up User
		not (ParameterEdge ( to == login_handler ))
		
		not (ParameterEdge ( from == user, to == login_handler ))
					
		eval ( handler.veto( login_handler ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(login_handler, session, user, login_handler);
		queue.add(param, drools);

end

rule "Create 'check permissions' operation in AccessControlHandler"
	when
		ach : AccessControlHandler( )
		
		not ( Operation ( name == "check permissions", eContainer == ach ))
					
		eval ( handler.veto( ach ))
	
	then
		PrimitiveOperation op = handler.generatedPrimitiveOperation(ach, ach);
		handler.setName(op, "check permissions");
		queue.add(op, drools);

end

rule "Create contents of 'permissions check' operation in a Frame (session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == session )

		check : CompositeOperation ( eContainer == page, name == "permissions check" )
		ach_check : Operation ( eContainer == ach, name == "check permissions" )
		
		not ( StartNode( eContainer == check ))	
				
		eval ( handler.veto( check ))

	then
			
		StartNode start = handler.generatedStartNode(check, check);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(check, check);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(check, check);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Error: You do not have valid permissions. You may need to login.");
		queue.add(cancel, drools);
		
		# virtual operation call
		OperationCallNode opCall = handler.generatedOperationCallNode(check, check);
		handler.setName(opCall, "call permissions operation");
		queue.add(opCall, drools);
		
		# run wire to this call
		ActionEdge run = handler.generatedActionEdge(check, check, opCall, ach_check);
		handler.setName(run, "run");
		queue.add(run, drools); 
	
		ExecutionEdge edge1 = handler.generatedExecutionEdge(check, check);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, opCall);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge2, "pass");
		handler.setFrom(edge2, opCall);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);
		
		# not ok	
		ExecutionEdge edge3 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge3, "fail");
		handler.setFrom(edge3, opCall);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

rule "Create contents of 'permissions check' operation in a Frame (page)"
	when
		page : Frame ( )
		ach : AccessControlHandler ( eContainer == page )

		check : CompositeOperation ( eContainer == page, name == "page permissions check" )
		ach_check : Operation ( eContainer == ach, name == "check permissions" )
		
		not ( StartNode( eContainer == check ))	
				
		eval ( handler.veto( check ))

	then
			
		StartNode start = handler.generatedStartNode(check, check);
		queue.add(start, drools);
		
		# ok
		FinishNode finish = handler.generatedFinishNode(check, check);
		queue.add(finish, drools);
		
		# not ok
		CancelNode cancel = handler.generatedCancelNode(check, check);
		handler.setValue(cancel, OperationsPackage.eINSTANCE.getCancelNode_ExceptionText(), "Error: You do not have valid permissions. You may need to login.");
		queue.add(cancel, drools);
		
		# virtual operation call
		OperationCallNode opCall = handler.generatedOperationCallNode(check, check);
		handler.setName(opCall, "call permissions operation");
		queue.add(opCall, drools);
		
		# run wire to this call
		ActionEdge run = handler.generatedActionEdge(check, check, opCall, ach_check);
		handler.setName(run, "run");
		queue.add(run, drools); 
	
		ExecutionEdge edge1 = handler.generatedExecutionEdge(check, check);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, opCall);
		queue.add(edge1, drools);

		# ok
		ExecutionEdge edge2 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge2, "pass");
		handler.setFrom(edge2, opCall);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);
		
		# not ok	
		ExecutionEdge edge3 = handler.generatedExecutionEdge(check, check);
		handler.setName(edge3, "fail");
		handler.setFrom(edge3, opCall);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end

rule "An AccessControlHandler that creates a LoginHandler should have the created 'current instance' as an incoming parameter (session)"
	when
		session : Session ( )
		ach : AccessControlHandler ( eContainer == session )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		instance : DomainIterator ( eContainer == session )
		setWire : SetWire ( from == login_handler, to == instance )
		
		not ( ParameterEdge ( from == instance, to == ach )) 
					
		eval ( handler.veto( ach ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(ach, ach, instance, ach);
		queue.add(param, drools);

end

rule "A separate AccessControlHandler that creates a LoginHandler should have the created 'current instance' as an incoming parameter (page within a session)"
	when
		session : Session ( )
		page : Frame ( eContainer == session )
		ach : AccessControlHandler ( eContainer == page )
		login_handler : LoginHandler ( type == LoginHandlerTypes.USER, eContainer == session )
		
		instance : DomainIterator ( eContainer == session )
		setWire : SetWire ( from == login_handler, to == instance )
		
		not ( ParameterEdge ( from == instance, to == ach )) 
					
		eval ( handler.veto( ach ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(ach, ach, instance, ach);
		queue.add(param, drools);

end

rule "Any role should extend the default User role"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root )
		
		another : Role ( this != user )
		
		not ( ExtendsEdge ( from == another, to == user ))
						
		eval ( handler.veto( user ))
		
	then
		ExtendsEdge ext = handler.generatedExtendsEdge(user, root, another, user);
		queue.add(ext, drools);

end

rule "The generated default User has an identical DomainSource as the extended Role"
	when
		root : InternetApplication ( )
		user : Role ( name == "User", eContainer == root )

		exists (
			original : DomainSource ( ) and
					 
			another : Role ( this != user ) and
			
			extends : ExtendsEdge ( from == another, to == user ) and
			
			# there's a schema edge from the original source to the subclassed role
			schemaEdge : SchemaEdge ( from == original, to == another )
		)
			
		not ( SchemaEdge ( to == user ))
						
		eval ( handler.veto( user ))

	then
		DomainSource original = functions.getOriginalDomainSource(user);
	
		DomainSource source = handler.generatedDomainSource(user, root);
		handler.setFile(source, original.getFile());
		handler.setType(source, original.getType());
		handler.setUrl(source, original.getUrl());
		handler.setCache(source, original.getCache());
		queue.add(source, drools);
		
		SchemaEdge edge = handler.generatedSchemaEdge(user, root, source, user);
		queue.add(edge, drools);
	
end

/**
 * @inference InputTextField,Label
 *		{@model InputTextField}s will contain a {@model Label} named 'Warning'.
 */
rule "Create 'Warning' Label for InputTextFields"
	when
		tf : InputTextField( )
		not ( warning : Label ( name == "Warning", eContainer == tf ))
					
		eval ( handler.veto( tf ))
	
	then
		Label warning = handler.generatedLabel(tf, tf);
		handler.setName(warning, "Warning");
		queue.add(warning, drools);
	
end

rule "When two TextFields of different types are under a SyncWire, add a 'validate' operation"
	when
		e1 : InputTextField( )
		e1_property : Property ( e1.fieldValue == e1_property )
		e2 : InputTextField( )
		e2_property : Property ( e2.fieldValue == e2_property )
		eval ( e1 != e2 )
		sw : SyncWire ( )
		eval ( functions.connects(sw, e1, e2) )
		
		eval ( e1.getType() != e2.getType() )
		
		not ( op : Operation ( name == "validate", eContainer == e1, eval(functions.generatedBy(sw, op)) ))
						
		eval ( handler.veto( sw ))
		
	then
		CompositeOperation op = handler.generatedCompositeOperation(sw, e1);
		handler.setName(op, "validate");
		queue.add(op, drools);

end

rule "When two TextFields of different types are under a SyncWire, call the 'validate' operation onChange"
	when
		e1 : InputTextField( )
		e1_property : Property ( e1.fieldValue == e1_property )
		e2 : InputTextField( )
		e2_property : Property ( e2.fieldValue == e2_property )
		eval ( e1 != e2 )
		sw : SyncWire ( )
		eval ( functions.connects(sw, e1, e2) )
		
		eval ( e1.getType() != e2.getType() )
		
		event : EventTrigger ( e1.onChange == event )
		
		op : Operation ( name == "validate", eContainer == e1, eval(functions.generatedBy(sw, op)) )
		
		not ( run : ActionEdge ( from == event, to == op ) )
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge run = handler.generatedActionEdge(sw, e1, event, op);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Create contents of 'validate' operation"
	when
		e1 : InputTextField( )
		e1_property : Property ( e1.fieldValue == e1_property )
		e2 : InputTextField( )
		e2_property : Property ( e2.fieldValue == e2_property )
		eval ( e1 != e2 )
		sw : SyncWire ( )
		eval ( functions.connects(sw, e1, e2) )
		
		eval ( e1.getType() != e2.getType() )
		
		o : CompositeOperation ( name == "validate", eContainer == e1, eval(functions.generatedBy(sw, o)) )

		warning : Label ( name == "Warning", eContainer == e1 )

		show : Operation ( name == "show", eContainer == warning )
		hide : Operation ( name == "hide", eContainer == warning )

		upd : Operation ( name == "update", eContainer == warning )
		
		not ( start : StartNode ( eContainer == o ))
				
		eval ( handler.veto( o ))

	then
	
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		DecisionNode check = handler.generatedDecisionNode(o, o);
		handler.setName(check, "can cast?");
		queue.add(check, drools);
		
		ExecutionEdge step1 = handler.generatedExecutionEdge(o, o, start, check);
		queue.add(step1, drools);
		
		CastNode cast = handler.generatedCastNode(o, o);
		queue.add(cast, drools);
		
		DataFlowEdge castIn = handler.generatedDataFlowEdge(o, o, e1_property, cast);
		queue.add(castIn, drools); 

		DataFlowEdge castOut = handler.generatedDataFlowEdge(o, o, cast, e2_property);
		queue.add(castOut, drools); 
		
		DataFlowEdge castCheck = handler.generatedDataFlowEdge(o, o, cast, check);
		queue.add(castCheck, drools);
		
		OperationCallNode callHide = handler.generatedOperationCallNode(o, o);
		handler.setName(callHide, "call hide");
		queue.add(callHide, drools);
		
		ActionEdge runHide = handler.generatedActionEdge(o, o, callHide, hide);
		handler.setName(runHide, "run");
		queue.add(runHide, drools);
		 
		OperationCallNode callShow = handler.generatedOperationCallNode(o, o);
		handler.setName(callShow, "call show");
		queue.add(callShow, drools);
		
		ActionEdge runShow = handler.generatedActionEdge(o, o, callShow, show);
		handler.setName(runShow, "run");
		queue.add(runShow, drools);
		
		OperationCallNode callUpdate = handler.generatedOperationCallNode(o, o);
		handler.setName(callUpdate, "update label");
		queue.add(callUpdate, drools);
		
		ActionEdge runUpdate = handler.generatedActionEdge(o, o, callUpdate, upd);
		handler.setName(runUpdate, "run");
		queue.add(runUpdate, drools);
		
		// parameter for update
		StaticValue message = handler.generatedStaticValue(o, o);
		handler.setName(message, "failure message");
		handler.setValue(message, "Warning: Invalid input.");
		queue.add(message, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(o, o, message, runUpdate);
		queue.add(param, drools);
		
		// check (pass) -> finish
		ExecutionEdge castPass = handler.generatedExecutionEdge(o, o, check, callHide);
		handler.setName(castPass, "yes");
		queue.add(castPass, drools);
		
		FinishNode finish1 = handler.generatedFinishNode(o, o);
		queue.add(finish1, drools);
		
		ExecutionEdge passFinish = handler.generatedExecutionEdge(o, o, callHide, finish1);
		queue.add(passFinish, drools);
		
		// check (fail) -> finish
		ExecutionEdge castFail = handler.generatedExecutionEdge(o, o, check, callUpdate);
		handler.setName(castFail, "no");
		queue.add(castPass, drools);
		
		ExecutionEdge castFail2 = handler.generatedExecutionEdge(o, o, callUpdate, callShow);
		queue.add(castFail2, drools);
		
		FinishNode finish2 = handler.generatedFinishNode(o, o);
		queue.add(finish2, drools);
		
		ExecutionEdge failFinish = handler.generatedExecutionEdge(o, o, callShow, finish2);
		queue.add(failFinish, drools);
		
end

/**
 * @inference VisibleThing
 *		{@model VisibleThing}s have an {@model EventTrigger} 'onInput'.
 */
rule "VisibleThings have an event onInput"
	when
		field : VisibleThing ( )
		not ( event : EventTrigger ( field.onInput == event ))
	
		eval ( handler.veto( field ))
	
	then
		EventTrigger event = handler.generatedEventTriggerOnInput(field, field);
		handler.setName(event, "onInput");
		queue.add(event, drools);

end

/**
 * We only create currentInput for things that can actually use it, to
 * simplify the completed model; i.e. only text fields.
 *
 * @inference InputTextField
 *		{@model InputTextField}s have an {@model Property} 'currentInput'.
 */
rule "InputTextFields have a Property currentInput"
	when
		field : InputTextField ( )
		not ( property : Property ( field.currentInput == property ))
	
		eval ( handler.veto( field ))
	
	then
		Property property = handler.generatedPropertyCurrentInput(field, field);
		handler.setName(property, "currentInput");
		handler.setType(property, BuiltinDataTypes.getTypeString());
		queue.add(property, drools);

end

/**
 * @inference VisibleThing
 *		{@model VisibleThing}s have an {@model EventTrigger} 'onClick'.
 */
rule "VisibleThings have an event onClick"
	when
		f : VisibleThing( )
		not (event : EventTrigger( f.onClick == event ))
				
		eval ( handler.veto( f ))
			
	then
		EventTrigger event = handler.generatedEventTriggerOnClick(f, f);
		queue.add(event, drools);
		
end

/**
 * @inference VisibleThing
 *		{@model VisibleThing}s have an {@model PrimitiveCondition} 'empty'.
 */
rule "VisibleThings have a PrimitiveCondition 'empty'"
	when
		f : VisibleThing( )
		not (condition : Condition( eContainer == f, name == "empty" ))
				
		eval ( handler.veto( f ))
			
	then
		PrimitiveCondition condition = handler.generatedPrimitiveCondition(f, f);
		handler.setName(condition, "empty");
		queue.add(condition, drools);
		
end

/**
 * @inference VisibleThing
 *		{@model VisibleThing}s have an {@model PrimitiveCondition} 'not empty'.
 */
rule "VisibleThings have a PrimitiveCondition 'not empty'"
	when
		f : VisibleThing( )
		not (condition : Condition( eContainer == f, name == "not empty" ))
				
		eval ( handler.veto( f ))
			
	then
		PrimitiveCondition condition = handler.generatedPrimitiveCondition(f, f);
		handler.setName(condition, "not empty");
		queue.add(condition, drools);
		
end

/**
 * @inference VisibleThing
 *		A {@model VisibleThing} has a {@model PrimitiveOperation} 'hide'.
 */
rule "Create 'hide' PrimitiveOperation for VisibleThing"
	when
		tf : VisibleThing( )
		not ( op : Operation ( name == "hide", eContainer == tf ))
		
		eval ( handler.veto( tf ))
	
	then
		PrimitiveOperation warning = handler.generatedPrimitiveOperation(tf, tf);
		handler.setName(warning, "hide");
		queue.add(warning, drools);
	
end

/**
 * @inference VisibleThing
 *		A {@model VisibleThing} has a {@model PrimitiveOperation} 'show'.
 */
rule "Create 'show' PrimitiveOperation for VisibleThing"
	when
		tf : VisibleThing( )
		not ( op : Operation ( name == "show", eContainer == tf ))
		
		eval ( handler.veto( tf ))
	
	then
		PrimitiveOperation warning = handler.generatedPrimitiveOperation(tf, tf);
		handler.setName(warning, "show");
		queue.add(warning, drools);
	
end
