/**
 * Client-side operations.
 */
«IMPORT iaml»

/* expand EventTriggers when they are attached to a child. */
/* perhaps a better way of doing this would be to create a secondary model (using model extensions)
   which is then used to generate the application more straightforward. */
/* or even iaml --> [phpModel] --> phpOutput, although this reduces little complexity */
«EXTENSION template::GeneratorExtensions»

/* we are in an input element, and we have to register event handlers */
/* the event handlers are not actually defined here - they have to be defined elsewhere in the page */
«DEFINE expandEventTriggers(String type) FOR model::EventTrigger»
	«IF name==type»
		«REM»the Page call worries about which ones to place where«ENDREM»
		«EXPAND callOperations(false) FOREACH outEdges»
	«ENDIF»
«ENDDEFINE»

/* if we are expanding inline a function already */
«DEFINE expandEventTriggersInline FOR emf::EObject»
	// cannot expand for non-event object
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::ContainsEventTriggers»
	«EXPAND expandEventTriggersInline FOREACH eventTriggers»
«ENDDEFINE»

«DEFINE expandEventTriggersInline FOR model::EventTrigger»
	// expanding inline event trigger «name»
	«IF name=="edit"»
		«EXPAND callOperations(true) FOREACH outEdges»
	«ELSEIF name=="access"»
		// we don't expand 'access' events inline
	«ELSE»
		«EXPAND exception FOR throwException("Unknown client-side event trigger: " + this)»
	«ENDIF»
«ENDDEFINE»

/* default: don't know what to do with a wire */
«DEFINE callOperations(Boolean inline) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Unknown wire edge connected to edit trigger: " + this)»
«ENDDEFINE»

/* 
 * run a command with some parameters. this could be in inline JS or a JS block.
 * RunInstanceWire: event --> operation 
 */
«DEFINE callOperations(Boolean inline) FOR model::wires::RunInstanceWire-»
	/* eContainer == «to.eContainer» */
	«IF to.eContainer.metaType.superTypes.contains( model::VisibleThing )-»
		«REM»VisibleThing includes InputTextField and Page«ENDREM»
		«REM»
			is both source and target on the same page? NOTE this
			will also return true for Event-->Operation if they are
			both on the same page.
		«ENDREM»
		«IF onCurrentPage(from, to)-»
			«REM»// on current page (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND callOperationParameters(this, inline) FOREACH inEdges SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current page (wire id = «id»)«ENDREM»
			store_event('«containingPage(to).id»', 'do_«operationName(to)»'
				«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline) FOREACH inEdges SEPARATOR ", "»«ENDIF»
			);
		«ENDIF-»
	«ELSEIF isAbstractDomainAttribute(to.eContainer)-»
		«REM»direct field --> domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF inEdges.size>0», «EXPAND callOperationParameters(this, inline) FOREACH inEdges SEPARATOR ", "»«ENDIF»
		); 
	«ELSE-»
		alert('unknown target operation type in «to.eContainer.metaType.name»');
		«EXPAND exception FOR throwException("Unknown target operation type in '" + to.eContainer.metaType.name + "' (this=" + this + ")")»
	«ENDIF-»
«ENDDEFINE»

/* ditto: check or error? */
«DEFINE callOperationParameters(model::WireEdge wire, Boolean inline) FOR model::WireEdge»
	«ERROR "unknown in edge: " + this»
«ENDDEFINE»

/* making sure that the parameter wire is from a parameter... */
«DEFINE callOperationParameters(model::WireEdge wire, Boolean inline) FOR model::wires::ParameterWire»
	«EXPAND callOperationParametersSource(wire, inline) FOR from»
«ENDDEFINE»

/* ditto: check or error? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::WireEdgesSource»
	«EXPAND exception FOR throwException("Unknown parameter wire source: " + this)»
«ENDDEFINE»

/* what is the runtime value of the parameter? */
«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::ApplicationElementProperty»
	«IF name == "fieldValue"»
		«REM»where is this value stored? is it available on the current page?«ENDREM»
		«IF onCurrentPage(wire.from, this)» 
			document.getElementById('«safeName(eContainer)»').value
		«ELSE»
			«REM»
				it's not on the current page. it could be anywhere!
				but we want it NOW, so we can't just ask the 
				server. we have to find out where it is.
			«ENDREM»			
			«EXPAND remoteParameterSource(false, wire, inline, this) FOR this.eContainer-»
		«ENDIF»
	«ELSE»
		get_application_element_property("«safeName()-»")
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperationParametersSource(model::WireEdge wire, Boolean inline) FOR model::StaticValue»
	"«value-»" /* static value "«name-»" */
«ENDDEFINE»

/* a remote data source */
«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR emf::EObject»
	«EXPAND exception FOR throwException("Cannot find a remote parameter source for " + this)»
«ENDDEFINE»

«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::domain::FileDomainAttribute»
	"<?php 
		// remote parameter source from a .properties file
		$db_name = "«getFileDomainStore(this).file-»";
		$row_name = "«safeNameString(this.name)-»";
		$properties = load_properties($db_name);
		$value = get_property($properties, $row_name, null);
		«IF require»
			// the value is required
			if ($value === null) {
				throw new IamlRuntimeException("Could not fetch row '$row_name' from properties database '$db_name': no results found");
			}
		«ENDIF»
		echo htmlspecialchars($value); 
	?>" 
«ENDDEFINE» 

«DEFINE remoteParameterSource(boolean require, model::WireEdge wire, Boolean inline, model::ApplicationElementProperty property) FOR model::DomainAttribute»
	"<?php 
		// remote parameter source from a database file
		$db_name = "sqlite:«safeNameString(getDomainStore(this).id)».db";
		$table_name = "«safeNameString(getDomainObject(this).name)»";
		$row_name = "«safeNameString(this.name)»";
		
		// TODO: put this into a function
		if (!$db_name)
			local_die("no $db_type db found");
		if (!$table_name)
			local_die("no $db_type table found (db=$db_name)");
		if (!$row_name)
			local_die("no $db_type row found (table=$table_name)");
		
		// connect to the database source
		$db = new PDO($db_name) or local_die("could not open $db_type db '$db_name'");
		
		// does anything exist?
		$results = $db->query("SELECT $row_name FROM $table_name") or local_die("could not look for existing values in $db_type '$table_name': " .print_r($db->errorInfo(), true));
		if ($row = $results->fetch()) {
			// update
			echo htmlspecialchars($row[$row_name]);
		} else {
			// empty
			«IF require»
				throw new IamlRuntimeException("Could not fetch row '$row_name' from table '$table_name' from database '$db_name': no results found");
			«ELSE»
				// not required
			«ENDIF»
		}		
	?>" 
«ENDDEFINE» 

/* expand out the operations for the page */
«DEFINE expandOperations FOR model::ContainsOperations-»
	«EXPAND expandOperation FOREACH operations-»
«ENDDEFINE»

«DEFINE expandOperations FOR model::ApplicationElementContainer-»
	// expanding operations for «this»
	«EXPAND expandOperation FOREACH allContainerOperations()-»
«ENDDEFINE»

«DEFINE expandOperation FOR model::Operation-»
	/* simple operation */
	function do_«safeName()»(«EXPAND expandParameters FOREACH parameters SEPARATOR ", "-») {
		alert("simple operation: «name»");
	}
«ENDDEFINE»

«DEFINE expandOperation FOR model::CompositeOperation»
	/** composite operation "«name»" */
	var running_«safeName()» = false;
	function do_«safeName()»(«EXPAND expandParameters FOREACH parameters SEPARATOR ", "-») {
		«REM»here we would expand out the data flow of the operation, etc«ENDREM»
		// operation: «name»
		if (running_«safeName()-» == false) {
			running_«safeName()-» = true;		// prevent loops
			
			// has this operation got a fail handler?
			«IF getFailEdge() != null»
				// fail edge «getFailEdge()»
				try {
					try_catch_depth++;
			«ENDIF»
			
			// execute the operation
			// if we are at the root try/catch, catch the exception explicitly
			if (try_catch_depth == 0 «IF getFailEdge() != null»&& false /* we have a fail edge -- run the "else" block */«ENDIF» ) {
				try {
					// get chained functions
					var function_queue = function() {
						// continue with any chained operations
						«EXPAND continueChainedOperations FOR this-»
					}
					var function_queue_queued = false;
				
					«EXPAND doExecutionFlow FOR startNode()-»
					
					// should we still run the chained functions?
					if (!function_queue_queued)
						function_queue();
				} catch (e if e instanceof IamlJavascriptException) {
					// unexpected exception
					alert("Unexpected exception: " + e);
				}
			} else {
				// get chained functions
				var function_queue = function() {
					// continue with any chained operations
					«EXPAND continueChainedOperations FOR this-»
				}
				var function_queue_queued = false;
			
				«EXPAND doExecutionFlow FOR startNode()-»
				
				// should we still run the chained functions?
				if (!function_queue_queued)
					function_queue();
			}					

			«IF getFailEdge() != null»
					try_catch_depth--;
				} catch (e if e instanceof IamlJavascriptException) {
					debug("Caught exception " + e);
					«EXPAND expandFailEdge FOR getFailEdge()»
				}
			«ENDIF»

			running_«safeName()-» = false;
		}
	}
«ENDDEFINE»

«DEFINE expandParameters FOR model::Parameter-»
	«safeName()-»
«ENDDEFINE»

/* I don't know how in JS we are supposed to handle multiple out edges yet... but we'll get there ;) */
«DEFINE doExecutionFlow FOR model::operations::StartNode-»
	// flow starts here
	«FOREACH outExecutions AS e-»
		«EXPAND doExecutionFlowNext FOR e.to-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE doExecutionFlow FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/* an edge that is the end (both StartNode and FinishNode also fall into this) */
«DEFINE doExecutionFlowNext FOR model::ExecutionEdgeDestination-»
	// do nothing «this-»
«ENDDEFINE»

«DEFINE doExecutionFlowNext FOR model::operations::CancelNode-»
	«IF exceptionText.length > 0»
		throw new IamlJavascriptException("«exceptionText»");
	«ENDIF»
«ENDDEFINE»

/* a chained operation (or decision operation): expandOperationContents will continue the execution flow */
«DEFINE doExecutionFlowNext FOR model::ChainedOperation-»
	// chained operation «name-»
	«EXPAND expandOperationContents FOR this-»
«ENDDEFINE»

/* expand the definition of an operation, assumed to be called as part of an existing function call */
«DEFINE expandOperationContents FOR model::ChainedOperation-»
	«REM»special operation names«ENDREM»
	«IF name == "setPropertyToValue"-»
		«REM»outflowTarget == inflowTarget«ENDREM»
		// outFlows first to = «outFlows.first().to»
		«IF isInputTextField(outFlows.first().to.eContainer)»
			// set a variable in the current page (assumed)
			«EXPAND setPropertyToValueOutflowTarget FOR outFlows.first().to» = «EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-»;
		«ELSEIF containingSession(outFlows.first().to) == null»
			«REM»contained in a Page or InternetApplication: a static value«ENDREM»
			set_application_value("«safeName(outFlows.first().to)»", 
				«EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-», 
				function_queue);
			function_queue_queued = true;		// we are waiting for it to return to execute the function queue
		«ELSE»
			«REM»contained in a Session: a session value«ENDREM»
			set_session("«safeName(containingSession(outFlows.first().to))»_«safeName(outFlows.first().to)»", 
				«EXPAND setPropertyToValueInflowTarget FOR inFlows.first().from-», 
				function_queue);
			function_queue_queued = true;		// we are waiting for it to return to execute the function queue
		«ENDIF»

		«REM»
			in the future, we might want to make this into a function that is passed
			to ajax calls and executed once the call is successful.
		«ENDREM»
		«FOREACH outExecutions AS e-»
			«EXPAND doExecutionFlowNext FOR e.to-»
		«ENDFOREACH»
		
		«REM»
			now we expand all the event triggers for the source element that contains the fieldValue: 
			if any of them have an eventTrigger, they should be called if necessary
		«ENDREM»
		«IF shouldExpandEventTriggers(this)»
			«EXPAND expandEventTriggersInline FOR outFlows.first().to.eContainer-»
		«ELSE»
			// we don't call additional events for «eContainer» 
		«ENDIF»
	«ELSE»
		«REM»an existing function on this page«ENDREM»
		«ERROR "Unknown client-side function to expand: " + this»
	«ENDIF»
«ENDDEFINE»

/* expand the definition of an operation, assumed to be called as part of an existing function call */
«DEFINE expandOperationContents FOR model::operations::DecisionOperation-»
	«REM»compare operations«ENDREM»
	if (
	«IF name == "equal?"-»
		«REM»check all inflow targets are identical«ENDREM»
		is_array_equal(new Array(«EXPAND expandCheckInflows FOREACH inFlows SEPARATOR ", "»))
	«ELSE»
		«REM»??? who knows«ENDREM»
		«ERROR "Unknown decision operation '" + this + "'"»
	«ENDIF»
	) {
		// passed (exactly one pass)
		«EXPAND doExecutionFlowNext FOR passedExectionFlow().to»
	} else {
		// failed (exactly one fail)
		«EXPAND doExecutionFlowNext FOR failedExectionFlow().to»
	}
«ENDDEFINE»

/* data flows out */
«DEFINE setPropertyToValueOutflowTarget FOR model::DataFlowEdgeDestination»
	«ERROR "unknown data flow edge destination for setPropertyToValue: " + this»
«ENDDEFINE»

«DEFINE setPropertyToValueOutflowTarget FOR model::ApplicationElementProperty»	
	document.getElementById('«safeNameString(( (model::NamedElement) eContainer).id)»').value
«ENDDEFINE»

/* data flows in */
«DEFINE setPropertyToValueInflowTarget FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow edge source for setPropertyToValue: " + this)»
«ENDDEFINE»

// TODO need to wrap value in some sort of encoding algorithm
«DEFINE setPropertyToValueInflowTarget FOR model::StaticValue»
	"«value-»" /* static value "«safeName()-»" */ 
«ENDDEFINE»

«DEFINE setPropertyToValueInflowTarget FOR model::Parameter»
	«safeName()»
«ENDDEFINE»

«DEFINE expandCheckInflows FOR model::DataFlowEdge-»
	«EXPAND expandCheckInflowsName FOR from-»
«ENDDEFINE»

/** get the data for the elements we are checking */
«DEFINE expandCheckInflowsName FOR model::DataFlowEdgesSource-»
	«EXPAND exception FOR throwException("Unknown data inflow edge source: " + this)»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::Parameter-»
	«safeName()-»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::ApplicationElementProperty-»
	«IF containingSession(this) != null»
		/* a property from our session */
		require_session("«safeName(containingSession(this))»_«safeName()-»")
	«ELSE»
		get_application_property("«safeName()-»")
	«ENDIF»
«ENDDEFINE»

«DEFINE expandCheckInflowsName FOR model::StaticValue-»
	"«value-»"
«ENDDEFINE»

/** fail edges */
«DEFINE expandFailEdge FOR model::WireEdge-»
	«EXPAND exception FOR throwException("Cannot expand the unknown fail edge: " + this)»
«ENDDEFINE»

«DEFINE expandFailEdge FOR model::wires::NavigateWire-»
	// we need to navigate to the fail page
	var url = "«safeName(to)».php?fail=" + e; /* TODO urlencode me */
	debug("Redirecting to '" + url + "' (fail)");
	window.location = url;
«ENDDEFINE»

/** continue operation execution */
«DEFINE continueChainedOperations FOR model::CompositeOperation-»
	«EXPAND continueChainedOperations FOREACH outEdges»
«ENDDEFINE»

«DEFINE continueChainedOperations FOR model::WireEdge»
	«EXPAND exception FOR throwException("Cannot continue a chained operation for: " + this)»
«ENDDEFINE»

«DEFINE continueChainedOperations FOR model::wires::NavigateWire»
	«IF name != "fail"»
		// navigate to another page
		var url = "«safeName(to)».php";
		debug("Redirecting to '" + url + "'");
		window.location = url;
	«ELSE»
		// ignoring fail wire
	«ENDIF»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»