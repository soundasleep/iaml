/**
 * Completes the functionality of {@model SetWire}s.
 */
package org.openiaml.model.drools.rules.set_wires

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Set wires between objects should create set wires between all elements inside each object that matches [set]"
	when
		p1 : CanBeSynced( )
		p2 : CanBeSynced( this != p1 )
		source : SetWire( from == p1, to == p2, overriddenNames not contains "set" )
		
		e1 : CanBeSynced( eContainer == p1 )
		e2 : CanBeSynced( eContainer == p2, eval(functions.nameMatches(e1, e2)) )
	
		not (sw : SetWire( eContainer == source, from == e1, to == e2 ))
				
		eval ( handler.veto( source ))
		
	then
		SetWire sw = handler.generatedSetWire(source, source, e1, e2);
		handler.setName(sw, "set");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Set wires from DomainSchema to CanBeSynced"
	when
		# we put in these to prevent multiple wires being generated for two connects
		domainSource : DomainSource ( )
		p2 : CanBeSynced ( )

		source : SetWire( from == domainSource, to == p2, overriddenNames not contains "set" )

		eval ( domainSource != p2)
		
		domainSchema : DomainSchema ( )
		schemaEdge : SchemaEdge ( from == domainSource, to == domainSchema )
		
		e1 : CanBeSynced ( eContainer == domainSchema )
		e2 : CanBeSynced( eContainer == p2 )

		eval(functions.nameMatches(e1, e2))
	
		not (sw : SetWire( eContainer == source, from == e1, to == e2 ))
		
		eval ( handler.veto( source ))
						
	then
		SetWire sw = handler.generatedSetWire(source, source, e1, e2);
		handler.setName(sw, "set");
		handler.setExecuteOnInput(sw, source.isExecuteOnInput());
		queue.add(sw, drools);
		
end

rule "Run instance wire from edit to update (onChange)"
	when
		source : Changeable( )
		target : ContainsOperations( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "run" )
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

/**
 * Solves issue 209: Allow Properties to be set directly by SetWires or SyncWires.
 *
 * @inference Changeable,SetWire
 *		A {@model SetWire} connecting a {@model Changeable} to a {@model Property}
 *		directly will update the target {@model Property} when the
 *		source element is {@model Changeable#onChange changed}.
 */
rule "Run instance wire from edit to Property update (onChange)"
	when
		source : Changeable( )
		
		targetContainer : ContainsOperations ( )
		target : Property ( eContainer == targetContainer )
		sw : SetWire( from == source, to == target, overriddenNames not contains "run" )

		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == targetContainer, 
			name != null, 
			eval( ("set property " + target.getName()).equals(operation.getName()) ) )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from edit to update, instant SetWire (onInput)"
	when
		source : InputTextField( )
		target : ContainsOperations( )
		sw : SetWire( from == source, to == target, executeOnInput == true, overriddenNames not contains "run" ) 
		
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation, name == "run" ))
				
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

# Ideally, these two commands would be joined together into one
rule "Connect parameter wire to: run instance wire from source.edit to target.update [set]"
	when
		source : CanBeSynced( )
		target : CanBeSynced( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[set] run instance parameter (source.edit)" )
	
		event : EventTrigger( eContainer == source, name=="edit" )
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
				
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: run instance wire from source.edit to target.update [set] (onChange)"
	when
		source : Changeable( )
		target : CanBeSynced( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[set] run instance parameter (source.edit)" )
	
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: Run instance wire from edit to Property update (onChange)"
	when
		source : Changeable( )
		
		targetContainer : ContainsOperations ( )
		target : Property ( eContainer == targetContainer )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[set] run instance parameter (source.edit)" )
		
		event : EventTrigger( source.onChange == event ) 
		operation : Operation( eContainer == targetContainer, 
			name != null, 
			eval( ("set property " + target.getName()).equals(operation.getName()) ) )

		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
				
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
				
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.edit)"); 
		queue.add(pw, drools);


end

rule "Connect parameter wire to: run instance wire from source.edit to target.update [set], instant SetWire (onInput)"
	when
		source : InputTextField( )
		target : CanBeSynced( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[set] run instance parameter, instant SetWire (source.edit)" )
	
		event : EventTrigger( source.onInput == event ) 
		operation : Operation( eContainer == target, name=="update" )
		field : Property( source.currentInput == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter, instant SetWire (source.edit)"); 
		queue.add(pw, drools);

end

# Ideally, these two commands would be joined together into one
rule "Run instance wire from target.access to target.init, when we have a value to provide as a parameter [set] (onAccess)"
	when
		source : ContainsOperations( )
		target : Accessible( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "run" )
		
		event : EventTrigger( target.onAccess == event )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		
		not (ActionEdge( eContainer == sw, from == event, to == operation, name == "run" ))
						
		eval ( handler.veto( sw ))
		
	then
		ActionEdge rw = handler.generatedActionEdge(sw, sw, event, operation);
		handler.setName(rw, "run");
		queue.add(rw, drools);

end

rule "Run instance wire from target.access to target.init, adding ConditionEdge to check it is set [set] (onAccess)"
	when
		source : ContainsOperations( )
		target : Accessible( )
		sw : SetWire( from == source, to == target )
		
		event : EventTrigger( target.onAccess == event )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		
		run : ActionEdge( eContainer == sw, from == event, to == operation, name == "run" )
		param : ParameterEdge( from == field, to == run )
		
		# condition check
		condition : Condition ( eContainer == source, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == condition, to == run ))
					
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge cw = handler.generatedConditionEdge(sw, sw, condition, run);
		queue.add(cw, drools);
		
end	

# Ideally, these two commands would be joined together into one
rule "Connect parameter wire to: run instance wire from target.access to target.init [set]"
	when
		source : CanBeSynced( )
		target : CanBeSynced( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[sync] run instance parameter (source.access)" )
	
		event : EventTrigger( eContainer == target, name=="access" )
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[sync] run instance parameter (source.access)"); 
		queue.add(pw, drools);

end

rule "Connect parameter wire to: run instance wire from target.access to target.init [set] (onAccess)"
	when
		source : CanBeSynced( )
		target : Accessible( )
		sw : SetWire( from == source, to == target, overriddenNames not contains "[set] run instance parameter (source.access)" )
	
		event : EventTrigger( target.onAccess == event ) 
		operation : Operation( eContainer == target, name=="init" )
		field : Property( source.fieldValue == field )
		wire : ActionEdge( from == event, to == operation, name == "run", eContainer == sw )
		
		not (ParameterEdge( eContainer == sw, from == field, to == wire )) 
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw = handler.generatedParameterEdge(sw, sw, field, wire); 
		handler.setName(pw, "[set] run instance parameter (source.access)"); 
		queue.add(pw, drools);

end

/**
 * I think that chained SetWires are generally impossible. Consider:
 * 
 *   page1 <--> page2 <--> unrelated
 *   condition on both SetWires, matching (page1, page2)
 * 
 * If we allow for chaining, then the condition 
 *   condition[page2, unrelated]
 * will be copied onto
 *   condition[page1, page2]
 * which means the SetWires will never satisfy all its conditions.
 *
 * --
 *
 * I think that chained SetWires are only possible *when* each
 * SetWires has identical Conditions, so we don't have to combine
 * the two conditions together into something impossible.
 *
 * However, trying to implement this did nothing. I think it is because
 * without adding more information to the model, you cannot chain.
 * The information you'd be adding is stuff like ChainedSetWire, but
 * this defeats the purpose of having it in the model, because this should
 * be handled by the code generation instead.
 */

rule "Cascaded SetWires: Conditions from parent to child [set]"
	when

		# the containing elements	
		source : CanBeSynced( )
		target : CanBeSynced( )
		sw : SetWire ( from == source, to == target )
		
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SetWire( from == e1, to == e2 )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )

		# and there isn't one on the element sync wire
		not (ecw : ConditionEdge( from == condition, to == esw )) 
						
		eval ( handler.veto( cw ))
		
	then
		ConditionEdge ecw = handler.generatedConditionEdge( cw, sw, condition, esw );
		handler.setName(ecw, "[copied] from: " + cw.getId());
		queue.add(ecw, drools);

end

rule "Cascaded SetWires: Parameters from parent to child [set]"
	when

		# the containing elements
		source : CanBeSynced( )
		target : CanBeSynced( )
		sw : SetWire ( from == source, to == target )
		
		# the elements contained
		e1 : CanBeSynced( eContainer == source )
		e2 : CanBeSynced( eContainer == target, eval(functions.nameMatches(e1, e2)) )
		esw : SetWire( from == e1, to == e2 )
		
		# there is a condition on the containing sync wire
		condition : Condition ( )
		cw : ConditionEdge( from == condition, to == sw )
		
		# the generated condition wire
		ecw : ConditionEdge( from == condition, to == esw )
		
		# there is a parameter on the condition wire
		parameter : ParameterEdgesSource( )
		pw : ParameterEdge( from == parameter, to == cw )

		# and there isn't one on the element sync wire
		not (epw : ParameterEdge( from == parameter, to == ecw )) 
						
		eval ( handler.veto( cw ))
		
	then
		# create it
		ParameterEdge epw = handler.generatedParameterEdge( cw, sw, parameter, ecw );
		handler.setName(epw, "[copied] from: " + pw.getId());
		queue.add(epw, drools);

end

# SetWires do not connect the fields together; they can _also_
# connect the Frames together.
rule "Connect Session.init to incoming SetWires (contained in Frames) [set] (onChange 2)"
	when
		session : Session (  )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		sw : SetWire( from == sourceFrame, to == targetFrame )

		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		sw2 : SetWire ( from == sourceElement, to == targetElement, eContainer == sw, overriddenNames not contains "run" )

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect Session.init to incoming SetWires (contained in Frames) [set] (onChange 3)"
	when
		session : Session (  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		sw : SetWire( from == sourceFrame, to == targetFrame )

		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		sw2 : SetWire ( from == sourceElement, to == targetElement, eContainer == sw, overriddenNames not contains "run" )

		event : EventTrigger( sourceElement.onChange == event ) 
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )
		
		not (ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" ))
						
		eval ( handler.veto( sw2 ))
		
	then
		ActionEdge rw2 = handler.generatedActionEdge(sw2, sw2, inite, operation);
		handler.setName(rw2, "run");
		queue.add(rw2, drools);
		
end

rule "Connect parameter for Session.init to incoming SetWires (contained in Frames) [set] (onChange 2)"
	when
		session : Session (  )
		sourceFrame : VisibleThing( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		sw : SetWire( from == sourceFrame, to == targetFrame )

		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		sw2 : SetWire ( from == sourceElement, to == targetElement, eContainer == sw)

		event : EventTrigger( sourceElement.onChange == event )
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

rule "Connect parameter for Session.init to incoming SetWires (contained in Frames) [set] (onChange 3)"
	when
		session : Session (  )
		sourceFrame : Frame( eval(!functions.containingSessionEquals(sourceFrame, session)) )  
		targetFrame : ContainsOperations( eval(functions.containingSessionEquals(targetFrame, session)) )
		sw : SetWire( from == sourceFrame, to == targetFrame )

		sourceElement : Changeable( eContainer == sourceFrame )
		targetElement : ContainsOperations( eContainer == targetFrame )
		sw2 : SetWire ( from == sourceElement, to == targetElement, eContainer == sw )

		event : EventTrigger( sourceElement.onChange == event )
		operation : Operation( eContainer == targetElement, name == "update" )

		rw : ActionEdge( eContainer == sw2, from == event, to == operation, name == "run" )
		inite : EventTrigger (eContainer == session, session.onInit == inite )

		initrw : ActionEdge( eContainer == sw2, from == inite, to == operation, name == "run" )
		
		field : Property( sourceElement.fieldValue == field )
		pw : ParameterEdge( eContainer == sw2, from == field, to == rw ) 

		not( ParameterEdge( eContainer == sw2, from == field, to == initrw ))  
						
		eval ( handler.veto( sw ))
		
	then
		ParameterEdge pw2 = handler.generatedParameterEdge(sw, sw, field, initrw);
		queue.add(pw2, drools);		
end

rule "Refresh New Instance Object mappings (except for generated primary keys) when Form sets an Instance: create text fields"
	when
		form : InputForm (  )
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		sync : SetWire( from == form, to == iterator )
	
		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )
		
		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (except for generated primary keys) when Form sets an Instance: create text fields"
	when
		form : InputForm (  )
		object : DomainSchema (  )		
		sync : SetWire( from == form, to == object )
		
		attribute : DomainAttribute( eContainer == object, primaryKey == false || isGenerated == false )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		InputTextField text = handler.generatedInputTextField(sync, form);
		handler.setName(text, attribute.getName());
		queue.add(text, drools);

end

/**
 * @inference InputForm,SetWire
 *		When two {@model InputForm}s are connected by a {@model SetWire} and the
 *		source {@model InputForm} contains a {@model InputTextField}, a <em>{@model Label}</em>
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing InputTextFields"
	when
		source : InputForm (  )
		target : InputForm (  )
		sync : SetWire( from == source, to == target )
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )
		
		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When two {@model InputForm}s are connected by a {@model SetWire} and the
 *		source {@model InputForm} contains a {@model Label}, another label
 *		with the same name is created in the target {@model InputForm}.
 */
rule "Refresh mappings between InputForms connected to InputForms containing Labels"
	when
		source : InputForm (  )
		target : InputForm (  )
		sync : SetWire( from == source, to == target )
		
		sf : Label ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )
						
		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to an
 *		{@model Email}, all contained {@model InputTextField}s in the form will
 *		be copied to the Email as {@model Label}s.
 */
rule "Refresh mappings between InputForms connected to Emails containing InputTextFields"
	when
		source : InputForm (  )
		target : Email (  )
		sync : SetWire( from == source, to == target )
		
		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to an
 *		{@model Email}, all contained {@model Label}s in the form will
 *		be copied to the Email as {@model Label}s.
 */
rule "Refresh mappings between InputForms connected to Emails containing Labels"
	when
		source : InputForm (  )
		target : Email (  )
		sync : SetWire( from == source, to == target )
		
		sf : Label ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label tf = handler.generatedLabel(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end

/**
 * @inference InputForm,SetWire
 *		When an {@model InputForm} is connected by a {@model SetWire} to a
 *		{@model Map}, all contained {@model InputTextField}s in the form will
 *		be copied to the Email as {@model MapPoint}s.
 */
rule "Refresh mappings between InputForms connected to Maps containing InputTextFields"
	when
		source : InputForm (  )
		target : Map (  )
		sync : SetWire( from == source, to == target )

		sf : InputTextField ( eContainer == source )
		not ( tf : VisibleThing ( eContainer == target, eval(functions.nameMatches( sf, tf ))) )

		eval ( !target.getOverriddenNames().contains(sf.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		MapPoint tf = handler.generatedMapPoint(sync, target);
		handler.setName(tf, sf.getName());
		queue.add(tf, drools);

end


/**
 * <strong>Depending on the orientation of a SetWire</strong>,
 * SyncWires create InputTextFields; SetWires should create Labels, because they cannot
 * be edited.
 *
 * @inference SetWire,Label
 *		When a {@model DomainIterator} is connected to a {@model InputForm} by a {@model SetWire},
 *		{@model Label}s will be generated for its non-generated, non-primary key attributes.
 */
rule "Refresh New Instance Object mappings (except for generated primary keys) when Instance sets a Form: create labels"
	when
		form : InputForm (  )
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		sync : SetWire( from == iterator, to == form )	// backwards
		
		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

# TODO is this rule even used anymore? consider removing.
rule "Refresh Domain Object mappings (except for generated primary keys) when Instance sets a Form: create labels"
	when
		form : InputForm (  )
		object : DomainSchema (  )
		sync : SetWire( from == object, to == form )	// backwards

		attribute : DomainAttribute( eContainer == object, primaryKey == false || isGenerated == false )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (except for generated primary keys) when Instance sets a IteratorList: create labels"
	when
		form : IteratorList (  )
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		sync : SetWire( from == iterator, to == form )	// backwards

		originalAttribute : DomainAttribute ( primaryKey == false || isGenerated == false )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )

		// not extending ANY kind of primary key
		eval( functions.notExtendingPrimaryKey( originalAttribute ) )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new one
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		queue.add(text, drools);

end

rule "Refresh Domain Object mappings (primary keys) when Instance sets a IteratorList: create hiddens"
	when
		form : IteratorList (  )
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		sync : SetWire( from == iterator, to == form )	// backwards

		// only generated primary keys
		originalAttribute : DomainAttribute ( primaryKey == true )
		attribute : DomainAttributeInstance( eContainer == instance )
		ExtendsEdge ( from == attribute, to == originalAttribute )
		
		not ( tf : VisibleThing( eContainer == form, eval(functions.nameMatches( attribute, tf )) ) )

		eval ( !form.getOverriddenNames().contains(attribute.getName()) )
						
		eval ( handler.veto( sync ))
		
	then
		# create a new Label[visible = false]
		Label text = handler.generatedLabel(sync, form);
		handler.setName(text, attribute.getName());
		handler.setType(text, attribute.getType());
		handler.setVisible(text, false);
		queue.add(text, drools);

end

rule "A SetWire between Attributes passed to a DomainIterator need to check that the attribute exists before initialising (onAccess)"
	when
		form : VisibleThing ( )		# InputForm, IteratorList
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		
		# form -> Iterator
		sync : SetWire( from == form, to == instance )
		
		# the instance is created through a NewInstanceWire
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( from == domainSource, to == schema )
		
		selectEdge : SelectEdge ( from == iterator, to == domainSource )
		
		# contained attribute/field
		attribute : DomainAttributeInstance( eContainer == instance )
		tf : Label ( eContainer == form )

		# Label -> attribute
		sync2 : SetWire ( from == tf, to == attribute, overriddenNames not contains "check new instance exists" )
		
		# text field access/init events
		access : EventTrigger ( tf.onAccess == access ) 
		initOp : Operation ( eContainer == tf, name == "init" )
		run : ActionEdge ( from == access, to == initOp )
		
		attributeValue : Property ( attribute.fieldValue == attributeValue )
		
		param : ParameterEdge ( from == attributeValue, to == run )  
		
		# 'not empty' condition in the instance
		existsCondition : Condition ( eContainer == iterator, name == "not empty" )
		
		# but not connected		
		not (ConditionEdge ( from == existsCondition, to == run ))
						
		eval ( handler.veto( sync2 ))
		
	then
		# connect it
		ConditionEdge cw = handler.generatedConditionEdge(sync2, sync2, existsCondition, run);
		handler.setName(cw, "check new instance exists");
		queue.add(cw, drools);

end

rule "A SetWire between Attributes selected from a DomainIterator need to check that the attribute exists before initialising (onChange)"
	when
		form : VisibleThing ( )		# InputForm, IteratorList
		iterator : DomainIterator ( )
		instance : DomainInstance ( iterator.currentInstance == instance )
		
		# Iterator -> Form
		sync : SetWire( from == instance, to == form )
		
		# the instance is created through a NewInstanceWire
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		schemaEdge : SchemaEdge ( from == domainSource, to == schema )
		
		selectEdge : SelectEdge ( from == iterator, to == domainSource )
		
		# contained attribute/field
		attribute : DomainAttributeInstance( eContainer == instance )
		tf : Label ( eContainer == form )

		# Attribute -> Label
		sync2 : SetWire ( from == attribute, to == tf, overriddenNames not contains "check new instance exists" )
		
		# text field access/init events
		onChange : EventTrigger ( attribute.onChange == onChange ) 
		initOp : Operation ( eContainer == tf, name == "update" )
		run : ActionEdge ( from == onChange, to == initOp )
		
		attributeValue : Property ( attribute.fieldValue == attributeValue )
		
		param : ParameterEdge ( from == attributeValue, to == run )  
		
		# 'not empty' condition in the instance
		existsCondition : Condition ( eContainer == iterator, name == "not empty" )
		
		# but not connected		
		not (ConditionEdge ( from == existsCondition, to == run ))
						
		eval ( handler.veto( sync2 ))
		
	then
		# connect it
		ConditionEdge cw = handler.generatedConditionEdge(sync2, sync2, existsCondition, run);
		handler.setName(cw, "check new instance exists");
		queue.add(cw, drools);

end


