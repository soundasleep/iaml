«IMPORT iaml»

«EXTENSION template::GeneratorExtensions»

«DEFINE storeDbPhp FOR model::InternetApplication-»
<?php
/**
 * For storing a single value into the database (attribute id).
 */
 
require("create_database.php");	// init db if necessary
require("properties_file.php");	// properties loading code

function log_message($msg) {
	$fp = fopen("php.log", "a");
	fwrite($fp, date("Y-m-d H:i:s") . " store_db.php: $msg\n");
	fclose($fp);
}

function local_die($msg) {
	log_message("ERROR: $msg"); 
	die($msg);
}

// get the http:// url to this application
function get_baseurl() {
	return "http://" . $_SERVER["HTTP_HOST"] . dirname($_SERVER["REQUEST_URI"]);
}

/**
 * Recursive functions in PHP. See default.js for Javascript implementations of these.
 * TODO add test cases to make sure these are both identical.
 */
function store_event($page_id, $event_name, $arg0) {
	global $trace;
	// have we already called this store_event? if so, bail
	if (in_array($page_id, $trace)) {
		log_message("breaking out of possibly infinite store_event loop: $page_id");
		return;
	}
	
	/*
	 * a simple solution (but not scalable TODO): create a new HTTP request to store the event.
	 * a better solution is obiously to store the new event in this same page.
	 */	
	$url = get_baseurl() . "/store_event.php?page_id=".urlencode($page_id)."&event_name=".urlencode($event_name)."&arg0=".urlencode($arg0)."&trace=".urlencode(implode(",", $trace));
	log_message("store_db.php calling $url");
	$r = file_get_contents($url);
	if ($r != "ok")
		local_die("store_event failed: " + $r);
		
	return true;
}

function store_db($attribute_id, $arg0) {
	global $trace;
	// have we already called this store_event? if so, bail
	if (in_array($attribute_id, $trace)) {
		log_message("breaking out of possibly infinite store_db loop: $attribute_id");
		return;
	}
	
	/*
	 * a simple solution (but not scalable TODO): create a new HTTP request to store the event.
	 * a better solution is obiously to store the new event in this same page.
	 */	
	$url = get_baseurl() . "/store_db.php?attribute_id=".urlencode($attribute_id)."&arg0=".urlencode($arg0)."&trace=".urlencode(implode(",", $trace));
	log_message("store_db.php calling $url");
	$r = file_get_contents($url);
	if ($r != "ok")
		local_die("store_db failed: " + $r); 
		
	return true;
}

log_message("store_db.php? " . print_r($_GET, true));
$attribute_id = $_GET["attribute_id"] or local_die("no attribute id");
$arg0 = $_GET["arg0"] or local_die("no arg0");

// anti-infinite-loop trace tracking
$trace = isset($_GET["trace"]) ? explode(",", $_GET["trace"]) : array();
$trace[] = $attribute_id;

// find the table name
$db_type = null;
$db_name = false;
$table_name = false;
$row_name = false;
«EXPAND expandDomainStore FOREACH domainStores»

if ($db_type == "pdo") {
	if (!$db_name)
		local_die("no $db_type db found");
	if (!$table_name)
		local_die("no $db_type table found (db=$db_name)");
	if (!$row_name)
		local_die("no $db_type row found (table=$table_name)");
	
	// connect to the database source
	$db = new PDO($db_name) or local_die("could not open $db_type db '$db_name'");
	
	// does anything exist?
	$results = $db->query("SELECT * FROM $table_name") or local_die("could not look for existing values in $db_type '$table_name': " .print_r($db->errorInfo(), true));
	if ($results->fetch()) {
		// yes: update all existing
		$s = $db->prepare("UPDATE $table_name SET $row_name = ?") or local_die("could not prepare $db_type update query: " . print_r($db->errorInfo(), true));
	} else {
		// no: insert new
		$s = $db->prepare("INSERT INTO $table_name ($row_name) VALUES (?)") or local_die("could not prepare $db_type insert query: " . print_r($db->errorInfo(), true));
	}
	
	// update all existing
	$s->execute(array($arg0)) or local_die("could not execute query: " . print_r($db->errorInfo(), true));
} elseif ($db_type == "properties") {
	if (!$db_name)
		local_die("no $db_type db found");
	if (!$row_name)
		local_die("no $db_type row found (table=$table_name)");
	
	$properties = load_properties($db_name);
	$properties = set_property($db_name, $properties, $row_name, $arg0); 
	
} else {
	throw new IamlRuntimeException("Unknown domain store type: $db_type");
}

// done
$s = null;
log_message("store_db.php: adding attribute_id=$attribute_id, arg0=$arg0 into db=$db_name, table=$table_name, row=$row_name");

log_message("done");
echo "ok";

«ENDDEFINE»

/** 
 * Expand out each DomainStore.
 */
«DEFINE expandDomainStore FOR model::domain::AbstractDomainStore» 
	«EXPAND expandDomainObject(this) FOREACH children»
«ENDDEFINE»

/**
 * Expand out each DomainObject.
 */
«DEFINE expandDomainObject(model::domain::AbstractDomainStore store) FOR model::domain::AbstractDomainObject»
	«EXPAND expandDomainAttribute(store, this) FOREACH attributes»
«ENDDEFINE»

/**
 * Expand out each DomainAttribute.
 */
«DEFINE expandDomainAttribute(model::domain::AbstractDomainStore store, model::domain::AbstractDomainObject object) FOR model::domain::AbstractDomainAttribute»
	«ERROR "Cannot expand AbstractDomainAttribute " + this + " (store=" + store + ") (object=" + object + ")"»
«ENDDEFINE»

«DEFINE expandDomainAttribute(model::DomainStore store, model::DomainObject object) FOR model::DomainAttribute»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "pdo";
		$db_name = "sqlite:«safeNameString(store.id)».db";
		$table_name = "«safeNameString(object.name)»";
		$row_name = "«safeNameString(name)»";
		
		// are there any onEdit operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents FOREACH eventTriggers»
	}
«ENDDEFINE»

«DEFINE expandDomainAttribute(model::domain::FileDomainStore store, model::domain::FileDomainObject object) FOR model::domain::FileDomainAttribute»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "properties";
		$db_name = "«store.file»";
		$table_name = null;
		$row_name = "«safeNameString(name)»";
		
		// are there any onEdit operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents FOREACH eventTriggers»
	}
«ENDDEFINE»

/* ----------------------- */
/* TODO put into separate file */
 
/**
 * Expand out any event triggers.
 */
«DEFINE expandDomainAttributeEvents FOR model::EventTrigger»
	«IF name=="edit"»
		«EXPAND callOperations FOREACH outEdges»
	«ENDIF»
«ENDDEFINE»

/* default: don't know what to do with a wire */
«DEFINE callOperations FOR model::WireEdge»
	«ERROR "unknown wire edge connected to edit trigger: " + this»
«ENDDEFINE»

/* 
 * run a command with some parameters. this could be in inline JS or a JS block.
 * RunInstanceWire: event --> operation 
 */
«DEFINE callOperations FOR model::wires::RunInstanceWire-»
	«IF isInputTextField(to.eContainer)-»
		«REM»// not on current page (wire id = «id»)«ENDREM»
		store_event('«containingPage(to).id»', 'do_«operationName(to)»'
			«IF inEdges.size>0», «EXPAND callOperationParameters FOREACH inEdges SEPARATOR ", "»«ENDIF»
		);
	«ELSEIF isAbstractDomainAttribute(to.eContainer)-»
		«REM»direct field --> abstract domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF inEdges.size>0», «EXPAND callOperationParameters FOREACH inEdges SEPARATOR ", "»«ENDIF»
		);  
	«ELSEIF isSession(to.eContainer)-»
		«REM»a function run on in this session«ENDREM»
		do_«operationName(to)»(«EXPAND callOperationParameters FOREACH inEdges SEPARATOR ", "»);
	«ELSEIF isPage(to.eContainer)-»
		«REM»a function run on a page«ENDREM»
		«IF from.eContainer == to.eContainer-»
			«REM»a function run on *this* page«ENDREM»
			do_«operationName(to)»(«EXPAND callOperationParameters FOREACH inEdges SEPARATOR ", "»);
		«ELSE-»
			«ERROR "Cannot run a server-side function '" + this + "' on another page (this page = '" + from.eContainer + "', target page = '" + to.eContainer + "')"-»
		«ENDIF-»
	«ELSE-»
		local_die('unknown target operation type «to.eContainer.metaType.name» for «this»');
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperationParameters FOR model::WireEdge»
	«ERROR "unknown in edge: " + this»
«ENDDEFINE»

/* making sure that the parameter wire is from a parameter... */
«DEFINE callOperationParameters FOR model::wires::ParameterWire»
	«EXPAND callOperationParametersSource FOR from»
«ENDDEFINE»

«DEFINE callOperationParametersSource FOR model::WireEdgesSource»
	«ERROR "unknown parameter wire source: " + this»
«ENDDEFINE»

«DEFINE callOperationParametersSource FOR model::ApplicationElementProperty»
	«IF name == "fieldValue"»
		$arg0 /* the new value is already store in this variable */
	«ELSE»
		«IF containingSession(this) != null»
			/* a property from our session */
			require_session("«safeName(containingSession(this))»_«safeName()-»")
		«ELSE»
			get_application_property("«safeName()-»")
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE callOperationParametersSource FOR model::StaticValue»
	"«value-»" /* static value "«name-»" */
«ENDDEFINE»
