«IMPORT iaml»

/**
 * The flow of execution within an operation.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * TODO unresolved: How to handle multiple outExecutions within PHP and JS.
 * 
 * Option: Start new threads, though this could be challenging for Javascript, and it
 * will also introduce concurrency issues.  
 */
«DEFINE executionFlow(model::visual::Page container, Boolean php) FOR model::operations::StartNode-»
	// flow starts here
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowStep(container, php) FOR e.to-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE executionFlow(model::visual::Page container, Boolean php) FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/**
 * The individual steps within a flow.
 */
«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::ExecutionEdgeDestination-»
	«EXPAND exception FOR throwException("Unknown operation contents node: " + this)»
«ENDDEFINE»

«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::CancelNode-»
	«IF exceptionText.length > 0»
		«IF php»
		throw new IamlRuntimeException("«exceptionText»");
		«ELSE»
		throw new IamlJavascriptException("«exceptionText»");
		«ENDIF»
	«ELSE»
		// ignored cancel node "«this»"
	«ENDIF»
«ENDDEFINE»

«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::StartNode-»
	// start of operation
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowStep(container, php) FOR e.to-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::FinishNode-»
	// operation finished successfully
«ENDDEFINE»

/**
 * We implement split nodes lazily; each branch is executed in sequence.
 *
 * Each split node will continue execution as normal until it reaches a
 * JoinNode, then it will stop.
 *
 * The second part of this template will iterate down the first split
 * path until it finds a JoinNode; we define this as the end of the split,
 * and continue execution from there.
 *
 * This assumes that all splits and joins occur with the same edges, etc. 
 *
 * TODO: What about recursive split/joins? 
 * TODO: What about multi level split/joins? e.g.
 *       |-> b ->|-> f ->|
 *   a ->|-> c ->|       |-> g
 *       |-> d ----> e ->|
 */ 
# @implementation SplitNode,JoinNode Currently execution split is implemented in a single threaded way; each {@model ExecutionEdge execution flow} is executed sequentially until all flows are complete. 
«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::SplitNode-»
	/* a split node */
	«REM»
		disable function_queue until we get to the end.
		this is necessary, otherwise all split functions in
		here will call the same function_queue multiple times.
	
		one side effect of this is that any splitted "set" operations
		will only get to the first "set" operation before
		the function queue (which may be a redirect to another page)
		executes, so the other "set" operations would not complete.	
	«ENDREM»
	«IF !php»
		var function_queue_split_«safeName()» = function_queue;
		var function_queue_queued_split_«safeName()» = function_queue_queued;
		function_queue = function() { /* empty */ };
		function_queue_queued = false;
	«ENDIF»
	
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowStep(container, php) FOR e.to-»
	«ENDFOREACH»
	
	/* find the first join node, and continue code there */
	«EXPAND findJoinNode(container, php, this) FOR outExecutions.first().to»
«ENDDEFINE»

«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::JoinNode-»
	// end of split operation path; wait for join node
«ENDDEFINE»

«DEFINE findJoinNode(model::visual::Page container, Boolean php, model::operations::SplitNode split) FOR emf::EObject»
«ENDDEFINE»

«DEFINE findJoinNode(model::visual::Page container, Boolean php, model::operations::SplitNode split) FOR model::ExecutionEdgesSource»
	«EXPAND findJoinNode(container, php, split) FOR outExecutions.first().to»
«ENDDEFINE»

«DEFINE findJoinNode(model::visual::Page container, Boolean php, model::operations::SplitNode split) FOR model::operations::JoinNode»
	/* found end of join node; continue execution */
	«REM»re-enable the function queue from before the split«ENDREM»
	«IF !php»
		function_queue = function_queue_split_«safeName(split)»;
		function_queue_queued = function_queue_queued_split_«safeName(split)»;
	«ENDIF»
	
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowStep(container, php) FOR e.to-»
	«ENDFOREACH»	
«ENDDEFINE»

/* a primitive operation: carry on */
«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::PrimitiveOperation-»
	// primitive operation "«name-»"
	«EXPAND Contents::operationContents(container, php) FOR this-»
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowStep(container, php) FOR e.to-»
	«ENDFOREACH»
	
	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/* a decision operation: expandOperationContents will continue the execution flow */
«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::DecisionOperation-»
	// decision operation "«name-»"
	«EXPAND Contents::operationContents(container, php) FOR this-»

	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/* an operation call: expand for any parameters */
«DEFINE executionFlowStep(model::visual::Page container, Boolean php) FOR model::operations::OperationCallNode-»
	// virtual operation call "«name-»"

	«REM»
		if we are in javascript, and 
		if the remote operation to call is part of a DomainObject, then
		we need to call it remotely. this is because the JS might be
		out-of-date.
	«ENDREM»
	«IF !php && model::DomainObjectInstance.isInstance(outEdges.typeSelect(model::wires::RunInstanceWire).first().to.eContainer)»
		// function call_remote_event(container, operation_name, arg0, arg1, function_queue = false) {
		var old_function_queue_«safeName()» = function_queue;
		var function_queue = function(response) {
		 	if (response == "ok") {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getPassEdges() AS e-»
					«EXPAND executionFlowStep(container, php) FOR e.to-»
				«ENDFOREACH»
				old_function_queue_«safeName()»();
		 	} else {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getFailEdges() AS e-»
					«EXPAND executionFlowStep(container, php) FOR e.to-»
				«ENDFOREACH»
				old_function_queue_«safeName()»();
			}
		};
		function_queue_queued = true;
		«EXPAND OperationCall::callRemoteOperation(php, false) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire)-»
	«ELSE»
		«REM»We assume '$result' will be set as the result of this operation call.«ENDREM»
		«EXPAND OperationCall::callOperation(php, false) FOREACH outEdges.typeSelect(model::wires::RunInstanceWire)-»
		
		/* Condition flow for virtual operation '«name»' */
		if (!«IF php»$result«ELSE»result«ENDIF») {
			«REM»continue expanding following conditions (if any)«ENDREM»
			«FOREACH getFailEdges() AS e-»
				«EXPAND executionFlowStep(container, php) FOR e.to-»
			«ENDFOREACH»
		} else {
			«REM»continue expanding following conditions (if any)«ENDREM»
			«FOREACH getPassEdges() AS e-»
				«EXPAND executionFlowStep(container, php) FOR e.to-»
			«ENDFOREACH»
		}
	«ENDIF»
«ENDDEFINE»

/**
 * Continue operations chained onto the current one.
 * TODO more documentation required. When are chained conditions used?
 */
«DEFINE continueChainedOperations(Boolean php) FOR model::PrimitiveOperation-»
	«EXPAND continueChainedOperations(php) FOREACH outEdges»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Cannot continue a chained operation for " + this)»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::wires::NavigateWire»
	«IF name != "fail"»
		«IF php»
			«IF model::visual::Page.isInstance(to)»
			/* prevent infinite loops on the current page */
			if ("«((model::visual::Page) to).id»" != CURRENT_PAGE) {
			«ELSE»
			if (true) {
			«ENDIF»
				// navigate to another page
				$url = "«safeName(to)».php";
				log_message("Redirecting to '$url'");
				header("Location: $url");
				die;
			}
		«ELSE»
			// navigate to another page
			var url = "«safeName(to)».php";
			debug("Redirecting to '" + url + "'");
			window.location = url;
			ajaxIncrement();	// prevent other events from executing
		«ENDIF»
	«ELSE»
		// ignoring fail wire
	«ENDIF»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
