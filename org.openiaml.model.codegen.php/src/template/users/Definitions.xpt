«IMPORT iaml»

/**
 * Method definitions for access control handlers.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * Expand out all domain object instances.
 */
«DEFINE accessControlHandlerDefinitions(Boolean php) FOR model::scopes::Session»
	«IF php»
		«EXPAND checkAccessDefinition FOREACH elements.typeSelect(model::components::AccessControlHandler)»
	«ELSE»
		/* no client-side access control handler definitions for Session */
	«ENDIF»
«ENDDEFINE»
«DEFINE accessControlHandlerDefinitions(Boolean php) FOR model::visual::Frame»
	«IF php»
		«EXPAND checkAccessDefinition FOREACH elements.typeSelect(model::components::AccessControlHandler)»
	«ELSE»
		/* no client-side access control handler definitions for Frame */
	«ENDIF»
«ENDDEFINE»

/**
 * Definition of the access_control_permissions_check_*() method.
 * Expected to be in PHP.
 */
«DEFINE checkAccessDefinition FOR model::components::AccessControlHandler»
	/**
	 * Definition of access control handler '«name»'
	 */
	function access_control_permissions_check_«safeNameString(id)»() {
		«REM»find the desired UserInstance to check against«ENDREM»
		«REM»there should be exactly one incoming parameter wire with a UserInstance«ENDREM»
		«LET inEdges.typeSelect(model::wires::ParameterWire).from.typeSelect(model::users::UserInstance).first() AS user»
			«IF user==null»
				«EXPAND exception FOR throwException("No incoming UserInstances for AccessControlHandler " + this)»
			«ENDIF»
			«EXPAND checkAccessDefinitionUser(user) FOR this»
		«ENDLET»
	}
«ENDDEFINE»

/**
 * We now have a UserInstance on which to validate against
 */
«DEFINE checkAccessDefinitionUser(model::users::UserInstance user) FOR model::components::AccessControlHandler»
	$instance = get_object_instance_«safeName(user)»();
	if (!$instance)
		throw new IamlRuntimeException("Unexpected empty UserInstance '«user.name»'; has the user logged in?");

	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Role) AS targetRole»
		«LET user.inEdges.typeSelect(model::wires::SelectWire).from.typeSelect(model::DomainObject).first() AS initialRole»
			/* check role '«targetRole.name»' */
			if (cast_«safeName(initialRole)»_as_«safeName(targetRole)»($instance) == null) {
				// user cannot be cast as this role
				$failure['«safeName(targetRole)»'] = new IamlRuntimeException("Source role '«initialRole.name»' could not be translated into '«targetRole.name»'");
			} else {
				// can be cast fine
				$failure['«safeName(targetRole)»'] = null;
			}
		«ENDLET»
	«ENDFOREACH»
	
	/* check permissions */
	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Permission) AS targetPermission»
		/* permission '«targetPermission.name»' */
		if (
		«IF user.inEdges.typeSelect(model::wires::NewInstanceWire).isEmpty»
			«IF user.inEdges.typeSelect(model::wires::SelectWire).isEmpty»
				«EXPAND exception FOR throwException("Cannot deduce the instance type of UserInstance: " + user)»
			«ELSE»
				user_instance_«safeName(user.inEdges.typeSelect(model::wires::SelectWire).from.first())»_has_permission_«safeName(targetPermission)»
			«ENDIF»
		«ELSE»
			user_instance_«safeName(user.inEdges.typeSelect(model::wires::NewInstanceWire).from.first())»_has_permission_«safeName(targetPermission)»
		«ENDIF»
		($instance)) {
			// user has permission
			$failure['«safeName(targetPermission)»'] = null;
		} else {
			// user does not
			$failure['«safeName(targetPermission)»'] = new IamlRuntimeException("User of type '«user.name»' did not have permission '«targetPermission.name»'");
		}
	«ENDFOREACH»
	
	/* combine with any constraint wires */
	«LET outEdges.typeSelect(model::wires::RequiresWire).outEdges.typeSelect(model::wires::ConstraintWire) AS c1»
	«LET outEdges.typeSelect(model::wires::RequiresWire).inEdges.typeSelect(model::wires::ConstraintWire) AS c2»
	«LET c1.toSet().union(c2) AS constraints»
		«FOREACH constraints AS constraint»
			// constraint wire '«constraint»'
			«LET ((model::wires::RequiresWire) constraint.from).to AS constraintFrom»
			«LET ((model::wires::RequiresWire) constraint.to).to AS constraintTo»
			«IF constraint.type==model::wires::ConstraintTypes::OR»
				if ($failure['«safeName(constraintFrom)»'] == null ||
						$failure['«safeName(constraintTo)»'] == null) {
					// OR is successful
					$failure['«safeName(constraintFrom)»'] = null;
					$failure['«safeName(constraintTo)»'] = null;
				}
			«ELSEIF constraint.type==model::wires::ConstraintTypes::XOR»
				if ($failure['«safeName(constraintFrom)»'] == null xor
						$failure['«safeName(constraintTo)»'] == null) {
					// XOR is successful
					$failure['«safeName(constraintFrom)»'] = null;
					$failure['«safeName(constraintTo)»'] = null;
				}
			«ELSE»
				// ignore ANDs; this is the default 
			«ENDIF»
			«ENDLET»
			«ENDLET»
		«ENDFOREACH»
	«ENDLET»
	«ENDLET»
	«ENDLET»
	
	// for the check to be successful, there must be no 'null's left in the failures
	log_message("Access control check results: " . print_r($failure, true));
	foreach ($failure as $key => $exception) {
		if ($exception !== null) {
			throw $exception;
		}	
	}
	
	/* check is successful */
	return true;
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
