«IMPORT iaml»

/**
 * Methods for casting instances of inherited domain objects.
 */
«EXTENSION template::GeneratorExtensions»

«DEFINE allCasts FOR model::DomainObject»
	«REM»expand self cast«ENDREM»
	«EXPAND castSourceAsTarget(this) FOR this»
	
	«REM»expand all direct extends«ENDREM»
	«FOREACH inEdges.typeSelect(model::wires::ExtendsWire).from.typeSelect(model::DomainObject) AS target»
		«EXPAND castSourceAsTarget(target) FOR this»
	«ENDFOREACH»
«ENDDEFINE»

«REM»
// return an object of the accumulated data, or null if it could
// not be cast
function cast_[source]_as_[target]($instance) {
	if [source] == [target]
		return $instance;

	foreach subclass of [source]
		attribute source_key = [source].primaryKey;
		attribute target_key = subclass.attributes ( k | k extends source_key )
		$source_value = $instance[source_key];
		
		$new_instance = (select * from subclass where target_key = ?)($source_value);
		
		if ($new_instance) {
			// add $instance to $new_instance
			foreach ($attr in $instance) {
				if (isset($new_instance[$attr]))
					$new_instance[[source] '.' $attr] = $instance[$attr];
				else
					$new_instance[$attr] = $new_instance[$attr];
			}
			return cast_[subclass]_as_[target]($new_instance);
		} else {
			return null;
		}

}

«ENDREM»
«DEFINE castSourceAsTarget(model::DomainObject target) FOR model::DomainObject»
/**
 * Try to cast a '«name»' into a subclass '«target.name»'. 
 *
 * Returns an instance of '«target.name»' with all accumulated attributes of
 * '«name»' and the heirarchy of subclasses, or <b>null</b> if it
 * could not be cast.
 */
function cast_«safeName()»_as_«safeName(target)»($instance) {
	«IF this == target»
		/* same instance; return immediately */
		return $instance;
	«ELSE»
		«FOREACH inEdges.typeSelect(model::wires::ExtendsWire).from.typeSelect(model::DomainObject) AS subclass»
			«LET attributes.selectFirst(a | a.primaryKey) AS sourceKey»
				«LET subclass.attributes.select(a | !a.outEdges.typeSelect(model::wires::ExtendsWire).to.select( a | a == sourceKey ).isEmpty).first() AS targetKey»
					$source_value = $instance["«safeNameString(sourceKey.name)»"];
					
					$query = "SELECT * FROM «safeNameString(subclass.name)» WHERE
						«safeNameString(targetKey.name)» = ?";

					/* TODO refactor this into a function call */
					$args = array($source_value);
					
					log_message("Selecting instance for cast from «name» to «target.name»: '$query', args = " . print_r($args, true));

					// select database	
					«EXPAND Select::selectDatabase FOR subclass»
			
					// execute query
					$rs = $db->prepare($query) or throw_new_IamlRuntimeException("Could not prepare query '$query': " . print_r($db->errorInfo(), true));
					$rs->execute($args) or throw_new_IamlRuntimeException("Could not execute query '$query': " . print_r($db->errorInfo(), true));
					
					// get just the first result
					$row = $rs->fetch();
					if (!$row) {
						log_message("Could not find any result");
						return null;	// could not find any results to cast to
					}

					// found a result
					$new_instance = array();
					foreach ($row as $key => $value) {
						$new_instance[$key] = $value;
					}
					log_message("Found instance: " . print_r($new_instance, true));
					/* END TODO */
					 
					// add $instance to $new_instance
					foreach ($instance as $key => $value) {
						if (isset($new_instance[$key])) {
							$new_instance["«safeNameString(this.name)»." . $key] = $value;
						} else {
							$new_instance[$key] = $value;
						}
					}
					
					// continue casting call
					return cast_«safeName(subclass)»_as_«safeName(target)»($new_instance);
				«ENDLET»
			«ENDLET»
		«ENDFOREACH»
	«ENDIF»
}
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
