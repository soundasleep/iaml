«IMPORT iaml»

/**
 * Methods for accessing data from domain objects and attributes.
 * All of this code is expected to execute on the server.
 */
«EXTENSION template::GeneratorExtensions»

/* code to _save_ attributes */
«DEFINE storeDomainAttribute(Boolean php) FOR model::DomainAttributeInstance-»
	«EXPAND storeDomainAttributeDefinition(php) FOR this»

	«IF php»
		«IF isAutosaveOff(this)»
		/* for elements with 'autosave' off */
		function queue_store_domain_attribute_«safeName()»($arg0) {
			/* queue store a value into attribute id '«id»' */
			«IF containingSession(this) != null»
				$_SESSION["instance_queue_«safeName(containingSession())-»_«safeName()-»"] = $arg0;
			«ELSE»
				set_application_value("instance_queue_«safeName()-»", $arg0);
			«ENDIF»
		}
		
		function save_queued_store_domain_attribute_«safeName()»() {
			/* execute the actual save for attribute id '«id»' */
			«IF containingSession(this) != null»
				/* contained within a session */
				$arg0 = has_session("instance_queue_«safeName(containingSession())-»_«safeName()-»", false);
				if ($arg0 !== false) {
					// lets set it
					store_domain_attribute_«safeName()-»($arg0);
				}
			«ELSE»
				/* contained within a page */
				$arg0 = get_application_value("instance_queue_«safeName()-»", false);
				if ($arg0 !== false) {
					// lets set it
					store_domain_attribute_«safeName()-»($arg0);
				}
			«ENDIF»
		}
		«ENDIF»
	«ELSE»
		/* for attributes with 'autosave' set to false */
		function queue_store_domain_attribute_«safeName()»(arg0) {
			«IF containingSession() != null»
				set_session("instance_queue_«safeName(containingSession())-»_«safeNameString(id)-»", arg0);
			«ELSE»
				set_application_value("instance_queue_«safeNameString(id)-»", arg0);
			«ENDIF» 
		}
		
		function save_queued_store_domain_attribute_«safeName()»() {
			save_queued_store_domain_attribute("«safeNameString(id)-»");
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE storeDomainAttributeDefinition(Boolean php) FOR model::DomainAttributeInstance-»
	«IF php»
		function store_domain_attribute_«safeName()»($arg0) {
			/* store a value into attribute id '«id»' */
			«IF eContainer.metaType.isAssignableFrom(model::DomainObjectInstance)»
				/* contained in an object instance '«eContainer»': get it from the instance */
				store_object_instance_«safeName(eContainer)»("«safeNameString(name)-»", $arg0);
			«ELSE»
				/* not contained in an object instance; select it manually */
				«IF inEdges.typeSelect(model::wires::SelectWire).isEmpty»
					«IF inEdges.typeSelect(model::wires::NewInstanceWire).isEmpty»
					throw new IamlRuntimeException("No selection wires exist for setting attribute instance '«safeNameString(id)-»'");
					«ELSE»
						// set the current "new" object
						«EXPAND setNewDomainAttribute(inEdges.typeSelect(model::wires::NewInstanceWire).first()) FOR this»
					«ENDIF»
				«ELSE»
					$attribute_name = "«safeNameString(name)-»";
					«EXPAND evaluateSelectWireStore FOR inEdges.typeSelect(model::wires::SelectWire).first()»
				«ENDIF»
			«ENDIF»
		}
	«ELSE»
		function store_domain_attribute_«safeName()»(arg0) {
			set_domain_attribute("«safeNameString(id)-»", arg0);
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE setNewDomainAttribute(model::wires::NewInstanceWire wire) FOR model::DomainAttributeInstance-»
	// it should already be created, or this will create a new one
	$existing = get_new_attribute_instance_«safeName()-»(true);	/* force creation */

	«IF containingSession(this) != null»
		/* contained within a session */
		$new_id = has_session("new_attribute_«safeName(containingSession())»_«safeName()-»", false);
		if ($new_id === false) {
			throw new IamlRuntimeException("Unexpectedly got an empty new session attribute");
		}
	«ELSE»
		/* contained within a page */
		$new_id = get_application_value("new_attribute_«safeName()-»", false);
		if ($new_id === false) {
			throw new IamlRuntimeException("Unexpectedly got an empty new page attribute");
		}
	«ENDIF»

	$attribute_name = "«safeNameString(name)-»";
	log_message("updating existing new attribute '$new_id', attribute = '$attribute_name'");
	
	// where are we loading it from? sets $db
	«EXPAND Select::selectDatabase FOR wire.from»
		
	// create query
	$query = "UPDATE «safeNameString(((model::DomainObject) wire.from).name)»
		SET $attribute_name = ?
		WHERE «attributeName(getPrimaryKey(this))-» = ?";
	
	$args = array($arg0, $new_id);
			
	// execute query
	$rs = $db->prepare($query) or throw_new_IamlRuntimeException("Could not prepare query '$query': " . print_r($db->errorInfo(), true));
	$rs->execute($args) or throw_new_IamlRuntimeException("Could not execute query '$query': " . print_r($db->errorInfo(), true));
	log_message("attribute '$attribute_name' set to '$arg0'");
«ENDDEFINE»

«DEFINE storeDomainObject FOR model::DomainObjectInstance-»
	function store_object_instance_«safeName()»($attribute_name, $arg0) {
		/* store a value into object id '«id»' */
		«IF inEdges.typeSelect(model::wires::SelectWire).isEmpty»
			«IF inEdges.typeSelect(model::wires::NewInstanceWire).isEmpty»
				throw new IamlRuntimeException("No selection wires exist for setting object instance '«id»'");
			«ELSE»
				// set the current "new" object
				«EXPAND setNewDomainObject(inEdges.typeSelect(model::wires::NewInstanceWire).first()) FOR this»
			«ENDIF»
		«ELSE»
			«EXPAND evaluateSelectWireStore FOR inEdges.typeSelect(model::wires::SelectWire).first()»
		«ENDIF»
	}
	
	function save_queued_store_domain_object_«safeName()-»() {
		/* save a queued domain object instance */
		«EXPAND queuedDomainObjectStore FOREACH attributes»
	}
«ENDDEFINE»

«DEFINE queuedDomainObjectStore FOR model::DomainAttributeInstance»
	save_queued_store_domain_attribute_«safeNameString(id)-»(); /* attribute "«safeNameString(name)-»" */
«ENDDEFINE»

«DEFINE setNewDomainObject(model::wires::NewInstanceWire wire) FOR model::DomainObjectInstance-»
	// it should already be created, or this will create a new one
	$existing = get_new_domain_object_«safeName()-»(true);	/* force creation */
	$new_id = $existing["«attributeName(getPrimaryKey(this))-»"];
	log_message("updating existing new object '$new_id', attribute = '$attribute_name'");
	
	// where are we loading it from? sets $db
	«EXPAND Select::selectDatabase FOR wire.from»
		
	// create query
	$query = "UPDATE «safeNameString(((model::DomainObject) wire.from).name)»
		SET $attribute_name = ?
		WHERE «attributeName(getPrimaryKey(this))-» = ?";
	
	$args = array($arg0, $new_id);
			
	// execute query
	$rs = $db->prepare($query) or throw_new_IamlRuntimeException("Could not prepare query '$query': " . print_r($db->errorInfo(), true));
	$rs->execute($args) or throw_new_IamlRuntimeException("Could not execute query '$query': " . print_r($db->errorInfo(), true));
	log_message("attribute '$attribute_name' set to '$arg0'");
«ENDDEFINE»

«DEFINE evaluateSelectWireStore FOR model::wires::SelectWire»
	/* selection wire «this» (for storing values), assumes $arg0 exists */
	
	// where are we loading it from? sets $db
	«EXPAND Select::selectDatabase FOR from»
	
	// create query
	$query = "UPDATE «safeNameString(((model::DomainObject) from).name)»
		SET $attribute_name = ?
		WHERE " . «EXPAND Select::getQuery FOR this-»;
	$args = array($arg0);
	$args2 = array(«EXPAND template::operations::Parameters::callParameter(true, this, false) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ","»);
	foreach ($args2 as $k) {
		$args[] = $k;
	}
	
	// execute query
	$rs = $db->prepare($query) or throw_new_IamlRuntimeException("Could not prepare query '$query': " . print_r($db->errorInfo(), true));
	$rs->execute($args) or throw_new_IamlRuntimeException("Could not execute query '$query': " . print_r($db->errorInfo(), true));
«ENDDEFINE»

/** to find the relevant domain attribute set method */
«DEFINE findSetDomainAttributeMethod FOR model::InternetApplication» 
	«EXPAND findDomainAttribute FOREACH getAllDomainAttributeInstances()»
«ENDDEFINE»

«DEFINE findDomainAttribute FOR model::DomainAttributeInstance»
	if ($id == "«safeNameString(id)-»") {
		store_domain_attribute_«safeNameString(id)-»($arg0);
		log_message("set_application_value.php: succeeded");
		echo "ok";
		die;
	}
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
