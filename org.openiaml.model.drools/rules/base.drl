#created on: 4/11/2008
package org.openiaml.model.drools.rules.base

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create empty domain store"
	when
		a : InternetApplication ( name == "test" )
		not (DomainStore( name=="test domain store") from a.domainStores)

		eval ( handler.veto( a ))

	then 
		#actions
		// DomainStore ds = (DomainStore) handler.createElement( a, ModelPackage.eINSTANCE.getDomainStore(), ModelPackage.eINSTANCE.getInternetApplication_DomainStores() );
		// ds.setIsGenerated(true);
		// ds.setGeneratedBy(a);
		
		DomainStore ds = handler.generatedDomainStore( a, a );
		handler.setName(ds, "test domain store");
		
		queue.add(ds, drools); // possibly infer new knowledge (this is necessary)
		
end

/**
 * @inference InputTextField,Property An untyped {@model InputTextField} 
 * 		contains an untyped {@model Property property} named 'fieldValue'.
 * @inference InputTextField,Property If set, the {@model VisibleThing#fieldValue fieldValue}
 *		is used as the default value of the created {@model Property property} named 'fieldValue'.   
 */
rule "Create field value for input text field (untyped)"
	when
		f : InputTextField( type == null )
		not (Property( eContainer == f, name=="fieldValue" ))
			
		eval ( handler.veto( f ))
		
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");
		handler.setType(fieldValue, null);
		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getFieldValue() != null) {
			handler.setDefault(fieldValue, f.getFieldValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference InputTextField,Property A typed {@model InputTextField} 
 * 		contains a typed {@model Property property} named 'fieldValue'.
 */
rule "Create field value for input text field (typed)"
	when
		f : InputTextField( type != null )
		not (Property( eContainer == f, name=="fieldValue" ))
		
		eval ( handler.veto( f ))
			
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");
		handler.setType(fieldValue, f.getType());
		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getFieldValue() != null) {
			handler.setDefault(fieldValue, f.getFieldValue());
		}
		queue.add(fieldValue, drools);
		
end

/**
 * @inference Label,Property A {@model Label} 
 * 		contains a {@model Property property} named 'fieldValue'.
 */
rule "Create field value for label"
	when
		f : Label( )
		not (Property( eContainer == f, name=="fieldValue" ))
		
		eval ( handler.veto( f ))
			
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");

		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getFieldValue() != null) {
			handler.setDefault(fieldValue, f.getFieldValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference Map,Property A {@model Map} 
 * 		contains a {@model Property property} named 'fieldValue'.
 */
rule "Create field value for map"
	when
		f : Map( )
		not (Property( eContainer == f, name=="fieldValue" ))
		
		eval ( handler.veto( f ))
			
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");

		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getFieldValue() != null) {
			handler.setDefault(fieldValue, f.getFieldValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference MapPoint,Property A {@model MapPoint} 
 * 		contains a {@model Property property} named 'fieldValue'.
 */
rule "Create field value for map point"
	when
		f : MapPoint( )
		not (Property( eContainer == f, name=="fieldValue" ))
		
		eval ( handler.veto( f ))
			
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");

		// set default to fieldValue ONLY if fieldValue is set
		// (we want to get an error if we try to access an undefined variable)
		if (f.getFieldValue() != null) {
			handler.setDefault(fieldValue, f.getFieldValue());
		}
		
		queue.add(fieldValue, drools);
		
end

/**
 * @inference DomainAttribute,Property A {@model DomainAttribute} 
 *		contains a {@model Property property} named 'fieldValue'.
 */
rule "Create field value for domain attribute"
	when
		f : DomainAttribute( )
		not (Property( eContainer == f, name=="fieldValue" ))
		
		eval ( handler.veto( f ))
			
	then
		Property fieldValue = handler.generatedProperty(f, f);
		handler.setName(fieldValue, "fieldValue");
		queue.add(fieldValue, drools);
		
end

/**
 * @inference Property All {@model Property ApplicationElementProperties}
 * 		will have a {@model CompositeCondition} created called "is set".
 */
rule "ApplicationElementProperties will also have a related 'is set' condition"
	when
		container : ContainsConditions ( )
		containerGe : GeneratesElements ( eval(containerGe == container) )
		value : Property ( eContainer == container )
		
		not ( Condition( eval(name.equals(value.getName() + " is set")), eContainer == container ))
	
		eval ( handler.veto( containerGe ))
	
	then
		CompositeCondition cond = handler.generatedCompositeCondition(containerGe, container);
		handler.setName(cond, value.getName() + " is set");
		queue.add(cond, drools);

end

rule "Create contents of 'X is set' operation"
	when
		container : ContainsConditions ( )
		value : Property ( eContainer == container )
		
		o : CompositeCondition( eval(name.equals(value.getName() + " is set")), eContainer == container )
		
		not ( StartNode ( eContainer == o ))
		
		eval ( handler.veto( o ))
	
	then
		
		DecisionCondition decision = handler.generatedDecisionCondition(o, o);
		handler.setName(decision, "is set?");
		queue.add(decision, drools);
		
		StartNode start = handler.generatedStartNode(o, o);
		queue.add(start, drools);
		
		FinishNode finish = handler.generatedFinishNode(o, o);
		queue.add(finish, drools);

		CancelNode cancel = handler.generatedCancelNode(o, o);
		queue.add(cancel, drools);
		
		DataFlowEdge data1 = handler.generatedDataFlowEdge(o, o);
		handler.setFrom(data1, value);
		handler.setTo(data1, decision);
		queue.add(data1, drools);

		ExecutionEdge edge1 = handler.generatedExecutionEdge(o, o);
		handler.setFrom(edge1, start);
		handler.setTo(edge1, decision);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge2, "yes");
		handler.setFrom(edge2, decision);
		handler.setTo(edge2, finish);
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(o, o);
		handler.setName(edge3, "no");
		handler.setFrom(edge3, decision);
		handler.setTo(edge3, cancel);
		queue.add(edge3, drools);

end
