/**
 * Rules related to casting (can_cast).
 */
package org.openiaml.model.drools.rules.casting

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

/**
 * Similar to issue 210: Create PrimitiveConditions by default, but
 * allow later overriding using the same semantics if it was a CompositeCondition.
 *
 * @inference VisibleThing
 *		{@model VisibleThing}s will contain a {@model Condition} named 'can cast?'.
 */
rule "Create 'can cast?' condition for VisibleThings"
	when
		tf : VisibleThing( )
		not ( condition : Condition ( name == "can cast?", eContainer == tf ))
		
		eval ( handler.veto( tf ))
	
	then
		PrimitiveCondition condition = handler.generatedPrimitiveCondition(tf, tf);
		handler.setName(condition, "can cast?");
		queue.add(condition, drools);

end

rule "Create contents of 'can cast?' condition"
	when
		tf : VisibleThing( )
		fieldValue : Property ( tf.fieldValue == fieldValue )
		c : CompositeCondition ( name == "can cast?", eContainer == tf )
		
		not ( start : StartNode ( eContainer == c ))
		
		eval ( handler.veto( c ))
	
	then
		StartNode start = handler.generatedStartNode(c, c);		
		queue.add(start, drools);
		
		Parameter param = handler.generatedParameter(c, c);
		handler.setName(param, "value");
		queue.add(param, drools);
		
		CastNode cast = handler.generatedCastNode(c, c);
		queue.add(cast, drools);
		
		DecisionNode check = handler.generatedDecisionNode(c, c);
		handler.setName(check, "can cast?");
		queue.add(check, drools);
		
		CancelNode cancel = handler.generatedCancelNode(c, c);
		queue.add(cancel, drools);
		
		FinishNode finish = handler.generatedFinishNode(c, c);
		queue.add(finish, drools);
		
		DataFlowEdge castIn = handler.generatedDataFlowEdge(c, c, param, cast);
		queue.add(castIn, drools);

		DataFlowEdge castOut = handler.generatedDataFlowEdge(c, c, cast, fieldValue);
		queue.add(castOut, drools);

		DataFlowEdge castCheck = handler.generatedDataFlowEdge(c, c, cast, check);
		queue.add(castCheck, drools);
		
		ExecutionEdge edge1 = handler.generatedExecutionEdge(c, c, start, check);
		queue.add(edge1, drools);

		ExecutionEdge edge2 = handler.generatedExecutionEdge(c, c, check, cancel);
		handler.setName(edge2, "no");
		queue.add(edge2, drools);

		ExecutionEdge edge3 = handler.generatedExecutionEdge(c, c, check, finish);
		handler.setName(edge3, "yes");
		queue.add(edge3, drools);

end

/**
 * @inference InputTextField,SyncWire
 *		A {@model SyncWire} connecting two elements with a {@model Condition} 'can sync?'
 *		will only {@model ConditionEdge permit} synchronisation if the value can be {@model CastNode cast successfully}.
 */
rule "Add 'can cast?' condition check for onChange connecting to Update"
	when
		source : Changeable ( )
		target : ContainsOperations ( )
		
		sw : SyncWire ( (from == source && to == target) || (from == target && to == source) )
		
		fieldValue : Property ( source.fieldValue == fieldValue )		

		event : EventTrigger ( source.onChange == event )
		upd : Operation ( name == "update", eContainer == target )
		
		run : ActionEdge ( from == event, to == upd )
		
		condition : Condition ( name == "can cast?", eContainer == target )
		
		not ( ce : ConditionEdge ( from == condition, to == run )) 
		
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge ce = handler.generatedConditionEdge(sw, sw, condition, run);
		handler.setName(ce, "prevent incompatible types");
		queue.add(ce, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(sw, sw, fieldValue, ce);
		queue.add(param, drools);		
	
end

/**
 * @inference SyncWire
 *		For elements connected by a {@model SyncWire}, the 'onAccess' {@model EventTrigger} executing the 'init' {@model Operation}
 *		will {@model ConditionEdge only execute} if the source {@model Property fieldValue} can be {@model CastNode cast successfully}.  
 */
rule "Add 'can cast?' condition check for onAccess connecting to Init"
	when
		source : Accessible ( )
		target : CanBeSynced ( )
		targetc : Changeable ( this == target )
		
		sw : SyncWire ( (from == source && to == target) || (from == target && to == source) )
		
		fieldValue : Property ( targetc.fieldValue == fieldValue )		

		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		p2 : ParameterEdge ( from == fieldValue, to == run )
		
		condition : Condition ( name == "can cast?", eContainer == source )
		
		not ( ce : ConditionEdge ( from == condition, to == run )) 
		
		eval ( handler.veto( sw ))
	
	then
		ConditionEdge ce = handler.generatedConditionEdge(sw, sw, condition, run);
		handler.setName(ce, "prevent incompatible types");
		queue.add(ce, drools);
		
		ParameterEdge param = handler.generatedParameterEdge(sw, sw, fieldValue, ce);
		queue.add(param, drools);		
	
end

/**
 * @inference SyncWire
 *		For elements connected by a {@model SyncWire}, the 'onAccess' {@model EventTrigger} executing the 'init' {@model Operation}
 *		will {@model ConditionEdge only execute} if the source {@model Property fieldValue} can be {@model CastNode cast successfully}.  
 */
rule "After 'init' has been called on a typed element, call 'validate'"
	when
		source : CanBeSynced ( )
		accessible : Accessible ( )
		eval ( source == accessible )
		
		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		
		validate : Operation ( name == "validate", eContainer == source )
		
		not ( runValidate : ActionEdge ( from == event, to == validate ))
		
		eval ( handler.veto( source ))
	
	then
		ActionEdge runValidate = handler.generatedActionEdge(source, source, event, validate);
		handler.setName(runValidate, "call validate after init");
		// must be a lower priority 		
		handler.setPriority(runValidate, run.getPriority() - 10);
		queue.add(runValidate, drools);

end

/**
 * onInit->Validate() is only called if the fieldValue has been set.
 */
rule "Only call 'validate' operation onAccess if fieldValue has been set"
	when
		source : CanBeSynced ( )
		accessible : Accessible ( )
		eval ( source == accessible )
		
		event : EventTrigger ( source.onAccess == event )
		upd : Operation ( name == "init", eContainer == source )
		
		run : ActionEdge ( from == event, to == upd )
		
		validate : Operation ( name == "validate", eContainer == source )
		runValidate : ActionEdge ( from == event, to == validate )
		
		isSet : Condition ( name == "fieldValue is set", eContainer == source )
		
		not ( edge : ConditionEdge ( from == isSet, to == runValidate) )
		
		eval ( handler.veto( runValidate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(runValidate, source, isSet, runValidate);
		handler.setName(edge, "only validate if set");
		queue.add(edge, drools);

end
