«IMPORT iaml»

«EXTENSION template::GeneratorExtensions»

«DEFINE storeDbPhp FOR model::InternetApplication-»
<?php
/**
 * For storing a single value into the database (attribute id).
 */
 
«EXPAND template::Template::commonHeader("", "Store DB")»

define('REDIRECT_ON_CLIENT', true);

// include operations, condition definitions
«EXPAND template::Common::commonPHPIncludes»

log_message("store_db.php? " . print_r($_GET, true));
$attribute_id = require_get("attribute_id");
$arg0 = require_get("arg0");

// anti-infinite-loop trace tracking
add_running_function($attribute_id);

// find the table name
$db_type = null;
$db_name = false;
$table_name = false;
$row_name = false;
«EXPAND expandDomainStore FOREACH sources»
«EXPAND expandDomainObjectRoot FOREACH elements»

if ($db_type == "pdo") {
	if (!$db_name)
		throw new IamlRuntimeException("no $db_type db found");
	if (!$table_name)
		throw new IamlRuntimeException("no $db_type table found (db=$db_name)");
	if (!$row_name)
		throw new IamlRuntimeException("no $db_type row found (table=$table_name)");
	
	// connect to the database source
	$db = new PDO($db_name) or throw_new_IamlRuntimeException("could not open $db_type db '$db_name'");
	
	// does anything exist?
	$results = $db->query("SELECT * FROM $table_name") or throw_new_IamlRuntimeException("could not look for existing values in $db_type '$table_name': " .print_r($db->errorInfo(), true));
	if ($results->fetch()) {
		// yes: update all existing
		$s = $db->prepare("UPDATE $table_name SET $row_name = ?") or throw_new_IamlRuntimeException("could not prepare $db_type update query: " . print_r($db->errorInfo(), true));
	} else {
		// no: insert new
		$s = $db->prepare("INSERT INTO $table_name ($row_name) VALUES (?)") or throw_new_IamlRuntimeException("could not prepare $db_type insert query: " . print_r($db->errorInfo(), true));
	}
	
	// update all existing
	$s->execute(array($arg0)) or throw_new_IamlRuntimeException("could not execute query: " . print_r($db->errorInfo(), true));
} elseif ($db_type == "properties") {
	if (!$db_name)
		throw new IamlRuntimeException("no $db_type db found");
	if (!$row_name)
		throw new IamlRuntimeException("no $db_type row found (table=$table_name)");
	
	$properties = load_properties($db_name);
	$properties = set_property(ROOT_PATH . $db_name, $properties, $row_name, $arg0); 
	
} else {
	throw new IamlRuntimeException("Unknown domain store type: $db_type");
}

// done
$s = null;
log_message("store_db.php: adding attribute_id=$attribute_id, arg0=$arg0 into db=$db_name, table=$table_name, row=$row_name");

log_message("done");
echo "ok";
echo_necessary_update_callbacks();

«ENDDEFINE»

/** 
 * Expand out each DomainStore.
 */
«DEFINE expandDomainStore FOR model::domain::DomainSource»
	/* Domain Source «this.name» */ 
	«EXPAND expandDomainObject(this) FOREACH outSchemas.to»
«ENDDEFINE»

/**
 * Expand out each DomainObject.
 */
«DEFINE expandDomainObject(model::domain::DomainSource store) FOR model::domain::DomainSchema»
	«EXPAND expandDomainAttribute(store, this) FOREACH attributes»
«ENDDEFINE»

/**
 * Expand out each DomainAttribute.
 */
«DEFINE expandDomainAttribute(model::domain::DomainSource store, model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF isPropertiesFile(store)»
		«EXPAND expandDomainAttributeProperties(store, object) FOR this»
	«ELSE»
		«EXPAND expandDomainAttributeDatabase(store, object) FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE expandDomainAttributeDatabase(model::domain::DomainSource store, model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "pdo";
		«EXPAND template::domain::Select::selectDatabase FOR store» 
		$table_name = "«safeNameString(object.name)»";
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

«DEFINE expandDomainAttributeProperties(model::domain::DomainSource store, model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "properties";
		$db_name = "«store.file»";
		$table_name = null;
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

/**
 * Expand out each solo DomainAttribute.
 */
«DEFINE soleAttribute(model::domain::DomainSource store) FOR model::DomainAttribute»
	«IF isPropertiesFile(store)»
		«EXPAND soleAttributeProperties(store) FOR this»
	«ELSE»
		«EXPAND soleAttributeDatabase(store) FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE soleAttributeDatabase(model::domain::DomainSource store) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "pdo";
		«EXPAND template::domain::Select::selectDatabase FOR store» 
		$table_name = "single_values";
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

«DEFINE soleAttributeProperties(model::domain::DomainSource store) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "properties";
		$db_name = "«store.file»";
		$table_name = null;
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

/* if an InternetApplication directly contains an AbstractObject,
   we still process it anyway. */
«DEFINE expandDomainObjectRoot FOR model::ApplicationElement»
	«REM»empty«ENDREM»
«ENDDEFINE»

«DEFINE expandDomainObjectRoot(model::domain::DomainSource store) FOR model::domain::DomainSchema»
	«EXPAND expandDomainAttributeRoot(store, this) FOREACH attributes»
«ENDDEFINE»

«DEFINE expandDomainAttributeRoot(model::domain::DomainSource store, model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF isPropertiesFile(store)»
		«EXPAND expandDomainAttributeRootProperties(object) FOR this»
	«ELSE»
		«EXPAND expandDomainAttributeRootDatabase(store, object) FOR this»
	«ENDIF»
«ENDDEFINE»

«DEFINE expandDomainAttributeRootDatabase(model::domain::DomainSource store, model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "pdo";
		«EXPAND template::domain::Select::selectDatabase FOR store» 
		$table_name = "«safeNameString(object.name)»";
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

«DEFINE expandDomainAttributeRootProperties(model::domain::DomainSchema object) FOR model::DomainAttribute»
	«IF !{onChange}.isEmpty»
	if ($attribute_id == "«safeNameString(id)»") {
		$db_type = "properties";
		$db_name = "internet_application.properties";
		$table_name = null;
		$row_name = "«safeNameString(name)»";
		
		// are there any onChange operations for this attribute that we
		// have to then call?
		«EXPAND expandDomainAttributeEvents("edit") FOREACH {onChange}»
	}
	«ENDIF»
«ENDDEFINE»

/**
 * Expand out any event triggers.
 */
«DEFINE expandDomainAttributeEvents(String eventName) FOR model::EventTrigger»
	«IF eventName=="edit"»
		«EXPAND template::operations::OperationCall::callOperation(true, true) FOREACH outWires»
		«EXPAND template::operations::OperationCall::callOperation(true, true) FOREACH outActions.sortBy(e|-e.priority)»
	«ELSE»
		«throwException("Unknown event name '" + eventName + "'")»
	«ENDIF»
«ENDDEFINE»
