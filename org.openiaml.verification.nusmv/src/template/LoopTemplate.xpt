«IMPORT iaml»

«EXTENSION metamodel::LoopExtensions»

«DEFINE main FOR model::InternetApplication»
	«FILE "output/check.smv"»	

-- definitions for each CompositeOperation
«EXPAND operationContents FOREACH eAllContents.typeSelect(model::CompositeOperation)»

-- main module
«LET eAllContents.typeSelect(model::visual::Page) AS allPages»
«LET eAllContents.typeSelect(model::visual::Button) AS allButtons»

MODULE main

VAR
	-- possible running operations
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)» : process operation_«safeName(operation)»(run_«safeName(operation)»);
		run_«safeName(operation)» : boolean;
	«ENDFOREACH»

	current_page : {
		null 
		«FOREACH allPages AS p»
			, «safeName(p)»
		«ENDFOREACH»
	};
	
	-- all buttons on all pages
	«FOREACH allButtons AS b»
	click_«safeName(b)» : boolean;
	«ENDFOREACH»

	-- value overflow
	value_overflow : boolean;
	
	operation_running : boolean;
	operation_finished : boolean;

ASSIGN
	init(value_overflow) := 0;
	init(operation_running) := 0;
	init(operation_finished) := 0;
	
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		init(run_«safeName(operation)») := 0;
	«ENDFOREACH»

	-- current_page is chosen by nusmv
	-- click_button is chosen by nusmv
	
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		next(run_«safeName(operation)») := case
			-- already running
			run_«safeName(operation)» = 1 : case 
				-- operation finished?
				running_«safeName(operation)».finished = 1 : 0;
				
				-- still running
				1 : 1;
			esac;
		
			-- prevent additional operations from running simultaneously from user input
			«FOREACH allButtons AS b»
				«REM»button -> run[onClick] -> operation«ENDREM»
				«IF !b.outEdges.typeSelect(model::wires::RunInstanceWire).select(w|w.name == "click" || w.name == "onClick").select(w|w.to == operation).isEmpty»				
				click_«safeName(b)» = 1 : 1;
				«ENDIF»
				«REM»button -> event[onClick] -> run -> operation«ENDREM»
				«IF !b.eventTriggers.select(e|e.name == "click" || e.name == "onClick").outEdges.typeSelect(model::wires::RunInstanceWire).select(w|w.to == operation).isEmpty»				
				click_«safeName(b)» = 1 : 1;
				«ENDIF»
				«REM»TODO button -> event -> run -> operation«ENDREM»
			«ENDFOREACH»
			
			-- should not be running
			1 : 0;
		esac;
	«ENDFOREACH»
	
	next(value_overflow) := case
		«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
			running_«safeName(operation)».value_overflow = 1 : 1;
		«ENDFOREACH»
		1 : value_overflow;
	esac;

	next(operation_running) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 0;
		run_«safeName(operation)» = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;
	
	next(operation_finished) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;

FAIRNESS
  running

«ENDLET»
«ENDLET»
	
	«ENDFILE»
«ENDDEFINE»
	
«DEFINE operationContents FOR model::CompositeOperation»
«LET nodes.typeSelect(model::operations::StartNode) AS startNodes»
«LET nodes.typeSelect(model::operations::FinishNode) AS finishNodes»
«LET nodes.typeSelect(model::operations::CancelNode) AS cancelNodes»
«LET nodes.typeSelect(model::ActivityNode) AS allNodes»
«LET operations.typeSelect(model::Operation) AS allOperations»
«LET variables AS allTemporaryVariables»

-- definitions for split nodes
«FOREACH nodes.typeSelect(model::operations::SplitNode) AS split»
«FOREACH split.outExecutions.to AS splitPath»
MODULE split_«safeName(splitPath)»(flag«FOREACH variables AS v», «safeName(v)»«ENDFOREACH»)

VAR
	-- has the operation completed?
	finished : boolean;

	-- current operation step
	current_step : {
		null 
		«REM»nodes«ENDREM»
		«FOREACH allNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		«REM»operations«ENDREM»
		«FOREACH allOperations AS n»
			, «safeName(n)»
		«ENDFOREACH» 
	};
	
	-- value overflow
	value_overflow : boolean;

ASSIGN
	init(finished) := 0;
	init(current_step) := null;
	
	next(finished) := case
		-- currently running
		flag = 1 : case
			«FOREACH allNodes.typeSelect(model::operations::JoinNode) AS n»
				current_step = «safeName(n)» : 1;
			«ENDFOREACH»

			1 : finished;
		esac;
		
		-- operation isn't running
		1 : 0;
	esac;
	
	next(current_step) := case
		-- operation hasn't started yet
		current_step = null : case
			flag = 1 : «safeName(splitPath)»;
			1 : null;
		esac;
		
		-- operation is running
		«REM»we cannot yet support two layers of split/join«ENDREM»
		«FOREACH allNodes.reject(n|model::operations::SplitNode.isInstance(n)).typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		«FOREACH allOperations.typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		
		-- operation is running, but shouldn't be
		1 : null;
	esac;
	
	«FOREACH allTemporaryVariables AS v»
		next(«safeName(v)») := case
			-- is operation running?
			flag = 1 : case
			
				-- are we on a step which modifies it?
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1»;
				«ENDFOREACH»	
				
				-- otherwise, it remains the same
				1 : «safeName(v)»;
			esac;
			
			1 : 0;
		esac;
	«ENDFOREACH»
	
	-- check for value overflow
	next(value_overflow) := case
		flag = 1 : case
			«FOREACH allTemporaryVariables AS v»
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : case
						(«EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») = («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1» : 0;
						-- if they are not equal, then we have overflowed
						1 : 1;
					esac;
				«ENDFOREACH»
			«ENDFOREACH»
			1 : value_overflow;
		esac;
		
		1 : value_overflow;
	esac;
	
FAIRNESS
	running
	
«ENDFOREACH»«REM»splitPath«ENDREM»
«ENDFOREACH»«REM»SplitNode«ENDREM»

-- operation definition
MODULE operation_«safeName()»(flag)

VAR
	-- has the operation completed?
	finished : boolean;

	-- current operation step
	current_step : {
		null 
		«REM»nodes«ENDREM»
		«FOREACH allNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		«REM»operations«ENDREM»
		«FOREACH allOperations AS n»
			, «safeName(n)»
		«ENDFOREACH» 
	};
	
	-- temporary variables
	«FOREACH allTemporaryVariables AS v»
		«safeName(v)» : 0..«maximumIntegerSize()»;
	«ENDFOREACH»
	
	-- split nodes
	«FOREACH nodes.typeSelect(model::operations::SplitNode).outExecutions.to AS split»
		run_split_«safeName(split)» : boolean;
		split_«safeName(split)» : process split_«safeName(split)»(run_split_«safeName(split)»«FOREACH variables AS v», «safeName(v)»«ENDFOREACH»);
	«ENDFOREACH»
	
	-- value overflow
	value_overflow : boolean;

ASSIGN
	init(finished) := 0;
	init(current_step) := null;
	
	«FOREACH nodes.typeSelect(model::operations::SplitNode).outExecutions.to AS split»
		init(run_split_«safeName(split)») := 0;
	«ENDFOREACH»
	
	next(finished) := case
		-- currently running
		flag = 1 : case
			«FOREACH finishNodes AS n»
				current_step = «safeName(n)» : 1;
			«ENDFOREACH»
			«FOREACH cancelNodes AS n»
				current_step = «safeName(n)» : 1;
			«ENDFOREACH»

			1 : finished;
		esac;
		
		-- operation isn't running
		1 : 0;
	esac;
	
	next(current_step) := case
		-- operation hasn't started yet
		current_step = null : case
			flag = 1 : «safeName(selectStartNode())»;
			1 : null;
		esac;
		
		-- operation is running
		«FOREACH allNodes.typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		«FOREACH allOperations.typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		
		-- operation is running, but shouldn't be
		1 : null;
	esac;
	
	«FOREACH allTemporaryVariables AS v»
		next(«safeName(v)») := case
			-- is operation running?
			flag = 1 : case
			
				-- are we on a step which modifies it?
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1»;
				«ENDFOREACH»	
				
				-- otherwise, it remains the same
				1 : «safeName(v)»;
			esac;
			
			1 : 0;
		esac;
	«ENDFOREACH»
	
	«FOREACH nodes.typeSelect(model::operations::SplitNode) AS split»
		«FOREACH split.outExecutions.to AS target»
		next(run_split_«safeName(target)») := case
			current_step = «safeName(split)» : 1;
			1 : 0;
		esac;
		«ENDFOREACH»
	«ENDFOREACH»
	
	-- check for value overflow
	next(value_overflow) := case
		flag = 1 : case
			«FOREACH allTemporaryVariables AS v»
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : case
						(«EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») = («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1» : 0;
						-- if they are not equal, then we have overflowed
						1 : 1;
					esac;
				«ENDFOREACH»
			«ENDFOREACH»
			1 : value_overflow;
		esac;
		
		1 : value_overflow;
	esac;

FAIRNESS
  running

«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»

«ENDDEFINE»

«DEFINE nextStep FOR model::ExecutionEdgesSource»
	«safeName(outExecutions.to.first())»
«ENDDEFINE»

«DEFINE nextStep FOR model::operations::DecisionOperation»
	«IF name == "equal?" || name == "equals?"»
		«IF getPassFlow().to.size != 1 || getFailFlow().to.size != 1»
		«safeName(outExecutions.to.first())»
		«ELSE»
		case
			«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " = "» 
				: «safeName(getPassFlow(this).to.first())»;
				 
			1 : «safeName(getFailFlow(this).to.first())»;
		esac
		«ENDIF»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown decision operation: " + this)»
	«ENDIF»
«ENDDEFINE»

«DEFINE nextStep FOR model::operations::SplitNode»
	-- wait for all split nodes to be finished; we can then resume
	case 
		«FOREACH outExecutions.to AS split SEPARATOR " & "»
			split_«safeName(split)».finished
		«ENDFOREACH» : «safeName(outExecutions.to.first())»;
		1 : current_step;
	esac
«ENDDEFINE»

/**
 * Changes to temporary variables.
 */
«DEFINE nextTemporaryVariable FOR model::TemporaryVariable»
next(«safeName()») := case
	in_operation = 1 : case
		-- start of operations
		current_step = «safeName(eContainer)» : 0; -- init

		-- incoming flows
		«FOREACH inFlows.from.typeSelect(model::PrimitiveOperation).select(o | o.name == "set" || o.name == "setValue") AS set»
		current_step = «safeName(set)» :
			-- work out the incoming variable
			«IF set.inFlows.from.size != 1»
				«EXPAND exception FOR throwException("Too many incoming data flows for: " + this)»
			«ENDIF»
			(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
			mod «maximumIntegerSize() + 1» -- prevent integer overflow
			;
		«ENDFOREACH»

		1 : «safeName()»;
	esac;	
	
	-- otherwise, leave it as it is
	1 : «safeName()»;
esac;
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow source: " + this)»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::operations::Arithmetic»
	«IF operationType.toString() == "ADD"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " + "»
	«ELSEIF operationType.toString() == "SUBTRACT"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " - "»
	«ELSEIF operationType.toString() == "MULTIPLY"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " * "»
	«ELSEIF operationType.toString() == "DIVIDE"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " / "»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown arithmetic type: " + operationType + " for " + this)»
	«ENDIF»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::TemporaryVariable»
	«safeName(this)»
	-- another temporary variable
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::StaticValue»
	«value» 
	-- static value
«ENDDEFINE»

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540  
 */
«DEFINE exception FOR Object»
«ENDDEFINE»
