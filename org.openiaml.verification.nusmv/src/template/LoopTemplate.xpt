«IMPORT iaml»

«EXTENSION metamodel::LoopExtensions»

«DEFINE main FOR model::InternetApplication»
	«FILE "output/check.smv"»	

-- definitions for each CompositeOperation
«EXPAND operationContents FOREACH eAllContents.typeSelect(model::CompositeOperation)»

-- main module
«LET eAllContents.typeSelect(model::visual::Page) AS allPages»
«LET eAllContents.typeSelect(model::visual::Button) AS allButtons»

MODULE main

VAR
	-- possible running operations
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)» : process operation_«safeName(operation)»(run_«safeName(operation)»);
		run_«safeName(operation)» : boolean;
	«ENDFOREACH»

	current_page : {
		null 
		«FOREACH allPages AS p»
			, «safeName(p)»
		«ENDFOREACH»
	};
	
	-- all buttons on all pages
	«FOREACH allButtons AS b»
	click_«safeName(b)» : boolean;
	«ENDFOREACH»

	-- value overflow
	value_overflow : boolean;
	
	operation_running : boolean;
	operation_finished : boolean;

ASSIGN
	init(value_overflow) := 0;
	init(operation_running) := 0;
	init(operation_finished) := 0;
	
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		init(run_«safeName(operation)») := 0;
	«ENDFOREACH»

	-- current_page is chosen by nusmv
	-- click_button is chosen by nusmv
	
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		next(run_«safeName(operation)») := case
			-- already running
			run_«safeName(operation)» = 1 : case 
				-- operation finished?
				running_«safeName(operation)».finished = 1 : 0;
				
				-- still running
				1 : 1;
			esac;
		
			-- prevent additional operations from running simultaneously from user input
			«FOREACH allButtons AS b»
				«REM»button -> run -> operation«ENDREM»
				«IF !b.outEdges.typeSelect(model::wires::RunInstanceWire).select(w|w.name == "click" || w.name == "onClick").select(w|w.to == operation).isEmpty»				
				click_«safeName(b)» = 1 : 1;
				«ENDIF»
				«REM»TODO button -> event -> run -> operation«ENDREM»
			«ENDFOREACH»
			
			-- should not be running
			1 : 0;
		esac;
	«ENDFOREACH»
	
	next(value_overflow) := case
		«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
			running_«safeName(operation)».value_overflow = 1 : 1;
		«ENDFOREACH»
		1 : value_overflow;
	esac;

	next(operation_running) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 0;
		run_«safeName(operation)» = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;
	
	next(operation_finished) := case
	«FOREACH eAllContents.typeSelect(model::CompositeOperation) AS operation»
		running_«safeName(operation)».finished = 1 : 1;
	«ENDFOREACH»
		1 : 0;
	esac;

FAIRNESS
  running

«ENDLET»
«ENDLET»
	
	«ENDFILE»
«ENDDEFINE»
	
«DEFINE operationContents FOR model::CompositeOperation»
MODULE operation_«safeName()»(flag)

«LET eAllContents.typeSelect(model::operations::StartNode) AS startNodes»
«LET eAllContents.typeSelect(model::operations::FinishNode) AS finishNodes»
«LET eAllContents.typeSelect(model::operations::CancelNode) AS cancelNodes»
«LET eAllContents.typeSelect(model::ActivityNode) AS allNodes»
«LET eAllContents.typeSelect(model::Operation) AS allOperations»
«LET eAllContents.typeSelect(model::TemporaryVariable) AS allTemporaryVariables»

VAR
	-- has the operation completed?
	finished : boolean;

	-- current operation step
	current_step : {
		null 
		«REM»nodes«ENDREM»
		«FOREACH allNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		«REM»operations«ENDREM»
		«FOREACH allOperations AS n»
			, «safeName(n)»
		«ENDFOREACH» 
	};
	
	-- temporary variables
	«FOREACH allTemporaryVariables AS v»
		«safeName(v)» : 0..«maximumIntegerSize()»;
	«ENDFOREACH»
	
	-- value overflow
	value_overflow : boolean;

ASSIGN
	init(finished) := 0;
	init(current_step) := null;
	
	next(finished) := case
		-- currently running
		flag = 1 : case
			«FOREACH finishNodes AS n»
				current_step = «safeName(n)» : 1;
			«ENDFOREACH»
			«FOREACH cancelNodes AS n»
				current_step = «safeName(n)» : 1;
			«ENDFOREACH»

			1 : finished;
		esac;
		
		-- operation isn't running
		1 : 0;
	esac;
	
	next(current_step) := case
		-- operation hasn't started yet
		current_step = null : case
			flag = 1 : «safeName(selectStartNode())»;
			1 : null;
		esac;
		
		-- operation is running
		«FOREACH allNodes.typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		«FOREACH allOperations.typeSelect(model::ExecutionEdgesSource).select(n|!n.outExecutions.to.isEmpty) AS n»
			current_step = «safeName(n)» :
				«EXPAND nextStep FOR n»;
		«ENDFOREACH»
		
		-- operation is running, but shouldn't be
		1 : null;
	esac;
	
	«FOREACH allTemporaryVariables AS v»
		next(«safeName(v)») := case
			-- is operation running?
			flag = 1 : case
			
				-- are we on a step which modifies it?
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1»;
				«ENDFOREACH»	
				
				-- otherwise, it remains the same
				1 : «safeName(v)»;
			esac;
			
			1 : 0;
		esac;
	«ENDFOREACH»
	
	-- check for value overflow
	next(value_overflow) := case
		flag = 1 : case
			«FOREACH allTemporaryVariables AS v»
				«FOREACH allOperations.typeSelect(model::PrimitiveOperation).select(n|n.name == "set" || n.name == "setValue")
						.select(n|n.outFlows.to.contains(v)) AS n»
					current_step = «safeName(n)» : case
						(«EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») = («EXPAND getTemporaryVariableValue FOR n.inFlows.from.first()») mod «maximumIntegerSize() + 1» : 0;
						-- if they are not equal, then we have overflowed
						1 : 1;
					esac;
				«ENDFOREACH»
			«ENDFOREACH»
			1 : value_overflow;
		esac;
		
		1 : value_overflow;
	esac;

FAIRNESS
  running

«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»

«ENDDEFINE»

«DEFINE nextStep FOR model::ExecutionEdgesSource»
	«safeName(outExecutions.to.first())»
«ENDDEFINE»

«DEFINE nextStep FOR model::operations::DecisionOperation»
	«IF name == "equal?" || name == "equals?"»
		«IF getPassFlow().to.size != 1 || getFailFlow().to.size != 1»
		«safeName(outExecutions.to.first())»
		«ELSE»
		case
			«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " = "» 
				: «safeName(getPassFlow(this).to.first())»;
				 
			1 : «safeName(getFailFlow(this).to.first())»;
		esac
		«ENDIF»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown decision operation: " + this)»
	«ENDIF»
«ENDDEFINE»

/**
 * Changes to temporary variables.
 */
«DEFINE nextTemporaryVariable FOR model::TemporaryVariable»
next(«safeName()») := case
	in_operation = 1 : case
		-- start of operations
		current_step = «safeName(eContainer)» : 0; -- init

		-- incoming flows
		«FOREACH inFlows.from.typeSelect(model::PrimitiveOperation).select(o | o.name == "set" || o.name == "setValue") AS set»
		current_step = «safeName(set)» :
			-- work out the incoming variable
			«IF set.inFlows.from.size != 1»
				«EXPAND exception FOR throwException("Too many incoming data flows for: " + this)»
			«ENDIF»
			(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
			mod «maximumIntegerSize() + 1» -- prevent integer overflow
			;
		«ENDFOREACH»

		1 : «safeName()»;
	esac;	
	
	-- otherwise, leave it as it is
	1 : «safeName()»;
esac;
«ENDDEFINE»

«DEFINE valueOverflowChecks FOR model::TemporaryVariable»
	in_operation = 1 : case
		-- start of operations
		current_step = «safeName(eContainer)» : value_overflow; -- init

		-- incoming flows
		«FOREACH inFlows.from.typeSelect(model::PrimitiveOperation).select(o | o.name == "set" || o.name == "setValue") AS set»
		current_step = «safeName(set)» :
			-- work out the incoming variable
			«IF set.inFlows.from.size != 1»
				«EXPAND exception FOR throwException("Too many incoming data flows for: " + this)»
			«ENDIF»
			«REM»emulation of a ? b : c«ENDREM»
			case 
				-- if (a) = (a mod limit) then we have not overflown
				(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
				=
				(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
				mod «maximumIntegerSize() + 1» : value_overflow;
				-- otherwise, we have
				1 : 1;
			esac;
		«ENDFOREACH»

		1 : value_overflow;
	esac;	
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow source: " + this)»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::operations::Arithmetic»
	«IF operationType.toString() == "ADD"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " + "»
	«ELSEIF operationType.toString() == "SUBTRACT"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " - "»
	«ELSEIF operationType.toString() == "MULTIPLY"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " * "»
	«ELSEIF operationType.toString() == "DIVIDE"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " / "»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown arithmetic type: " + operationType + " for " + this)»
	«ENDIF»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::TemporaryVariable»
	«safeName(this)»
	-- another temporary variable
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::StaticValue»
	«value» 
	-- static value
«ENDDEFINE»

/**
 * Steps between operation nodes.
 */
«DEFINE operationStep(boolean lookingForEnd) FOR emf::EObject»
	«EXPAND exception FOR throwException("Unexpected operation step: " + this)»
«ENDDEFINE»
«DEFINE operationStep(boolean lookingForEnd) FOR model::ActivityNode»
	current_step = «safeName()» : «EXPAND nextOperationStep(lookingForEnd) FOR this»;
«ENDDEFINE»
«DEFINE operationStep(boolean lookingForEnd) FOR model::Operation»
	current_step = «safeName()» : «EXPAND nextOperationStep(lookingForEnd) FOR this»;
«ENDDEFINE»

/**
 * lookingForEnd = true:
 *  if (finishNode or cancelNode) [id of node];
 *  else [null];
 * lookingForEnd = false:
 *  [id of node];
 */
«DEFINE stepOrEnd(boolean lookingForEnd) FOR model::ExecutionEdgeDestination»
	«IF lookingForEnd»
		«IF model::operations::CancelNode.isInstance(this) ||
			model::operations::FinishNode.isInstance(this)»
			«safeName()»
		«ELSE»
			null
		«ENDIF»
	«ELSE»
		«safeName()»
	«ENDIF»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::ActivityNode»
	«EXPAND exception FOR throwException("Cannot expand generic activity node: " + this)»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::Operation»
	«EXPAND exception FOR throwException("Cannot expand generic operation: " + this)»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::StartNode»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::FinishNode»
	null
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::CancelNode»
	null
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::Arithmetic»
	null -- should never be called
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::PrimitiveOperation»
	«REM»TODO can a primitive operation have multiple outgoing edges?«ENDREM»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::CompositeOperation»
	«REM»TODO can a primitive operation have multiple outgoing edges?«ENDREM»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::DecisionOperation»
	«IF name=="equal" || name=="equal?"»
		«IF getPassFlow().isEmpty || getFailFlow().isEmpty || inFlows.size < 2»
		-- there are no different pass/fail conditions
			
			«IF outExecutions.size > 0»
				«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
			«ELSE»
			null -- goes nowhere
			«ENDIF»
		
		«ELSEIF inFlows.size > 2»
			«EXPAND exception FOR throwException("Too many inflows for decision operation: " + inFlows.size + " : " + this)»
		«ELSE»
		case
			«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " = "»
				: «EXPAND stepOrEnd(lookingForEnd) FOR getPassFlow().first().to»;
			1 : «EXPAND stepOrEnd(lookingForEnd) FOR getFailFlow().first().to»;
		esac
		«ENDIF»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown decision operation: " + this)»
	«ENDIF»
«ENDDEFINE»

/**
 * We are in a page, and we have clicked a button
 */
«DEFINE stepPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND stepPageButton FOREACH allButtonsOnPage(this)»
		1 : null;
	esac;
«ENDDEFINE»

«DEFINE stepPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			«safeName(((model::CompositeOperation) outRun.first().to).nodes.typeSelect(model::operations::StartNode).first())»
		«ENDLET» ;
«ENDDEFINE»

/**
 * Getting out of in_operation
 */
«DEFINE inOperationEnd FOR model::operations::FinishNode»
		current_step = «safeName()» : 0;
«ENDDEFINE»
«DEFINE inOperationEnd FOR model::operations::CancelNode»
		current_step = «safeName()» : 0;
«ENDDEFINE»

/**
 * Getting into in_operation
 */
«DEFINE inOperationPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND inOperationPageButton FOREACH allButtonsOnPage(this)»
		1 : 0;
	esac;
«ENDDEFINE»

«DEFINE inOperationPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			1
		«ENDLET» ;
«ENDDEFINE»

/**
 * Starting an operation by clicking a button
 */
«DEFINE operationStartPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND operationStartPageButton FOREACH allButtonsOnPage(this)»
		1 : null;
	esac;
«ENDDEFINE»

«DEFINE operationStartPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			«safeName(((model::CompositeOperation) outRun.first().to).nodes.typeSelect(model::operations::StartNode).first())»
		«ENDLET» ;
«ENDDEFINE»

/**
 * Ending an operation by getting to the end
 */
«DEFINE operationEnd FOR emf::EObject»
		current_step = «safeName()» : null; -- no way to finish from nameless node
«ENDDEFINE»
«DEFINE operationEnd FOR model::ExecutionEdgesSource»
	«EXPAND operationStep(true) FOR this»
«ENDDEFINE»

/**
 * Prevent random switching out of current_page
 * TODO make it so we can navigate without having to click buttons, etc
 */
«DEFINE keepCurrentPage FOR model::visual::Page»
	current_page = «safeName()» : «safeName()»;
«ENDDEFINE»

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540  
 */
«DEFINE exception FOR Object»
«ENDDEFINE»
