
  /**
   * Exgtend refreshSemanticChildren to handle shortcuts too.
   * 
   * @generated NOT
   * @return
   */
  protected final List myRefreshSemanticChildren() {
    
    // Don't try to refresh children if the semantic element
    // cannot be resolved.
    if (resolveSemanticElement() == null) {
      return Collections.EMPTY_LIST;    
    }
    
    //
    // current views
    List viewChildren = getViewChildren();
    List semanticChildren = new ArrayList(getSemanticChildrenList());
    List shortcutChildren = new ArrayList(getShortcutChildrenList());
    
    List allChildren = new ArrayList();
    allChildren.addAll(semanticChildren);
    allChildren.addAll(shortcutChildren);

    // this method changes [allChildren] by removing elements within it
    // i.e. it removes any views in the list that are already in the view
    List orphaned = cleanCanonicalSemanticChildren(viewChildren, allChildren);
    boolean changed = false;
    //
    // delete all the remaining oprphaned views
    if ( !orphaned.isEmpty() ) {
      changed = deleteViews(orphaned.iterator());
    }
    
    // so, we need to only select elements within the semanticChildren that are
    // also inside allChildren
    List newSemanticChildren = new ArrayList();
    for (Object o : semanticChildren) {
      if (allChildren.contains(o)) {
        newSemanticChildren.add(o);
      }
    }
    List newShortcutChildren = new ArrayList();
    for (Object o : shortcutChildren) {
      if (allChildren.contains(o)) {
        newShortcutChildren.add(o);
      }
    }
    
    //
    // create a view for each remaining semantic element.
    List createdViews = Collections.EMPTY_LIST;
    if ( !newSemanticChildren.isEmpty() ) {
      createdViews = createViews( newSemanticChildren );
      
      for ( int i = 0; i < createdViews.size(); i++ ) {
        View createdView = (View)((IAdaptable)createdViews.get(i)).getAdapter(View.class);
        if (createdView == null) {
          String eMsg =
            NLS
            .bind(
              DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_,
              newSemanticChildren.get(i));
          IllegalStateException ise =
            new IllegalStateException(eMsg);
          Log.error(
            DiagramUIPlugin.getInstance(),
            IStatus.ERROR,
            eMsg,
            ise);
          throw ise;
        }
      }
    }
    
    if ( !newShortcutChildren.isEmpty() ) {
      createdViews = createShortcutViews( newShortcutChildren );
      
      for ( int i = 0; i < createdViews.size(); i++ ) {
        View createdView = (View)((IAdaptable)createdViews.get(i)).getAdapter(View.class);
        if (createdView == null) {
          String eMsg =
            NLS
            .bind(
              DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_ + " [shortcut children]",
              newShortcutChildren.get(i));
          IllegalStateException ise =
            new IllegalStateException(eMsg);
          Log.error(
            DiagramUIPlugin.getInstance(),
            IStatus.ERROR,
            eMsg,
            ise);
          throw ise;
        }
      }
    }
    
    if (changed || createdViews.size() > 0)
      postProcessRefreshSemantic(createdViews);
    

    return createdViews;
  }

  /**
   * my own method
   * @generated NOT
   */
  protected List getShortcutChildrenList() {
    View viewObject = (View) getHost().getModel();
    List result = new LinkedList();
    for (Iterator it = IamlDiagramUpdater
        .getVisibleThing_79ShortcutChildren(viewObject).iterator(); it
        .hasNext();) {
      result.add(((IamlNodeDescriptor) it.next()).getModelElement());
    }
    return result;
  }
  
  /**
   * Creates a <code>View</code> element for each of the supplied semantic elements.
   * @param eObjects list of semantic element
   * @return a list of {@link IAdaptable} that adapt to {@link View}.
   * @generated NOT
   */
  protected final List createShortcutViews(List eObjects) {
    List descriptors = new ArrayList();
    Iterator elements = eObjects.iterator();
    while( elements.hasNext() ) {
      EObject element = (EObject)elements.next();
      if ( element != null ) {
        CreateViewRequest.ViewDescriptor descriptor = getViewDescriptor(element);
        descriptors.add(descriptor);
      }
    }
    
    if ( !descriptors.isEmpty() ) {
      //
      // create the request
      CreateViewRequest request = getCreateViewRequest(descriptors);
      
      //
      // get the command and execute it.
      Command cmd = getCreateViewShortcutsCommand(request, descriptors, host());
      if ( cmd != null && cmd.canExecute() ) {
        SetViewMutabilityCommand.makeMutable(new EObjectAdapter(host().getNotationView())).execute();
        executeCommand(cmd);
        List adapters = (List)request.getNewObject();
        return adapters;
      }
    }
    return Collections.EMPTY_LIST;
  }
      
  /**
   * my own method; add a shortcut command to the end of the normal create view command
   * @generated NOT
   */
  protected Command getCreateViewShortcutsCommand(CreateRequest request, List<CreateViewRequest.ViewDescriptor> descriptors, IGraphicalEditPart host) {
        Command command = getCreateViewCommand(request);
        
        if (command != null) {
      command = command.chain(new ICommandProxy(new CreateShortcutDecorationsCommand(
          // I doubt any of this works ;)
          host.getEditingDomain(), host.getPrimaryView(), descriptors, VisibleThingEditPart.MODEL_ID)));

        }
        
        return command;
  }
  
  public class CreateShortcutDecorationsCommand extends
  AbstractTransactionalCommand {

private List<CreateViewRequest.ViewDescriptor> myDescriptors;
private String modelId;

/**
 * @param modelEditPart the ID to use for the annotation, e.g. PageEditPart.MODEL_ID
 */
public CreateShortcutDecorationsCommand(
    TransactionalEditingDomain editingDomain, View parentView,
    List<CreateViewRequest.ViewDescriptor> viewDescriptors,
    String modelId) {
  super(editingDomain, "Create Shortcuts", getWorkspaceFiles(parentView)); //$NON-NLS-1$
  myDescriptors = viewDescriptors;
  this.modelId = modelId;
  
}

/**
 * @param modelEditPart the ID to use for the annotation, e.g. PageEditPart.MODEL_ID
 */
public CreateShortcutDecorationsCommand(
    TransactionalEditingDomain editingDomain, View parentView,
    CreateViewRequest.ViewDescriptor viewDescriptor,
    String modelId) {
  this(editingDomain, parentView, Collections
      .singletonList(viewDescriptor), modelId);
}

protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
    IAdaptable info) throws ExecutionException {
  for (CreateViewRequest.ViewDescriptor nextDescriptor : myDescriptors) {
    View view = (View) nextDescriptor.getAdapter(View.class);
    if (view != null && view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
      EAnnotation shortcutAnnotation = EcoreFactory.eINSTANCE
          .createEAnnotation();
      shortcutAnnotation.setSource("Shortcut"); //$NON-NLS-1$
      shortcutAnnotation.getDetails().put(
          "modelID", modelId); //$NON-NLS-1$
      view.getEAnnotations().add(shortcutAnnotation);
    }
  }
  return CommandResult.newOKCommandResult();
}
}


  /**
   * @generated
   */
  private Diagram getDiagram() {
    return ((View) getHost().getModel()).getDiagram();
  }

  /**
   * Changed by Jevon
   * @generated NOT
   */
  @SuppressWarnings("unchecked")
  private Collection refreshConnections() {
    Map domain2NotationMap = new HashMap();
    Collection linkDescriptors = collectAllLinks(getDiagram(),
        domain2NotationMap);
    Collection existingLinks = new LinkedList(getDiagram().getEdges());
    for (Iterator linksIterator = existingLinks.iterator(); linksIterator
        .hasNext();) {
      // Jevon change
      boolean linksIteratorRemoved = false;
      Edge nextDiagramLink = (Edge) linksIterator.next();
      int diagramLinkVisualID = IamlVisualIDRegistry
          .getVisualID(nextDiagramLink);
      if (diagramLinkVisualID == -1) {
        if (nextDiagramLink.getSource() != null
            && nextDiagramLink.getTarget() != null) {
          // Jevon change
          if (!linksIteratorRemoved) {
            linksIterator.remove();
            linksIteratorRemoved = true;
          }
        }
        continue;
      }
      EObject diagramLinkObject = nextDiagramLink.getElement();
      EObject diagramLinkSrc = nextDiagramLink.getSource().getElement();
      EObject diagramLinkDst = nextDiagramLink.getTarget().getElement();
      for (Iterator LinkDescriptorsIterator = linkDescriptors.iterator(); LinkDescriptorsIterator
          .hasNext();) {
        IamlLinkDescriptor nextLinkDescriptor = (IamlLinkDescriptor) LinkDescriptorsIterator
            .next();
        if (diagramLinkObject == nextLinkDescriptor.getModelElement()
            && diagramLinkSrc == nextLinkDescriptor.getSource()
            && diagramLinkDst == nextLinkDescriptor
                .getDestination()
            && diagramLinkVisualID == nextLinkDescriptor
                .getVisualID()) {
          // Jevon change 
          if (!linksIteratorRemoved) {
            linksIterator.remove();
            linksIteratorRemoved = true;
          }
          LinkDescriptorsIterator.remove();
        }
      }
    }
    deleteViews(existingLinks.iterator());
    return createConnections(linkDescriptors, domain2NotationMap);
  }