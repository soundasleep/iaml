package org.openiaml.model.model.diagram.visual.edit.policies;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.common.util.UniqueEList;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.commands.DeferredLayoutCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.SetViewMutabilityCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.INodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalConnectionEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewRequest.ConnectionViewDescriptor;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ui.PlatformUI;
import org.openiaml.model.model.ModelPackage;
import org.openiaml.model.model.WireEdge;
import org.openiaml.model.model.diagram.visual.edit.parts.ApplicationElementPropertyEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.ButtonEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.ChainedOperationEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.CommitWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.CompositeConditionEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.CompositeOperationEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.ConditionWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.DomainAttributeEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.DomainAttributeInstanceEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.DomainObjectEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.DomainObjectInstanceEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.EventTriggerEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.InputFormEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.InputTextFieldEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.LoginHandlerEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.NavigateWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.NewInstanceWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.PageEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.ParameterWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.RunInstanceWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.SelectWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.SessionEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.SetWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.ShowWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.SingleOperationEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.StaticValueEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.SyncWireEditPart;
import org.openiaml.model.model.diagram.visual.edit.parts.VisibleThingEditPart;
import org.openiaml.model.model.diagram.visual.part.IamlDiagramUpdater;
import org.openiaml.model.model.diagram.visual.part.IamlLinkDescriptor;
import org.openiaml.model.model.diagram.visual.part.IamlNodeDescriptor;
import org.openiaml.model.model.diagram.visual.part.IamlVisualIDRegistry;
import org.openiaml.model.model.diagram.visual.providers.IamlElementTypes;

/**
 * @generated
 */
public class VisibleThingCanonicalEditPolicy extends
    CanonicalConnectionEditPolicy {

  /**
   * @generated
   */
  Set myFeaturesToSynchronize;

  /**
   * @generated
   */
  protected List getSemanticChildrenList() {
    View viewObject = (View) getHost().getModel();
    List result = new LinkedList();
    for (Iterator it = IamlDiagramUpdater
        .getVisibleThing_79SemanticChildren(viewObject).iterator(); it
        .hasNext();) {
      result.add(((IamlNodeDescriptor) it.next()).getModelElement());
    }
    return result;
  }

  /**
   * Connections that are getting created are being removed for some reason. I override this
   * method so no views (connections) should ever be removed...
   * 
   * I've changed this again, now we want it to delete all views, because my new method "should"
   * always select only duplicates and orphan edges to delete.
   * 
   * @generated NOT
   */
  protected boolean shouldDeleteView(View view) {
    // return false;
    return true;
  }

  /**
   * @generated
   */
  protected boolean isOrphaned(Collection semanticChildren, final View view) {
    if (view.getEAnnotation("Shortcut") != null) {//$NON-NLS-1$
      return IamlDiagramUpdater.isShortcutOrphaned(view);
    }
    int visualID = IamlVisualIDRegistry.getVisualID(view);
    switch (visualID) {
    case EventTriggerEditPart.VISUAL_ID:
    case SingleOperationEditPart.VISUAL_ID:
    case CompositeOperationEditPart.VISUAL_ID:
    case ChainedOperationEditPart.VISUAL_ID:
    case DomainObjectEditPart.VISUAL_ID:
    case DomainAttributeEditPart.VISUAL_ID:
    case ApplicationElementPropertyEditPart.VISUAL_ID:
    case PageEditPart.VISUAL_ID:
    case InputFormEditPart.VISUAL_ID:
    case InputTextFieldEditPart.VISUAL_ID:
    case StaticValueEditPart.VISUAL_ID:
    case SessionEditPart.VISUAL_ID:
    case LoginHandlerEditPart.VISUAL_ID:
    case CompositeConditionEditPart.VISUAL_ID:
    case DomainObjectInstanceEditPart.VISUAL_ID:
    case DomainAttributeInstanceEditPart.VISUAL_ID:
    case ButtonEditPart.VISUAL_ID:
      return !semanticChildren.contains(view.getElement())
          || visualID != IamlVisualIDRegistry.getNodeVisualID(
              (View) getHost().getModel(), view.getElement());
    }
    return false;
  }

  /**
   * @generated
   */
  protected String getDefaultFactoryHint() {
    return null;
  }

  /**
   * @generated
   */
  protected Set getFeaturesToSynchronize() {
    if (myFeaturesToSynchronize == null) {
      myFeaturesToSynchronize = new HashSet();
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getContainsEventTriggers_EventTriggers());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getContainsOperations_Operations());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getApplicationElementContainer_Children());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getApplicationElement_Properties());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getApplicationElement_Values());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getVisibleThing_Sessions());
      myFeaturesToSynchronize.add(ModelPackage.eINSTANCE
          .getContainsConditions_Conditions());
    }
    return myFeaturesToSynchronize;
  }

  /**
   * Get a list of all EObjects in the current diagram that need to be made
   * into Edges. In particular this will go outside simply direct containment.
   * 
   * @generated NOT
   */
  protected List getSemanticConnectionsList() {

    View viewObject = (View) getHost().getModel();
    List result = new LinkedList();
    for (Iterator it = IamlDiagramUpdater
        .getAllChildrenEdges(viewObject).iterator(); it
        .hasNext();) {
      result.add(((EObject) it.next()));
    }
    return result;
  }

  /**
   * We need to override this method to get the correct EObject.
   * 
   * @generated NOT
   */
  protected EObject getSourceElement(EObject relationship) {
    if (relationship instanceof WireEdge) {
      return ((WireEdge) relationship).getFrom();
    }
    return null;
  }

  /**
   * We need to override this method to get the correct EObject.
   * 
   * @generated NOT
   */
  protected EObject getTargetElement(EObject relationship) {
    if (relationship instanceof WireEdge) {
      return ((WireEdge) relationship).getTo();
    }
    return null;
  }
  
  /**
   * We add additional logic to findEditPartForElement. The original method would dive straight
   * into the ancestor of the view, even though in this case, host() returns the container of the
   * actual EditPart we might be looking for.
   * Otherwise it asks the parent method for the right result.
   * 
   * @return an editpart; <tt>null</tt> if non could be found.
   * @generated NOT
   */
  protected EditPart findEditPartForElement(EObject element, EObject context, List parts) {
    DiagramEditPart host = (DiagramEditPart) getHost();
    for (Object ep : host.getConnections()) {
      ConnectionEditPart cep = (ConnectionEditPart) ep;
      if (element.equals(cep.resolveSemanticElement())) {
        // we found the edit part already
        return cep;
      }
    }

    // otherwise, consult the parent
    return super.findEditPartForElement(element, context, parts);
  }
  
  /**
   * If we are trying to create a connection to an Edge, this method will return false, because
   * the edge.getParent() = the root diagram window, not the XXXEditPart that we're actually
   * after.
   * 
   * So, we add some special logic to an otherwise direct copy, to assume we _can_ create
   * connections between ConnectionEditParts, even if they don't have a CanonicalEditPolicy.
   * 
   * @see CanonicalConnectionEditPolicy#canCreateConnection(EditPart, EditPart)
   * @generated NOT
   */
  protected boolean canCreateConnection(EditPart sep, EditPart tep,
      EObject connection) {
    if (sep != null && sep.isActive() && tep != null && tep.isActive()) {

      View src = (View) sep.getAdapter(View.class);
      View tgt = (View) tep.getAdapter(View.class);
      if (src != null && tgt != null) {

        return ((sep instanceof ConnectionEditPart) || sep.getParent().getEditPolicy(
          EditPolicyRoles.CANONICAL_ROLE) != null)
          && ((tep instanceof ConnectionEditPart) || tep.getParent().getEditPolicy(
            EditPolicyRoles.CANONICAL_ROLE) != null);
      }
    }
    return false;
  }
  
  /**
   * We create our own method to create connection views, so we can wrap the
   * elementAdapter with another layer - IElementTypeElementAdapter - which lets us supply IElementType information
   * to the adapter. Otherwise adapter.getAdapter(IElementType.class) will always return null.
   * Otherwise, this method is copied directly from createConnectionView.
   * 
   * Creates a connection view facde element for the supplied semantic element.
   * An empty string is used as the default factory hint.
   * 
   * @param element
   *            the semantic element
   * @param the
   *            connections source editpart
   * @param the
   *            connections target editpart
   * @param index
   *            semantic elements position
   * @generated NOT
   * @see #createConnectionView(EObject, int)
   * @see IElementTypeElementAdapter
   */
  protected Edge myCreateConnectionView(EObject connection, int index) {
    EditPart sep = getSourceEditPartFor(connection);
    EditPart tep = getTargetEditPartFor(connection);
    if (!canCreateConnection(sep, tep, connection)) {
      return null;
    }

    View sView = (View) sep.getModel();
    View tView = (View) tep.getModel();
    Edge model = null;
    String factoryHint = getDefaultFactoryHint();
    // use a different adapter so we can actually get IElementTypes
    IAdaptable elementAdapter = new IElementTypeElementAdapter(connection,
      factoryHint);
    CreateConnectionViewRequest ccr = getCreateConnectionViewRequest(
      elementAdapter, getFactoryHint(elementAdapter, factoryHint), index);

    ccr.setType(RequestConstants.REQ_CONNECTION_START);
    ccr.setSourceEditPart(sep);
    getCreateViewCommand(ccr); // sep.getCommand(ccr); //prime the command
    ccr.setTargetEditPart(tep);
    ccr.setType(RequestConstants.REQ_CONNECTION_END);
    Command cmd = getCreateViewCommand(ccr); // tep.getCommand(ccr);
    if (cmd != null && cmd.canExecute()) {
      List viewAdapters = new ArrayList();
      viewAdapters.add(new EObjectAdapter(((View) host().getModel())
        .getDiagram()));
      viewAdapters.add(new EObjectAdapter(sView));
      viewAdapters.add(new EObjectAdapter(tView));

      SetViewMutabilityCommand.makeMutable(viewAdapters).execute();
      
      executeCommand(cmd);
      IAdaptable adapter = (IAdaptable) ccr.getNewObject();
      SetViewMutabilityCommand.makeMutable(adapter).execute();
      model = (Edge) adapter.getAdapter(Edge.class);
      if (model == null) {
        String eMsg = NLS
          .bind(
            DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_,
            connection);
        IllegalStateException ise = new IllegalStateException(eMsg);
        Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR, eMsg,
          ise);
        throw ise;
      }
    }
    return model;
  }
  
  /**
   * We wrap EObjectAdapter to also adapt to IElementType.class requests, so we can 
   * actually create edges in our current editor.
   * 
   * This is also copied from the other adapter that adapts it to String.class.
   * 
   * @generated NOT
   * @author jmwright
   *
   */
  public static class IElementTypeElementAdapter extends EObjectAdapter {
    private String _hint;
    
    /**
     * constructor
     * @param element
     * @param hint
     */
    public IElementTypeElementAdapter( EObject element, String hint ) {
      super(element);
      _hint = hint;
    }
    
    /** Adds <code>String.class</tt> adaptablity. */
    public Object getAdapter(Class adapter) { 
      if ( adapter.equals(String.class) ) {
        return _hint;
      }
      // my hack: we just get the diagram editor to get the IElementType directly
      if (adapter.equals(IElementType.class)) {
        return IamlElementTypes.getElementType( ((EObject)getRealObject()).eClass() );
      }
      return super.getAdapter(adapter);
    }
  }
  
  
  /**
   * Return a create connection view request.
   * 
   * Copied directly, because the original method is private.
   * 
   * @param elementAdapter
   *            semantic element
   * @param viewKind
   *            type of view to create
   * @param hint
   *            factory hint
   * @param index
   *            index
   * @return a create <i>non-persisted </i> view request
   * @generated NOT
   */
  private CreateConnectionViewRequest getCreateConnectionViewRequest(
      IAdaptable elementAdapter, String hint, int index) {
    return new CreateConnectionViewRequest(getConnectionViewDescriptor(
      elementAdapter, hint, index));
  }


  /**
   * Return a connection view descriptor.
   * 
   * Copied directly, because the original method is private.
   * 
   * @param elementAdapter
   *            semantic element
   * @param hint
   *            factory hint
   * @param index
   *            index
   * @return a create <i>non-persisted </i> connection view descriptor
   * @generated NOT
   */
  private ConnectionViewDescriptor getConnectionViewDescriptor(
      IAdaptable elementAdapter, String hint, int index) {
    return new ConnectionViewDescriptor(elementAdapter, hint, index, false,
      ((IGraphicalEditPart) getHost()).getDiagramPreferencesHint());
  }

  /**
   * @generated
   */
  protected boolean shouldIncludeConnection(Edge connector,
      Collection children) {
    return false;
  }
  
  /**
   * Even though the method "should not be overridden", we do so anyway.
   * 
   * @see #refreshSemanticConnections()
   * @return <code>List</code> of new <code>IAdaptable</code> objects that
   *         adapt to <code>View</code> objects that were created as a
   *         result of the synchronization
   * @generated NOT
   */
  protected List myRefreshSemanticConnections() {
    
    // lets just get the edges (of type EObject)
    List connections = getSemanticConnectionsList();
    List toDelete = new ArrayList();
    
    // remove duplicate links that shouldn't be there
    for (Object obj : ((Diagram) ((VisibleThingEditPart) host()).getModel()).getEdges()) {
      Object found = null;
      Edge edge = (Edge) obj;
      for (Object connection : connections) {
        if (edge.getElement().equals(connection)) {
          // it's OK
          // this logic also make sure that if we have multiple edges for the same object,
          // then we will keep one and delete the rest
          found = connection;
          break;
        }
      }
      
      if (found != null) {
        connections.remove(found);
      }
      
      // if it wasnt found, we need to delete it
      if (found == null) {
        toDelete.add(edge);
      }
      
    }
    
    // delete these duplicate views
    deleteViews(toDelete.iterator());
    
    // remaining edges in 'connections' should be added to diagram
    
    // create a view for each remaining semantic element.
    List viewDescriptors = new ArrayList();
    Iterator semanticChildrenIT = connections.iterator();
    while (semanticChildrenIT.hasNext()) {
      EObject semanticChild = (EObject) semanticChildrenIT.next();
      //Edge viewChild = createConnectionView(semanticChild, ViewUtil.APPEND);
      Edge viewChild = myCreateConnectionView(semanticChild, ViewUtil.APPEND);
      if (viewChild != null) {
        viewDescriptors.add(new EObjectAdapter(viewChild)); 
      }
    }
    
    /*
     * This doesn't seem to do anything.
     */
    //makeViewsMutable(viewDescriptors);

    /*
     * This doesn't seem to do anything either...
     */
    // now refresh all the connection containers to update the editparts
    /*
    HashSet ends = new HashSet();
    ListIterator li = viewDescriptors.listIterator();
    while (li.hasNext()) {
      IAdaptable adaptable = (IAdaptable) li.next();
      Edge edge = (Edge) adaptable.getAdapter(Edge.class);
      EditPart sourceEP = getEditPartFor(edge.getSource(), edge);
      if (sourceEP != null) {
        ends.add(sourceEP);
      }
      EditPart targetEP = getEditPartFor(edge.getTarget(), edge);
      if (targetEP != null) {
        ends.add(targetEP);
      }
    }*/
    
    /*
     * Nor does this...
     */
    /*
    for (Iterator iter = ends.iterator(); iter.hasNext();) {
      EditPart end = (EditPart) iter.next();
      end.refresh();
    }
    */

    return viewDescriptors;
  }

  /**
   * We override the fundamental method of refreshing the diagram -
   * refreshSemantic() - so that we can select not only directly
   * contained elements, but also those referenced in shortcuts.
   * 
   * @generated NOT
   */
  @SuppressWarnings("unchecked")
  protected void refreshSemantic() {
    List createdViews = new LinkedList();
    
    /*
     * I use my own method to select all the Nodes to render in the diagram.
     * @see #refreshSemanticChildren()
     */
    // createdViews.addAll(refreshSemanticChildren());
    createdViews.addAll(myRefreshSemanticChildren());
    List createdConnectionViews = new LinkedList();
    
    /*
     * I use my own method to select all the Edges to render in the Diagram.
     * @see #refreshSemanticConnections()
     */
    // createdConnectionViews.addAll(refreshSemanticConnections());
    createdConnectionViews.addAll(myRefreshSemanticConnections());
    
    /*
     * Using refreshConnections() will set some Edges eContainer=null, which then throws
     * a NullPointerException in:
     * 
     * java.lang.NullPointerException
     *    at org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalEditPolicy.addListenersToContainers(CanonicalEditPolicy.java:1032)
     *    at org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalEditPolicy.makeViewsImmutable(CanonicalEditPolicy.java:1008)
     *   
     * Plus, I'm not sure this method is even necessary anymore... this is the only
     * method that calls it.
     */
    //createdConnectionViews.addAll(refreshConnections());

    // not sure that this actually does anything
    if (createdViews.size() > 1) {
      // perform a layout of the container
      DeferredLayoutCommand layoutCmd = new DeferredLayoutCommand(host()
          .getEditingDomain(), createdViews, host());
      executeCommand(new ICommandProxy(layoutCmd));
    }
    
    // get rid of any duplicate edges
    removeDuplicateEdges();

    createdViews.addAll(createdConnectionViews);
    
    // a hack: remove all 'null' elements in the list
    /*
    while (createdViews.contains(null)) {
      createdViews.remove(null);
    }*/
    
    /*
     * The default makeViewsImmutable() can throw NullPointerExceptions; my modification
     * adds a null check.
     */
    //makeViewsImmutable(createdViews);
    makeViewsImmutableWithNullCheck(createdViews);

  }
  
  /**
   * Cycle through the diagram to get rid of any duplicate edges, i.e. edges that refer
   * to the same EObject.
   * 
   * @generated NOT
   */
  public void removeDuplicateEdges() {
    List objectsFound = new ArrayList();
    List toDelete = new ArrayList();
    for (Object obj : ((Diagram) ((VisibleThingEditPart) host()).getModel()).getEdges()) {
      Object found = null;
      Edge edge = (Edge) obj;
      if (objectsFound.contains(edge.getElement())) {
        // we need to delete this edge
        toDelete.add(edge);
      } else {
        // it's a unique object
        objectsFound.add(edge.getElement());
      }

    }
    
    deleteViews(toDelete.iterator());
  }

  /**
   * Sets views as being immutable, meaning that they are unmodifiable as 
   * non-persisted views.  Any subsequent change to an immutable view will force 
   * the view to be persisted.
   * 
   * This method has been copied exactly.
   * 
   * @generated NOT
   * @param createdViews <code<>List</code> of view adapters that were created during the 
   * {@link CanonicalEditPolicy#refreshSemantic()} operation
   * 
   * @see CanonicalEditPolicy#makeViewsImmutable(List)
   */
  protected void makeViewsImmutableWithNullCheck(List createdViews) {
    if (createdViews != null && !createdViews.isEmpty()) {
      // uses my own method
      addListenersToContainersWithNullCheck(createdViews);
      
      List viewAdapters = prepareAdapterList(createdViews);
      Command immutable = SetViewMutabilityCommand.makeImmutable(viewAdapters);
      AsyncCommand ac = new AsyncCommand(immutable);
      ac.execute();
    }
  }

  /**
   * Copied from {@link CanonicalEditPolicy#addListenersToContainers()}, except this
   * method prevents some NullPointerExceptions from being thrown.
   * 
   * @generated NOT
   * @param createdViews
   */
  private void addListenersToContainersWithNullCheck(List createdViews) {
    UniqueEList list = new UniqueEList();
    ListIterator li = createdViews.listIterator();
    while (li.hasNext()) {
      Object obj = li.next();
      if (obj instanceof IAdaptable) {
        View view = (View)((IAdaptable)obj).getAdapter(View.class);
        if (view != null)
          list.add(view.eContainer());
      }
    }
    
    ListIterator liContainers = list.listIterator();
    while (liContainers.hasNext()) {
      View containerView = (View)liContainers.next();
      if (containerView != null) {    // jevon change: add a null check to prevent NPEs
        addListenerFilter("NotationListener_Container" + containerView.toString(), //$NON-NLS-1$
            this,
            containerView,
            NotationPackage.eINSTANCE.getView_PersistedChildren()); 
      }
    }
  }
  
  /**
   * This method is copied directly from {@link CanonicalEditPolicy#prepareAdapterList(List)}, 
   * since the original method is marked 'private'
   * 
   * @generated NOT
   * @param createdViews
   * @return
   */
  private List prepareAdapterList(List createdViews) {
    List viewAdapters = new ArrayList();
    viewAdapters.add( host() );
    ListIterator li = createdViews.listIterator();
    while (li.hasNext()) {
      Object obj = li.next();
      if (obj != null) {
        if (!(obj instanceof IAdaptable) && obj instanceof EObject)
          viewAdapters.add(new EObjectAdapter((EObject)obj));
        else
          viewAdapters.add(obj);
      }
    }
    return viewAdapters;
  }
  
  /**
   * Copied directly from CanonicalEditPolicy.
   * 
   * Runs the supplied commands asyncronously.
   * 
   * @generated NOT
   **/
  private static class AsyncCommand extends Command {
    private final CompoundCommand _cc;
    
    /**
     * constructor
     * @param label this command label
     */
    public AsyncCommand(String label) {
      super(label);
      _cc = new CompoundCommand(label);
    }

    /**
     * constructor
     * @param cmd the command
     */
    public AsyncCommand( Command cmd ) {
      this( cmd.getLabel() );
      add( cmd );
    }

    
    /**
     * constructor
     * @param cmd the command
     */
    public AsyncCommand( ICommand cmd ) {
      this( cmd.getLabel() );
      add( cmd );
    }
    
    /**
     * Executes the command asynchonously. 
     * Calls {@link #doExecute}.
     */
    public final void execute() {
            // do not use Display.getCurrent() this mthod could be invoked
            // on a non ui thread
            PlatformUI.getWorkbench().getDisplay().asyncExec( new Runnable() {
          public void run() {
            AsyncCommand.this.doExecute();
          }
        } );
    }
    
    /**
     * Return the command to be executed asynchronously.
     * @return the command
     */
    protected final CompoundCommand getCommand() {
      return _cc;
    }
    
    /** Executes the command. */
    protected void doExecute() {
      getCommand().execute(); 
    }
    
    /**
     * Add supplied command to the list of commands to be executed.
     * @param cmd command to add
     */
    public void add( ICommand cmd ) {
      _cc.add( new ICommandProxy(cmd));
    }

    
    /**
     * Add supplied command to the list of commands to be executed.
     * @param cmd the command to add
     */
    public void add( Command cmd ) {
      _cc.add( cmd );
    }
  }
  
  /**
   * Extends refreshSemanticChildren to handle shortcuts too.
   * 
   * @see #getShortcutChildrenList()
   * @generated NOT
   * @return
   */
  protected final List myRefreshSemanticChildren() {

    // Don't try to refresh children if the semantic element
    // cannot be resolved.
    if (resolveSemanticElement() == null) {
      return Collections.EMPTY_LIST;
    }

    //
    // current views
    List viewChildren = getViewChildren();
    List semanticChildren = new ArrayList(getSemanticChildrenList());
    List shortcutChildren = new ArrayList(getShortcutChildrenList());

    // both lists are of EObjects
    shortcutChildren.removeAll(semanticChildren);
    
    List allChildren = new ArrayList();
    allChildren.addAll(semanticChildren);
    allChildren.addAll(shortcutChildren);

    // this method changes [allChildren] by removing elements within it
    // i.e. it removes any views in the list that are already in the view
    List orphaned = cleanCanonicalSemanticChildren(viewChildren,
        allChildren);
    boolean changed = false;
    //
    // delete all the remaining oprphaned views
    if (!orphaned.isEmpty()) {
      changed = deleteViews(orphaned.iterator());
    }

    // so, we need to only select elements within the semanticChildren that are
    // also inside allChildren
    List newSemanticChildren = new ArrayList();
    for (Object o : semanticChildren) {
      if (allChildren.contains(o)) {
        newSemanticChildren.add(o);
      }
    }
    List newShortcutChildren = new ArrayList();
    for (Object o : shortcutChildren) {
      if (allChildren.contains(o)) {
        newShortcutChildren.add(o);
      }
    }

    //
    // create a view for each remaining semantic element.
    List createdViews = Collections.EMPTY_LIST;
    if (!newSemanticChildren.isEmpty()) {
      createdViews = createViews(newSemanticChildren);

      for (int i = 0; i < createdViews.size(); i++) {
        View createdView = (View) ((IAdaptable) createdViews.get(i))
            .getAdapter(View.class);
        if (createdView == null) {
          String eMsg = NLS
              .bind(
                  DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_,
                  newSemanticChildren.get(i));
          IllegalStateException ise = new IllegalStateException(eMsg);
          Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR,
              eMsg, ise);
          throw ise;
        }
      }
    }

    // the same thing, but with shortcuts
    if (!newShortcutChildren.isEmpty()) {
      createdViews = createShortcutViews(newShortcutChildren);

      for (int i = 0; i < createdViews.size(); i++) {
        View createdView = (View) ((IAdaptable) createdViews.get(i))
            .getAdapter(View.class);
        if (createdView == null) {
          String eMsg = NLS
              .bind(
                  DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_
                      + " [shortcut children]",
                  newShortcutChildren.get(i));
          IllegalStateException ise = new IllegalStateException(eMsg);
          Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR,
              eMsg, ise);
          throw ise;
        }
      }
    }

    if (changed || createdViews.size() > 0)
      postProcessRefreshSemantic(createdViews);

    return createdViews;
  }

  /**
   * Get all of the shortcut children to add to this diagram.
   * 
   * @generated NOT
   */
  protected List getShortcutChildrenList() {
    View viewObject = (View) getHost().getModel();
    List result = new LinkedList();
    for (Iterator it = IamlDiagramUpdater
        .getVisibleThing_79ShortcutChildren(viewObject).iterator(); it
        .hasNext();) {
      result.add(((IamlNodeDescriptor) it.next()).getModelElement());
    }
    return result;
  }

  /**
   * Like {@link #createViews(List)}, but creates Shortcut commands instead.
   * 
   * Creates a <code>View</code> element for each of the supplied semantic elements.
   * 
   * @param eObjects list of semantic element
   * @return a list of {@link IAdaptable} that adapt to {@link View}.
   * @generated NOT
   */
  protected final List createShortcutViews(List eObjects) {
    List descriptors = new ArrayList();
    Iterator elements = eObjects.iterator();
    while (elements.hasNext()) {
      EObject element = (EObject) elements.next();
      if (element != null) {
        CreateViewRequest.ViewDescriptor descriptor = getViewDescriptor(element);
        descriptors.add(descriptor);
      }
    }

    if (!descriptors.isEmpty()) {
      //
      // create the request
      CreateViewRequest request = getCreateViewRequest(descriptors);

      //
      // get the command and execute it.
      Command cmd = getCreateViewShortcutsCommand(request, descriptors,
          host());
      if (cmd != null && cmd.canExecute()) {
        SetViewMutabilityCommand.makeMutable(
            new EObjectAdapter(host().getNotationView())).execute();
        executeCommand(cmd);
        List adapters = (List) request.getNewObject();
        return adapters;
      }
    }
    return Collections.EMPTY_LIST;
  }

  /**
   * Get the command to create both the element, and the shortcut decorator, on the request.
   * Copied from {@link #getCreateViewCommand(CreateRequest)}.
   * 
   * @generated NOT
   */
  protected Command getCreateViewShortcutsCommand(CreateRequest request,
      List<CreateViewRequest.ViewDescriptor> descriptors,
      IGraphicalEditPart host) {
    Command command = getCreateViewCommand(request);

    if (command != null) {
      command = command.chain(new ICommandProxy(
          new CreateShortcutDecorationsCommand(
              // these parameters are guessed, but they work
              host.getEditingDomain(), host.getPrimaryView(),
              descriptors, VisibleThingEditPart.MODEL_ID)));

    }

    return command;
  }

  /**
   * A simple command to add a shortcut decoration.
   * 
   * @author jmwright
   * @generated NOT 
   */
  public class CreateShortcutDecorationsCommand extends
      AbstractTransactionalCommand {

    private List<CreateViewRequest.ViewDescriptor> myDescriptors;
    private String modelId;

    /**
     * @param modelEditPart the ID to use for the annotation, e.g. PageEditPart.MODEL_ID
     */
    public CreateShortcutDecorationsCommand(
        TransactionalEditingDomain editingDomain, View parentView,
        List<CreateViewRequest.ViewDescriptor> viewDescriptors,
        String modelId) {
      super(editingDomain,
          "Create Shortcuts", getWorkspaceFiles(parentView)); //$NON-NLS-1$
      myDescriptors = viewDescriptors;
      this.modelId = modelId;

    }

    /**
     * @param modelEditPart the ID to use for the annotation, e.g. PageEditPart.MODEL_ID
     */
    public CreateShortcutDecorationsCommand(
        TransactionalEditingDomain editingDomain, View parentView,
        CreateViewRequest.ViewDescriptor viewDescriptor, String modelId) {
      this(editingDomain, parentView, Collections
          .singletonList(viewDescriptor), modelId);
    }

    protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
        IAdaptable info) throws ExecutionException {
      for (CreateViewRequest.ViewDescriptor nextDescriptor : myDescriptors) {
        View view = (View) nextDescriptor.getAdapter(View.class);
        if (view != null && view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
          EAnnotation shortcutAnnotation = EcoreFactory.eINSTANCE
              .createEAnnotation();
          shortcutAnnotation.setSource("Shortcut"); //$NON-NLS-1$
          shortcutAnnotation.getDetails().put("modelID", modelId); //$NON-NLS-1$
          view.getEAnnotations().add(shortcutAnnotation);
        }
      }
      return CommandResult.newOKCommandResult();
    }
  }

  /**
   * @generated
   */
  private Diagram getDiagram() {
    return ((View) getHost().getModel()).getDiagram();
  }

  /**
   * This method doesn't actually do anything anymore.
   * 
   * Changed by Jevon
   * @generated NOT
   */
  @SuppressWarnings("unchecked")
  private Collection refreshConnections() {
    if (true)
      throw new UnsupportedOperationException("refreshConnections() is no longer used");
    
    /*
    if (true)
      return Collections.EMPTY_LIST;
      */
    Map domain2NotationMap = new HashMap();
    Collection linkDescriptors = collectAllLinks(getDiagram(),
        domain2NotationMap);
    Collection existingLinks = new LinkedList(getDiagram().getEdges());
    for (Iterator linksIterator = existingLinks.iterator(); linksIterator
        .hasNext();) {
      // Jevon change
      boolean linksIteratorRemoved = false;
      Edge nextDiagramLink = (Edge) linksIterator.next();
      int diagramLinkVisualID = IamlVisualIDRegistry
          .getVisualID(nextDiagramLink);
      if (diagramLinkVisualID == -1) {
        if (nextDiagramLink.getSource() != null
            && nextDiagramLink.getTarget() != null) {
          // Jevon change
          if (!linksIteratorRemoved) {
            linksIterator.remove();
            linksIteratorRemoved = true;
          }
        }
        continue;
      }
      EObject diagramLinkObject = nextDiagramLink.getElement();
      EObject diagramLinkSrc = nextDiagramLink.getSource().getElement();
      EObject diagramLinkDst = nextDiagramLink.getTarget().getElement();
      for (Iterator LinkDescriptorsIterator = linkDescriptors.iterator(); LinkDescriptorsIterator
          .hasNext();) {
        IamlLinkDescriptor nextLinkDescriptor = (IamlLinkDescriptor) LinkDescriptorsIterator
            .next();
        if (diagramLinkObject == nextLinkDescriptor.getModelElement()
            && diagramLinkSrc == nextLinkDescriptor.getSource()
            && diagramLinkDst == nextLinkDescriptor
                .getDestination()
            && diagramLinkVisualID == nextLinkDescriptor
                .getVisualID()) {
          // Jevon change 
          if (!linksIteratorRemoved) {
            linksIterator.remove();
            linksIteratorRemoved = true;
          }
          LinkDescriptorsIterator.remove();
        }
      }
    }
    deleteViews(existingLinks.iterator());
    return createConnections(linkDescriptors, domain2NotationMap);
  }

  /**
   * @generated
   */
  private Collection collectAllLinks(View view, Map domain2NotationMap) {
    if (!VisibleThingEditPart.MODEL_ID.equals(IamlVisualIDRegistry
        .getModelID(view))) {
      return Collections.EMPTY_LIST;
    }
    Collection result = new LinkedList();
    switch (IamlVisualIDRegistry.getVisualID(view)) {
    case VisibleThingEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getVisibleThing_79ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case EventTriggerEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getEventTrigger_1001ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case SingleOperationEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getSingleOperation_1002ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case CompositeOperationEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getCompositeOperation_1003ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ChainedOperationEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getChainedOperation_1004ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case DomainObjectEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getDomainObject_1005ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case DomainAttributeEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getDomainAttribute_1006ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ApplicationElementPropertyEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result
            .addAll(IamlDiagramUpdater
                .getApplicationElementProperty_1007ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case PageEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getPage_1008ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case InputFormEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getInputForm_1009ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case InputTextFieldEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getInputTextField_1010ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case StaticValueEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getStaticValue_1011ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case SessionEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getSession_1012ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case LoginHandlerEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getLoginHandler_1013ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case CompositeConditionEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getCompositeCondition_1014ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case DomainObjectInstanceEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getDomainObjectInstance_1015ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case DomainAttributeInstanceEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getDomainAttributeInstance_1016ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ButtonEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getButton_1017ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case SyncWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getSyncWire_3001ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case RunInstanceWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getRunInstanceWire_3002ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ParameterWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getParameterWire_3003ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case SelectWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getSelectWire_3004ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case SetWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getSetWire_3005ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ShowWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getShowWire_3006ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case NavigateWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getNavigateWire_3007ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case CommitWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getCommitWire_3008ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case ConditionWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getConditionWire_3009ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    case NewInstanceWireEditPart.VISUAL_ID: {
      if (!domain2NotationMap.containsKey(view.getElement())) {
        result.addAll(IamlDiagramUpdater
            .getNewInstanceWire_3010ContainedLinks(view));
      }
      if (!domain2NotationMap.containsKey(view.getElement())
          || view.getEAnnotation("Shortcut") == null) { //$NON-NLS-1$
        domain2NotationMap.put(view.getElement(), view);
      }
      break;
    }
    }
    for (Iterator children = view.getChildren().iterator(); children
        .hasNext();) {
      result.addAll(collectAllLinks((View) children.next(),
          domain2NotationMap));
    }
    for (Iterator edges = view.getSourceEdges().iterator(); edges.hasNext();) {
      result.addAll(collectAllLinks((View) edges.next(),
          domain2NotationMap));
    }
    return result;
  }

  /**
   * This method isn't called anymore, because its only called by
   * {@link #refreshConnections()}.
   * 
   * @generated NOT
   */
  private Collection createConnections(Collection linkDescriptors,
      Map domain2NotationMap) {
    if (true)
      throw new UnsupportedOperationException("createConnections() is no longer supported");

    List adapters = new LinkedList();
    for (Iterator linkDescriptorsIterator = linkDescriptors.iterator(); linkDescriptorsIterator
        .hasNext();) {
      final IamlLinkDescriptor nextLinkDescriptor = (IamlLinkDescriptor) linkDescriptorsIterator
          .next();
      EditPart sourceEditPart = getEditPart(nextLinkDescriptor
          .getSource(), domain2NotationMap);
      EditPart targetEditPart = getEditPart(nextLinkDescriptor
          .getDestination(), domain2NotationMap);
      if (sourceEditPart == null || targetEditPart == null) {
        continue;
      }
      CreateConnectionViewRequest.ConnectionViewDescriptor descriptor = new CreateConnectionViewRequest.ConnectionViewDescriptor(
          nextLinkDescriptor.getSemanticAdapter(), null,
          ViewUtil.APPEND, false, ((IGraphicalEditPart) getHost())
              .getDiagramPreferencesHint());
      CreateConnectionViewRequest ccr = new CreateConnectionViewRequest(
          descriptor);
      ccr.setType(RequestConstants.REQ_CONNECTION_START);
      ccr.setSourceEditPart(sourceEditPart);
      sourceEditPart.getCommand(ccr);
      ccr.setTargetEditPart(targetEditPart);
      ccr.setType(RequestConstants.REQ_CONNECTION_END);
      Command cmd = targetEditPart.getCommand(ccr);
      if (cmd != null && cmd.canExecute()) {
        executeCommand(cmd);
        IAdaptable viewAdapter = (IAdaptable) ccr.getNewObject();
        if (viewAdapter != null) {
          adapters.add(viewAdapter);
        }
      }
    }
    return adapters;
  }

  /**
   * @generated
   */
  private EditPart getEditPart(EObject domainModelElement,
      Map domain2NotationMap) {
    View view = (View) domain2NotationMap.get(domainModelElement);
    if (view != null) {
      return (EditPart) getHost().getViewer().getEditPartRegistry().get(
          view);
    }
    return null;
  }
}
