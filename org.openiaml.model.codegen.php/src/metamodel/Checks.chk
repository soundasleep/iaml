import iaml;

// NOTE: checks cannot have a semicolon in the exception, otherwise the 
// OAW parser won't be able to parse beyond it
extension metamodel::Extensions;

// TODO add test cases for model validation
// both through Eclipse and through manual test cases (code generation)
context model::InternetApplication ERROR "No frames in internet application" :
	!(scopes.typeSelect(model::visual::Frame).isEmpty &&
		scopes.scopes.typeSelect(model::visual::Frame).isEmpty);

context model::visual::Frame ERROR "Frame must have a name" :
	name.length > 0;
	
context model::Operation ERROR "Operation must have a name" :
	name.length > 0;
	
context model::components::LoginHandler ERROR "A login handler must have an incoming parameter to check against" :
	!inParameterEdges.isEmpty;
	
context model::components::LoginHandler ERROR "A login handler of type USER must have at least one incoming parameter of type Role":
	type != model::components::LoginHandlerTypes::USER ||
	!inParameterEdges.from.typeSelect(model::users::Role).isEmpty;

context model::components::LoginHandler ERROR "A login handler of type DOMAIN_OBJECT must have at least one incoming parameter of type DomainAttribute":
	type != model::components::LoginHandlerTypes::DOMAIN_OBJECT ||
	!inParameterEdges.from.typeSelect(model::DomainAttribute).isEmpty;

context model::wires::RunAction ERROR "A run instance wire can only connect to an operation" :
	model::Operation.isInstance( to );

context model::operations::DecisionNode ERROR "A compare DecisionNode must have at least two data flows in to compare" :
	(name == "equal?" && inFlows.size >= 2) 
	|| (name != "equal?"); 

context model::operations::DecisionNode ERROR "A DecisionNode can only have at most two out execution edges" :
	outExecutions.size <= 2;
	
context model::wires::SyncWire ERROR "You cannot have a SyncWire that connects to a StaticValue":
	!model::StaticValue.isInstance(from) &&
	!model::StaticValue.isInstance(to);
	
context model::wires::SyncWire ERROR "You cannot have a SyncWire that connects to a QueryParameter":
	!model::QueryParameter.isInstance(from) &&
	!model::QueryParameter.isInstance(to);

context model::wires::SyncWire ERROR "A SyncWire cannot connect to itself":
	from != to;

context model::wires::SyncWire ERROR "You cannot have a SyncWire connecting two ApplicationElementProperties":
	!(model::Property.isInstance(from) && 
	model::Property.isInstance(to));
	
context model::domain::DomainSchema ERROR "You cannot have a DomainSchema called single_values (reserved word)" :
	name != "single_values";
	
/**
 * Important: If this message changes, it must also be updated in org.openiaml.model.custom.actions.GenerateCodeAction#couldBePhantomEdges()
 */	
context model::Wire ERROR "A Wire must have a 'from'" :
	from != null;

/**
 * Important: If this message changes, it must also be updated in org.openiaml.model.custom.actions.GenerateCodeAction#couldBePhantomEdges()
 */	
context model::Wire ERROR "A Wire must have a 'to'" :
	to != null;

context model::Action ERROR "An Action must have a 'from'" :
	from != null;
context model::Action ERROR "An Action must have a 'to'" :
	to != null;

context model::wires::ExtendsEdge ERROR "A Role cannot extend itself" :
	from != to;

/*
 * isInstance() definitely works in OAW checks for abstract supertypes.
 * if a check isn't working, make sure that you are following the OAW
 * checks logic correctly; the predicate is expected to be _true_,
 * and will only throw an exception if the predicate is false.
 *
 * i.e.: "name != 'single_values'"
 */

context model::operations::OperationCallNode ERROR "An OperationCallNode must have exactly one RunAction connecting it to an Operation" :
	outActions.size == 1
		&& model::wires::RunAction.isInstance(outActions.first())
		&& model::Operation.isInstance(outActions.first().to);

context model::wires::RunAction WARNING "This RunAction will not do anything: consider naming it 'onClick'" :
	!(model::VisibleThing.isInstance(from) && !(name == "click" || name == "onClick"));

context model::Property WARNING "A session property used as part of a login handler should have a default value set, otherwise secure frames will crash with an exception rather than going to the login frame" :
	!(defaultValue == null && inWires.typeSelect(model::wires::SetWire).from.typeSelect(model::components::LoginHandler).size > 0); 

context model::QueryParameter ERROR "A QueryParameter cannot be used on a Frame outside of its containing frame (" + containingFrame(this.eContainer) + ", " + containingFrame(outWires.first().to.eContainer) + ")" :
	outWires.forAll( e | isAccessibleOnFrame(containingFrame(this.eContainer), e.to) );

context model::components::LoginHandler ERROR "A LoginHandler[user] can not have more than one incoming ParameterWire" :
	(type != model::components::LoginHandlerTypes::USER) || inParameterEdges.size <= 1; 

context model::domain::DomainIterator ERROR "A DomainIterator has incoming Parameters, but does not have a query to use them" :
	inParameterEdges.isEmpty || (query != null && query.length > 0); 

context model::scopes::Session ERROR "A Session can only contain one LoginHandler" :
	elements.typeSelect(model::components::LoginHandler).size <= 1;

context model::visual::Frame ERROR "A Frame cannot contain a LoginHandler" :
	elements.typeSelect(model::components::LoginHandler).size == 0;

context model::CompositeOperation ERROR "An Operation can only contain one StartNode" :
	nodes.typeSelect(model::operations::StartNode).size <= 1;

context model::CompositeCondition ERROR "A Condition can only contain one StartNode" :
	nodes.typeSelect(model::operations::StartNode).size <= 1;

// issue 98: unused PrimitiveOperation names should issue a warning
// issue 136: CompositeOperations should not have this warning
context model::PrimitiveOperation WARNING "Unknown primitive operation name '" + name + "'" :
	model::CompositeOperation.isInstance(this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).next == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).previous == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).reset == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).skip == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).jump == this) || 
	(name == "set" ||
		name == "javascriptAlert" || name == "save" ||
		name == "new" ||
		name == "equal?" || name == "add role" ||
		name == "add permission" || name == "remove role" ||
		name == "remove permission" || name == "check permissions" ||
		(model::VisibleThing.isInstance(eContainer) &&
			(name == "hide" || name == "show")) || 
		(model::scopes::Email.isInstance(eContainer) &&
			(name == "send")) ||
		name == "true?" || name == "can cast?");

context model::PrimitiveCondition WARNING "Unknown primitive condition name '" + name + "'" :
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).hasNext == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).hasPrevious == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).canSave == this) || 
	(eContainer != null && model::domain::DomainIterator.isInstance(eContainer) && ((model::domain::DomainIterator) eContainer).empty == this);		

context model::operations::Arithmetic ERROR "Arithmetic must have at least one incoming data source edge" :
	inFlows.size > 0;

context model::components::EntryGate ERROR "An EntryGate needs to have at least one incoming Condition, or one outgoing 'first' wire, or it will never permit access" :
	inConditionEdges.size >= 1
	|| outWires.typeSelect(model::NamedElement).exists(w | w.name == "first");

context model::components::ExitGate ERROR "An ExitGate needs to have at least one incoming Condition, or one outgoing 'last' wire, or it will never permit access" :
	inConditionEdges.size >= 1
	|| outWires.typeSelect(model::NamedElement).exists(w | w.name == "last");
	
context model::operations::DecisionNode ERROR "A 'can cast?' DecisionNode needs to have an incoming DataFlowEdge from a CastNode" :
	name != "can cast?" || 
	(inFlows.size == 1 && model::operations::CastNode.isInstance(inFlows.first().from));

context model::operations::DecisionNode ERROR "A 'can cast?' DecisionNode needs to have an incoming DataFlowEdge from a CastNode" :
	name != "can cast?" || 
	(inFlows.size == 1 && model::operations::CastNode.isInstance(inFlows.first().from));

context model::operations::CastNode ERROR "A CastNode needs exactly one incoming data flow edge, had: " + inFlows.size :
	inFlows.size == 1;

/**
 * To quickly identify problems related to issue 170: making an explicit Property called 'fieldValue'
 */
context model::ContainsProperties WARNING "You should not have a contained Property named 'fieldValue', unless it is contained within the fieldValue containment feature" :
	properties.select(e | e.name == "fieldValue").isEmpty; 

/**
 * Two types are specified to be incompatible if they are different.
 * TODO this should be changed, because e.g. email is compatible with string in one direction. 
 */
context model::Changeable ERROR "Type '" + type.uRI + "' is incompatible with contained fieldValue type '" + fieldValue.type.uRI + "'":
	type == null ||
	fieldValue == null ||
	fieldValue.type == null ||
	type.uRI == fieldValue.type.uRI;

context model::Changeable ERROR "Contained fieldValue property has a default value, even though container already specifies one" :
	defaultValue == null ||
	fieldValue == null ||
	fieldValue.defaultValue == null ||
	defaultValue == fieldValue.defaultValue;

context model::scopes::Email ERROR "An e-mail cannot contain a Property and a StaticValue with the same name" :
	properties.collect(e|e.name).intersect(values.collect(e|e.name)).isEmpty;

context model::wires::SyncWire ERROR "A SyncWire cannot connect to an Email" :
	!model::scopes::Email.isInstance(to) &&
	!model::scopes::Email.isInstance(from);

context model::DomainAttributeInstance ERROR "A DomainAttributeInstance must extend a DomainAttribute as its definition" :
	!outExtendsEdges.to.typeSelect(model::DomainAttribute).isEmpty;
	