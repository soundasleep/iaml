/**
 * Rules related to DetailWires.
 */
package org.openiaml.model.drools.rules.detail_wires

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.datatypes.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create QueryParameter for target container of DetailWire"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( )
		
		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet(instanceSet, instance, source )) )

		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		pk : DomainAttribute ( eContainer == schema, primaryKey == true ) 

		not ( queryPk : QueryParameter ( eContainer == target, name == pk.name ) )
	
		eval ( handler.veto( detail ))
	
	then
		QueryParameter qp = handler.generatedQueryParameter(detail, target);
		handler.setName(qp, pk.getName());
		queue.add(qp, drools);
	
end

/**
 * @inference DetailWire
 *		When a {@model DetailWire} is connected from a {@model Frame} that uses a
 *		{@model SelectWire selected} {@model DomainIterator}, to an empty {@model Frame},
 *		the target {@model Frame} will obtain content to select an instance from a {@model QueryParameter}.
 */
rule "Create a relevant DomainIterator, with SelectWire, in the destination for the DetailWire"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		pk : DomainAttribute ( eContainer == schema, primaryKey == true )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		queryPk : QueryParameter ( eContainer == target, name == pk.name )
		
		not ( DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) ))
	
		eval ( handler.veto( detail ))
	
	then
		DomainIterator i2 = handler.generatedDomainIterator(detail, target);
		handler.setName(i2, "Current " + schema.getName() + " instance");
		// set the query
		handler.setLimit(i2, 1);
		handler.setQuery(i2, functions.safeNameString(pk.getName()) + " = :pk");				
		queue.add(i2, drools);
		
		// connect QueryParameter
		ParameterEdge param = handler.generatedParameterEdge(detail, target, queryPk, i2);
		handler.setName(param, "pk");
		queue.add(param, drools);
	
end

/**
 * @model DetailWire
 *		If a {@model VisibleThing} to view the selected {@model DomainIterator} from a
 *		{@model DetailWire} does not exist, a {@model InputForm} will be created.
 */
rule "Create a View Instance Form for target of DetailWire"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		i2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )

		not ( VisibleThing ( eContainer == target, eval( ("View " + schema.getName()).equals(name) ) ) )
	
		eval ( handler.veto( detail ))
	
	then
		InputForm form = handler.generatedInputForm(detail, target);
		handler.setName(form, "View " + schema.getName());
		queue.add(form, drools);

end

rule "Connect View Instance Form with a SetWire to the DomainIterator"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
				
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		i2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )

		form : VisibleThing ( eContainer == target, eval( ("View " + schema.getName()).equals(name) ) )
		
		not ( set : SetWire ( eval( functions.connectsSet( set, i2, form ) ) ) )
	
		eval ( handler.veto( detail ))
	
	then
		SetWire set = handler.generatedSetWire(detail, target, i2, form);
		handler.setName(set, "set");
		queue.add(set, drools);
	
end

/**
 * @inference DetailWire
 *		When a {@model DetailWire} is connecting from a {@model InputForm} that is populated
 *		by a {@model SelectWire}, a {@model Button} will be created in the {@model InputForm}
 *		to {@model ActionEdge view} the current instance in the target {@model Frame}.
 */
rule "Create a Link Button for the source of a DetailWire"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		not ( button : VisibleThing ( eContainer == source, name == "link" )) 
	
		eval ( handler.veto( detail ))
	
	then
		Button link = handler.generatedButton(detail, source);
		handler.setName(link, "link");
		queue.add(link, drools);
	
end

rule "Create a Link Button for the source of a DetailWire: Connect ActionEdge"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		
		not ( ActionEdge ( from == onClick, to == target )) 
	
		eval ( handler.veto( detail ))
	
	then
		ActionEdge nav = handler.generatedActionEdge(detail, source, onClick, target);
		handler.setName(nav, "View detail");
		queue.add(nav, drools);
		
end

rule "Create a Link Button for the source of a DetailWire (not IteratorList): Add Parameter from AttributeInstance"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		# ignoring IteratorLists
		not ( IteratorList ( this == source )) 
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		nav : ActionEdge ( from == onClick, to == target )

		pkAttribute : DomainAttribute ( eContainer == schema, primaryKey == true )
		pkInstance : DomainAttributeInstance ( eContainer == instance )
		ExtendsEdge ( from == pkInstance, to == pkAttribute )
		
		pk : Property ( pkInstance.fieldValue == pk ) 
		
		not ( ParameterEdge ( from == pk, to == nav ))
	
		eval ( handler.veto( detail ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(detail, source, pk, nav);
		handler.setName(param, pkAttribute.getName());
		queue.add(param, drools);
	
end

rule "Create a Link Button for the source of a DetailWire (IteratorList): Add Parameter from AttributeInstance"
	when
		container : Frame( )
		
		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : IteratorList ( eContainer == container )
		target : Frame ( )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		button : VisibleThing ( eContainer == source, name == "link" )
		onClick : EventTrigger ( button.onClick == onClick )
		nav : ActionEdge ( from == onClick, to == target )

		pkAttribute : DomainAttribute ( eContainer == schema, primaryKey == true )
		pkInstance : DomainAttributeInstance ( eContainer == instance )
		ExtendsEdge ( from == pkInstance, to == pkAttribute )
		
		# attribute instance is connected to the Container by a SetWire or SyncWire to a Hidden
		hidden : Hidden ( eContainer == source )
		set : SetWire ( eval(functions.connectsSet(set, pkInstance, hidden) ) )
		
		pk : Property ( hidden.fieldValue == pk ) 
		
		not ( ParameterEdge ( from == pk, to == nav ))
	
		eval ( handler.veto( detail ))
	
	then
		ParameterEdge param = handler.generatedParameterEdge(detail, source, pk, nav);
		handler.setName(param, pkAttribute.getName());
		queue.add(param, drools);
	
end

/**
 * @inference DetailWire,DomainIterator
 *		The generated {@model DomainIterator} used to select one instance of a
 *		{@model DetailWire} source is given the same {@model DomainSource} as the
 *		original {@model DomainIterator}.
 */
rule "The view one DomainIterator is connected to the same DomainSource as the view many DomainIterator"
	when
		container : Frame( )

		schema : DomainSchema ( )
		domainSource : DomainSource ( )
		instance : DomainIterator( eContainer == container )

		selectEdge : SelectEdge ( eval ( functions.connectsSelect(selectEdge, instance, domainSource )) )
		schemaEdge : SchemaEdge ( eval ( functions.connectsSchema(schemaEdge, domainSource, schema )) )
		
		source : VisibleThing ( eContainer == container )
		target : Frame ( )
		instanceSet : SetWire ( eval(functions.connectsSet( instanceSet, instance, source ) ) )
		
		detail : DetailWire ( )
		eval ( functions.connectsDetail(detail, source, target ))
		
		iterator2 : DomainIterator ( eContainer == target,
			name != null && eval( name.equals("Current " + schema.getName() + " instance") ) )
		
		not ( SelectEdge ( from == iterator2 ))		
	
		eval ( handler.veto( detail ))
	
	then
		SelectEdge select = handler.generatedSelectEdge(detail, iterator2, iterator2, domainSource);
		queue.add(select, drools); 
	
end
