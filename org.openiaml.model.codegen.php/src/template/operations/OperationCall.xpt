«IMPORT iaml»

/**
 * Calling an operation.
 */
«EXTENSION template::GeneratorExtensions»

/* default: don't know what to do */
«DEFINE callOperation(Boolean php, Boolean inStoreDb, model::visual::Page currentPage) FOR model::WireEdge»
	«EXPAND exception FOR throwException("Unknown wire edge connected to edit trigger: " + this)»
«ENDDEFINE»

/* 
 * Run a command with some parameters.
 * RunInstanceWire: event --> operation 
 *
 * @param inStoreDb is set if we are calling operations as a result of storing a value
 * in the database. instead of defining a new function 'get_db_param(...)' and
 * using this as a parameter source,
 * we instead use '$arg0', which we expect will be set already.
 * @see callOperationsParameterSource() and StoreDbPhp::expandDomainAttributeEvents()
 */
«DEFINE callOperation(Boolean php, Boolean inStoreDb, model::visual::Page currentPage) FOR model::wires::RunInstanceWire-»
	/* eContainer == «to.eContainer» */
	
	«IF php»
		$result = null;
	«ELSE»
		var result = null;
	«ENDIF»
	
	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		/* expand conditions */
		if («EXPAND template::conditions::Runtime::callCondition(php, this, inStoreDb, currentPage) FOREACH inEdges.typeSelect(model::wires::ConditionWire) SEPARATOR " && "») {
	«ENDIF»

	«IF php»
		$result =
	«ELSE»
		result = 
	«ENDIF»

	«IF model::VisibleThing.isInstance(to.eContainer)-»
		«REM»VisibleThing includes InputTextField and Page«ENDREM»
		«REM»
			is both source and target on the same page? NOTE this
			will also return true for Event-->Operation if they are
			both on the same page.
		«ENDREM»
		«IF availableInCurrentScript(from, to)-»
			«REM»// on current page (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOREACH inEdges.typeSelect(model::wires::ParameterWire).sortBy(e|e.name) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current page (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingPage(to).id)»', '«operationName(to)-»'
				«IF inEdges.size>0», «EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingPage(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF model::scopes::Session.isInstance(to.eContainer)-»
		«IF availableInCurrentScript(from, to)-»
			«REM»// on current page (wire id = «id»)«ENDREM»
			do_«operationName(to)»(«EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOREACH inEdges.typeSelect(model::wires::ParameterWire).sortBy(e|e.name) SEPARATOR ", "»);
		«ELSE-»
			«REM»// not on current page (wire id = «id»)«ENDREM»
			call_remote_event('«safeNameString(containingPage(to).id)»', '«operationName(to)-»'
				«IF inEdges.size>0», «EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
			);
			«REM»				
			store_event('«containingPage(to).id»', 'do_«operationName(to)»'
			«ENDREM»
		«ENDIF-»
	«ELSEIF isDomainAttribute(to.eContainer)-»
		«REM»direct field --> abstract domain attribute«ENDREM»
		store_db('«safeNameString(((model::DomainAttribute) to.eContainer).id)»'
			«IF inEdges.size>0», «EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»«ENDIF»
		); 
	«ELSEIF isDomainAttributeInstance(to.eContainer)-»
		«REM»direct field --> domain attribute instance«ENDREM»
		«EXPAND template::domain::AttributeInstance::attributeInstanceCall(php, inStoreDb, this, (model::DomainAttributeInstance) to.eContainer, currentPage) FOR to»;
	«ELSEIF isDomainObjectInstance(to.eContainer)-»
		«REM»direct field --> domain object instance«ENDREM»
		«EXPAND template::domain::DomainInstance::domainInstanceCall(php, this, (model::DomainObjectInstance) to.eContainer, currentPage) FOR to»;
	«ELSEIF model::components::AccessControlHandler.isInstance(to.eContainer)-»
		«EXPAND template::users::AccessControlHandler::accessControlHandlerOperationCall(php, this, (model::components::AccessControlHandler) to.eContainer) FOR to»;
	«ELSE-»
		alert('unknown target operation type in «to.eContainer.metaType.name»');
		«EXPAND exception FOR throwException("Unknown target operation type in '" + to.eContainer.metaType.name + "' (this=" + this + ")")»
	«ENDIF-»

	«IF inEdges.typeSelect(model::wires::ConditionWire).size != 0»
		}
	«ENDIF»
«ENDDEFINE»

/**
 * NavigateWire: browse to a new destination.
 * We need to switch on the target, because we could navigate to many different types
 * of new destinations?
 */
«DEFINE callOperation(Boolean php, Boolean inStoreDb, model::visual::Page currentPage) FOR model::wires::NavigateWire»
	«EXPAND navigateTo(php, inStoreDb, currentPage, this) FOR to» 
«ENDDEFINE»

«DEFINE navigateTo(Boolean php, Boolean inStoreDb, model::visual::Page currentPage, model::wires::NavigateWire wire) FOR model::WireEdgeDestination»
	«EXPAND exception FOR throwException("Unknown NavigateWire destination: " + this)»
«ENDDEFINE»

/**
 * Resuming navigation to a Gate.
 */
«DEFINE navigateTo(Boolean php, Boolean inStoreDb, model::visual::Page currentPage, model::wires::NavigateWire wire) FOR model::components::Gate»
	«IF php»
		/* navigating back to resume a gate */
		// get the resume ID
		«EXPAND template::scopes::Gate::getResumeTarget('resume')»
		if (!$resume) {
			// nowhere to resume; select somewhere random
			«EXPAND template::scopes::Gate::getAnyTarget('resume')»
		}
		
		if ($resume != CURRENT_PAGE) {
			// navigate to another page
			$url = "$resume.php";
			log_message("Resuming to '$url'");
			header("Location: $url");
			die;
		}
	«ELSE»
		var url = "<?php
			/* navigating back to resume a gate */
			// get the resume ID
			«EXPAND template::scopes::Gate::getResumeTarget('resume')»
			if (!$resume) {
				// nowhere to resume; select somewhere random
				«EXPAND template::scopes::Gate::getAnyTarget('resume')»
			}
			
			echo $resume;
		?>.php";
		debug("Resuming to '" + url + "'");
		window.location = url;
		ajaxIncrement();	// prevent other events from executing		
	«ENDIF»
«ENDDEFINE» 

/**
 * Navigate to a page.
 */
«DEFINE navigateTo(Boolean php, Boolean inStoreDb, model::visual::Page currentPage, model::wires::NavigateWire wire) FOR model::visual::Page»
	«IF php»
		/* prevent infinite loops on the current page */
		if ("«id-»" != CURRENT_PAGE) {
			// navigate to another page
			$url = "«safeName()».php";
			log_message("Redirecting to '$url'");
			header("Location: $url");
			die;
		}
	«ELSE»
		// navigating to a new page
		var url = "«safeName()».php";
		debug("Redirecting to '" + url + "'");
		window.location = url;
		ajaxIncrement();	// prevent other events from executing
	«ENDIF»
«ENDDEFINE»

/**
 * Assumes that there is a function call waiting in 'function_queue'.
 * This function will be executed with the response as a parameter.
 */
«DEFINE callRemoteOperation(Boolean php, Boolean inStoreDb, model::visual::Page currentPage) FOR model::wires::RunInstanceWire-»
	«IF inEdges.typeSelect(model::wires::ParameterWire).size > 0» 
		var arg0 = «EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOR inEdges.typeSelect(model::wires::ParameterWire).get(0)»;
	«ELSE»
		var arg0 = null;	/* no parameter */
	«ENDIF»
	«IF inEdges.typeSelect(model::wires::ParameterWire).size > 1»
		var arg1 = «EXPAND Parameters::callParameter(php, this, inStoreDb, false, currentPage) FOR inEdges.typeSelect(model::wires::ParameterWire).get(1)»;
	«ELSE»
		var arg1 = null;	/* no parameter */
	«ENDIF»
	call_remote_event(
		'«safeNameString(containingPage(to).id)»', 
		'«operationName(to)-»',
		arg0,
		arg1,
		function_queue
	);
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
