«IMPORT iaml»

/**
 * The flow of execution within an operation.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * TODO unresolved: How to handle multiple outExecutions within PHP and JS.
 * 
 * Option: Start new threads, though this could be challenging for Javascript, and it
 * will also introduce concurrency issues.
 *
 * @param operation is the current operation flow from an operation? if false, it is from a condition.  
 */
# @implementation StartNode If a {@model StartNode} has more than one {@model ExecutionEdge} coming out of it, they will be executed sequentially. 
«DEFINE executionFlow(Boolean operation, model::visual::Frame container, Boolean php) FOR model::operations::StartNode-»
	«EXPAND executionFlowInternal(operation, container, php, outExecutions) FOR this»
«ENDDEFINE»

«DEFINE executionFlowInternal(Boolean operation, model::visual::Frame container, Boolean php, List[model::ExecutionEdge] edges) FOR model::ExecutionEdgesSource-»
	// flow starts here
	/**
	 * Since Javascript does not support GOTO, we must emulate this manually.
	 * We also implement this in PHP to unify the approach.
	 * 
	 * TODO Ideally we would take the execution graph and translate it sensibly
	 * into a correct structure of blocks, but this remains future work.
	 */
	// we emulate goto using an infinite loop of switch(pos)
	«REM»initialise stack«ENDREM»
	«IF php»
		$call_stack_«safeName()» = new CallStack();
		$completed_«safeName()» = false;
	«ELSE»
		var call_stack_«safeName()» = new CallStack();
		var completed_«safeName()» = false;
	«ENDIF»
	
	«REM»all of the initial outgoing executions are inserted onto the stack initially«ENDREM»
	«FOREACH edges AS e»
		«EXPAND addStack(this, php) FOR e»
	«ENDFOREACH»
	
	«REM»loop over stack until it is complete«ENDREM»
	«IF php»
		while (!$completed_«safeName()») {
			$current_node_«safeName()» = $call_stack_«safeName()»->pop();
			switch ($current_node_«safeName()») {
	«ELSE»
		while (!completed_«safeName()») {
			var current_node_«safeName()» = call_stack_«safeName()».pop();
			switch (current_node_«safeName()») {
	«ENDIF»
	
			«FOREACH allDestinations(this, {}) AS dest»
				case "«safeName(dest)»":
					«EXPAND executionFlowStep(operation, this, container, php) FOR dest»
					break;
			«ENDFOREACH»
			
				default:
					«IF php»
						throw new IamlRuntimeException("Unexpected state: " . $current_node);
					«ELSE»
						throw new IamlJavascriptException("Unexpected state: " + current_node);
					«ENDIF»
				}
			}
	// all destinations 2:
	/*
	 * «allDestinations(this, {})»
	 */
«ENDDEFINE»

«DEFINE executionFlow(Boolean operation, model::visual::Frame container, Boolean php) FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/**
 * Converts an ExecutionEdge into an operation on the call stack.
 */
«DEFINE addStack(model::ExecutionEdgesSource start, Boolean php) FOR model::ExecutionEdge»
	«IF php»$call_stack_«safeName(start)»->push«ELSE»call_stack_«safeName(start)».push«ENDIF»
	("«safeName(to)-»");
«ENDDEFINE»

«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR emf::EObject-»
	/* disabled */
	// all destinations 1:
	/*
	 * «allDestinations(this, {})»
	 */
«ENDDEFINE»

/**
 * The individual steps within a flow.
 */
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::ExecutionEdgeDestination-»
	«throwException("Unknown operation contents node: " + this)»
«ENDDEFINE»

«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::CancelNode-»
	«IF operation»
		«REM»operations will throw exceptions at CancelNodes«ENDREM»
		«IF exceptionText.length > 0»
			«IF php»
			throw new IamlRuntimeException("«exceptionText»");
			«ELSE»
			throw new IamlJavascriptException("«exceptionText»");
			«ENDIF»
		«ELSE»
			// ignored cancel node "«this»" since it did not have an exception text
		«ENDIF»
	«ELSE»
		«REM»conditions will return false at CancelNodes«ENDREM»
		return false;
	«ENDIF»
«ENDDEFINE»

«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::StartNode-»
	«throwException("Should never have the executionFlowStep start at a StartNode: use executionFlow.")»
«ENDDEFINE»

«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::FinishNode-»
	// operation finished successfully
	«IF operation»
		«REM»operations will continue at FinishNodes (to let threads finish)«ENDREM»
		«IF php»
			$completed_«safeName(start)» = true;
		«ELSE»
			completed_«safeName(start)» = true;
		«ENDIF»
	«ELSE»
		«REM»conditions will return true at FinishNodes (TODO threads don't need to finish?)«ENDREM»
		return true;
	«ENDIF»
«ENDDEFINE»

/**
 * We implement split nodes lazily; each branch is executed in sequence.
 *
 * Each split node will continue execution as normal until it reaches a
 * JoinNode, then it will stop.
 *
 * The second part of this template will iterate down the first split
 * path until it finds a JoinNode; we define this as the end of the split,
 * and continue execution from there.
 *
 * This assumes that all splits and joins occur with the same edges, etc. 
 *
 * TODO: What about recursive split/joins? 
 * TODO: What about multi level split/joins? e.g.
 *       |-> b ->|-> f ->|
 *   a ->|-> c ->|       |-> g
 *       |-> d ----> e ->|
 */ 
# @implementation SplitNode,JoinNode Currently execution split is implemented in a single threaded way; each {@model ExecutionEdge execution flow} is executed sequentially until all flows are complete. 
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::SplitNode-»
	/* a split node */
	
	«REM»
		disable function_queue until we get to the end.
		this is necessary, otherwise all split functions in
		here will call the same function_queue multiple times.
	
		one side effect of this is that any splitted "set" operations
		will only get to the first "set" operation before
		the function queue (which may be a redirect to another frame)
		executes, so the other "set" operations would not complete.	
	«ENDREM»
	«IF !php»
		«REM»
		// disable function queue over split
		var function_queue_split_«safeName()» = function_queue;
		var function_queue_queued_split_«safeName()» = function_queue_queued;
		function_queue = function() { };
		function_queue_queued = false;
		«ENDREM»

		/* we wrap up the function queue in N layers, so we
		 can progressively unwrap it as it is executed */
		
		var function_queue_wrapped_«safeName()» = function_queue;
		var function_queue_wrapped_«safeName()»_count = «outExecutions.size»;
		
		function_queue = function() {
			function_queue_wrapped_«safeName()»_count--;
			
			if (function_queue_wrapped_«safeName()»_count == 0) {
				function_queue_wrapped_«safeName()»();	// execute it
			} else if (function_queue_wrapped_«safeName()»_count < 0) {
				throw new IamlJavascriptException("Ran out of function queue wrapping: «this»");
			} else {
				// expected
			}
		}
	«ENDIF»
	
		
	«REM»
		we emulate split nodes by adding additional layers of
		call stacks, in a similar way to StartNode, for each
		outgoing edge
	«ENDREM»
	«FOREACH outExecutions AS e-»
		«EXPAND executionFlowInternal(operation, container, php, {e}) FOR this» 
	«ENDFOREACH»
	
	«REM»
		find the target join node for this split node; this is
		where execution will continue (and set the next step
		in the call stack)
	«ENDREM»
	// final join node = «findFinalJoinNode(this)»
	«IF findFinalJoinNode(this) != null»
		«EXPAND executionFlowStep(operation, start, container, php) FOR findFinalJoinNode(this)»
	«ELSE»
		«throwException("No join node found for split node '" + this + "'")»
	«ENDIF»
	
	«REM»
	«IF !php»
		// restore function queue after split
		function_queue = function_queue_split_«safeName()»;
		function_queue_queued = false;
	«ENDIF»
	«ENDREM»

«ENDDEFINE»

«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::JoinNode-»
	// split finished successfully
	«IF php»
		$completed_«safeName(start)» = true;
	«ELSE»
		completed_«safeName(start)» = true;
	«ENDIF»
«ENDDEFINE»

/* a primitive operation: carry on */
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::PrimitiveOperation-»
	// primitive operation "«name-»"
	«EXPAND Contents::operationContents(start, container, php) FOR this-»
	
	«REM»Contents::operationContents() will expand outgoing executions as necessary«ENDREM»
	
	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/* a decision operation: expandOperationContents will continue the execution flow */
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::DecisionOperation-»
	// decision operation "«name-»"
	«EXPAND Contents::operationContents(start, container, php) FOR this-»

	«REM»Contents::operationContents() will expand outgoing executions as necessary«ENDREM»

	// continue chained operations
	«EXPAND continueChainedOperations(php) FOR this»
«ENDDEFINE»

/**
 * A decision condition.
 */
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::DecisionCondition-»
	// decision condition "«name-»"
	«EXPAND Contents::operationContents(start, container, php) FOR this-»

	«REM»Contents::operationContents() will expand outgoing executions as necessary«ENDREM»
«ENDDEFINE»

/**
 * An operation call: expand for any parameters.
 *
 * @implementation OperationCall The result from a {@model OperationCall} can be used to 
 *    execute conditional {@model ExecutionEdge execution paths}.
 * @implementation OperationCall If a {@model OperationCall} does not have any explicit pass/fail
 *    {@model ExecutionEdge ExecutionEdges} defined, then the result value is ignored.
 */
«DEFINE executionFlowStep(Boolean operation, model::ExecutionEdgesSource start, model::visual::Frame container, Boolean php) FOR model::operations::OperationCallNode-»
	// virtual operation call "«name-»"

	«REM»
		if we are in javascript, and 
		if the remote operation to call is part of a DomainObject, then
		we need to call it remotely. this is because the JS might be
		out-of-date.
		
		PROBLEM: if we call it remotely, we have to halt execution 
		until the call resumes (since the condition needs to return 'true' or
		'false' as it is inline).
		
		TODO one solution (possibly the best) is to have a polling connection open
		to the server, which sends back results of these necessary synchronous calls
		while they happen. in that way, instead of always blocking, we can get the most
		recent result from the server. (blocking can still happen.)
		
		i.e.:

		1. client script is loaded, with the initial value of 'new_value_exists?'
		2. client script opens up pull ajax, listening for events
		   [...]
		3. event happens on server
		4. server notifies client of new result of 'new_value_exists?'
		5. client updates local cache of 'new_value_exists?' to result
		   [...]
		6. client needs to get result of 'new_value_exists?'
		7. the cached value is used 
		
	«ENDREM»
	«IF !php && model::DomainObjectInstance.isInstance(outActions.typeSelect(model::wires::RunInstanceWire).first().to.eContainer)»

		var function_queue = function(response) {
		 	if (response == "ok") {
				«REM»continue expanding following operations (if any)«ENDREM»
				«FOREACH getPassFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
		 	} else {
				«REM»continue expanding following operations (if any)«ENDREM»
				«FOREACH getFailFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
			}
		};
		
		«FOREACH outActions.typeSelect(model::wires::RunInstanceWire) AS run»
			«IF model::PrimitiveOperation.isInstance(run.to) && ((model::PrimitiveOperation) run.to).name == "exists?"»
				/**
				 * If we are in Javascript and we are trying to get an operation on a DomainObjectInstance (usually 'exists?') 
				 * and we are in a condition, we can't wait for an async result. In this case, we use
				 * cached operation results (stored in Javascript) which can be updated through
				 * callbacks, etc.
				 */
				if (cached_result_«safeName(run.to)»()) {
					function_queue("ok");
				} else {
					function_queue("not ok");
				}
			«ELSE»
				«EXPAND OperationCall::callRemoteOperation(php, false, container) FOREACH outActions.typeSelect(model::wires::RunInstanceWire)-»
			«ENDIF»
		«ENDFOREACH»
	«ELSE»
		«REM»We assume '$result' will be set as the result of this operation call.«ENDREM»
		«EXPAND OperationCall::callOperation(php, false, container) FOREACH outActions.typeSelect(model::wires::RunInstanceWire)-»
		
		«IF getFailFlows().isEmpty || getPassFlows().isEmpty»
			/* No conditional flows; it was just an operation call */
			«FOREACH getFailFlows() AS e-»
				«EXPAND addStack(start, php) FOR e»
			«ENDFOREACH»
			«FOREACH getPassFlows() AS e-»
				«EXPAND addStack(start, php) FOR e»
			«ENDFOREACH»
		«ELSE»		
			/* Condition flow for virtual operation '«name»' */
			if (!«IF php»$result«ELSE»result«ENDIF») {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getFailFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
			} else {
				«REM»continue expanding following conditions (if any)«ENDREM»
				«FOREACH getPassFlows() AS e-»
					«EXPAND addStack(start, php) FOR e»
				«ENDFOREACH»
			}
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

/**
 * Continue operations chained onto the current one.
 * TODO more documentation required. When are chained conditions used?
 *
 * @implementation PrimitiveOperation,ExecutionEdge 
 * 		After a {@model PrimitiveOperation}, all outgoing {@model Wire}s and {@model Action}s 
 *		are executed sequentially.
 */
«DEFINE continueChainedOperations(Boolean php) FOR model::PrimitiveOperation-»
	«EXPAND continueChainedOperations(php) FOREACH outWires»
	«EXPAND continueChainedOperations(php) FOREACH outActions»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::Wire»
	«throwException("Cannot continue a chained operation for Wire " + this)»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::Action»
	«throwException("Cannot continue a chained operation for Action " + this)»
«ENDDEFINE»

«DEFINE continueChainedOperations(Boolean php) FOR model::wires::NavigateWire»
	«IF name != "fail"»
		«IF php»
			«IF model::visual::Frame.isInstance(to)»
			/* prevent infinite loops on the current frame */
			if ("«((model::visual::Frame) to).id»" != CURRENT_PAGE) {
			«ELSE»
			if (true) {
			«ENDIF»
				// navigate to another frame
				$url = "«safeName(to)».php";
				log_message("[redirect] Redirecting to '$url'");
				header("Location: $url");
				die;
			}
		«ELSE»
			// navigate to another frame
			var url = "«safeName(to)».php";
			debug("[redirect] Redirecting to '" + url + "'");
			window.location = url;
			ajaxIncrement();	// prevent other events from executing
		«ENDIF»
	«ELSE»
		// ignoring fail wire
	«ENDIF»
«ENDDEFINE»
