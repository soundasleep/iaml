/**
 * Rules relating to {@model DomainSchema}s.
 */
#created on: 4/11/2008
package org.openiaml.model.drools.rules.domain

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.datatypes.*;

import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.domain.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create a default primary key for DomainObjects which do not have one"

	when
		object : DomainSchema ( )
		type : EXSDDataType( definition != null, 
			eval(functions.equalDataTypes(definition, BuiltinDataTypes.getTypeInteger())))  
		not (da : DomainAttribute ( eContainer == object, primaryKey == true ) )
	
		eval ( handler.veto( object ))
	
	then	
		// create a new one
		DomainAttribute da2 = handler.generatedDomainAttribute(object, object);
		handler.setName(da2, "generated primary key");
		handler.setValue(da2, ModelPackage.eINSTANCE.getDomainAttribute_PrimaryKey(), true);
		handler.setType(da2, type);
		queue.add(da2, drools);

end 

rule "Domain objects that extend each other will also copy over attributes, connected by ExtendsEdges"
	when
		sourceObject : DomainSchema( )
		# don't copy primary keys
		sourceAttribute : DomainAttribute ( eContainer == sourceObject, primaryKey == false )
		
		targetObject : DomainSchema ( this != sourceObject )
		
		ext : ExtendsEdge ( from == targetObject, to == sourceObject )
		
		not ( DomainAttribute ( eContainer == targetObject, name == sourceAttribute.name )) 

		eval ( handler.veto( ext ))
	
	then
		DomainAttribute copy = handler.generatedDomainAttribute(ext, targetObject);
		handler.setName(copy, sourceAttribute.getName());
		handler.setValue(copy, ModelPackage.eINSTANCE.getDomainAttribute_PrimaryKey(), sourceAttribute.isPrimaryKey());
		handler.setType(copy, sourceAttribute.getType());		// copy over type
		queue.add(copy, drools);
		
		// extends wire to maintain relationship
		ExtendsEdge ext2 = handler.generatedExtendsEdge(ext, sourceAttribute, copy, sourceAttribute);
		queue.add(ext2, drools);

end

rule "Domain objects that extend each other should include an indexable reference to the source primary key"
	when
		sourceObject : DomainSchema( )
		
		targetObject : DomainSchema ( this != sourceObject )
		
		ext : ExtendsEdge ( from == targetObject, to == sourceObject )
		
		sourceId : DomainAttribute ( eContainer == sourceObject, primaryKey == true )
		
		not ( 
		da : DomainAttribute ( eContainer == targetObject, primaryKey == false )
		and 
		ExtendsEdge ( from == da, to == sourceId ) ) 

		eval ( handler.veto( ext ))

	then
		# create the target ID attribute
		DomainAttribute id_ref = handler.generatedDomainAttribute(ext, targetObject);
		handler.setName(id_ref, sourceObject.getName() + "." + sourceId.getName());
		handler.setType(id_ref, sourceId.getType());	// copy over type of ID
		queue.add(id_ref, drools);
		
		# and set it as extends to signify relationship
		ExtendsEdge ext2 = handler.generatedExtendsEdge(ext, sourceId, id_ref, sourceId);
		queue.add(ext2, drools);		

end		

