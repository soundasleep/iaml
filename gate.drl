#created on: 4/11/2008
package org.openiaml.model.drools.rules.gate

#list any import classes here.
import org.openiaml.model.drools.*;

import org.openiaml.model.inference.*;
import org.openiaml.model.model.*;
import org.openiaml.model.model.impl.*;
import org.openiaml.model.model.wires.*;
import org.openiaml.model.model.visual.*;
import org.openiaml.model.model.operations.*;
import org.openiaml.model.model.scopes.*;
import org.openiaml.model.model.components.*;
import org.openiaml.model.model.users.*;

#declare any global variables here
global OverridableCreateElementsHelper handler;
global DroolsInsertionQueue queue;
global DroolsHelperFunctions functions;

rule "Create 'Continue' button for Frames connected with 'first' or 'last' or 'fail' ActionEdge"
	when
		gate : Gate ( overridden == false )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" || name == "fail" )
		
		not (Button ( eContainer == target, name == "Continue" ))
		not (ActionEdge ( to == gate ))

	
	then
		Button button = handler.generatedButton(gate, target);
		handler.setName(button, "Continue");
		queue.add(button, drools);

end

rule "Connect 'click' on 'Continue' button to resume Gate"
	when
		gate : Gate ( overridden == false )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" || name == "fail" ) 
		button : Button ( eContainer == target, name == "Continue" )
		
		click : EventTrigger ( button.onClick == click, eContainer == button )
		
		not (ActionEdge ( from == click, to == gate ))
	
	then
		ActionEdge wire = handler.generatedActionEdge(gate, target, click, gate);
		handler.setName(wire, "resume");
		queue.add(wire, drools);

end

rule "Create '(gate) flag' property when Gate is connected by 'first' or 'last'"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session, overridden == false )
		
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		not (Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) ))
	
	then
		Property prop = handler.generatedProperty(gate, session);
		handler.setName(prop, gate.getName() + " flag");
		handler.setValue(prop, ModelPackage.eINSTANCE.getProperty_DefaultValue(), "false");
		queue.add(prop, drools);
	
end

rule "Create 'set flag' operation for Frames connected with 'first' or 'last' ActionEdge"
	when
		gate : Gate ( overridden == false )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		
		not (CompositeOperation ( eContainer == target, name == "Set gate flag" ))

	then
		CompositeOperation op = handler.generatedCompositeOperation(gate, target);
		handler.setName(op, "Set gate flag");
		queue.add(op, drools);

end

rule "Connect 'access' event with 'set flag' operation"
	when
		gate : Gate ( overridden == false )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		op : CompositeOperation ( eContainer == target, name == "Set gate flag" )
		access : EventTrigger ( eContainer == target, target.onAccess == access )
		
		not (ActionEdge ( from == access, to == op ))
		
	then
		ActionEdge run = handler.generatedActionEdge(gate, target, access, op);
		handler.setName(run, "run");
		queue.add(run, drools);

end

rule "Create contents of 'set flag' operation"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session, overridden == false )
		target : Frame ( )
		nav : ActionEdge ( from == gate, to == target, name == "first" || name == "last" )
		button : Button ( eContainer == target, name == "Continue" )
		property : Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) )
		
		op : CompositeOperation ( eContainer == target, name == "Set gate flag" )
		
		not (StartNode ( eContainer == op ))
		
	then
		StartNode start = handler.generatedStartNode(gate, op);
		FinishNode finish = handler.generatedFinishNode(gate, op);
		PrimitiveOperation set = handler.generatedPrimitiveOperation(gate, op);
		handler.setName(set, "set");
		StaticValue value = handler.generatedStaticValue(gate, op);
		handler.setName(value, "true");
		handler.setValue(value, "true");
		
		queue.add(start, drools);
		queue.add(finish, drools);
		queue.add(set, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(gate, op, start, set);
		ExecutionEdge e2 = handler.generatedExecutionEdge(gate, op, set, finish);
		DataFlowEdge d1 = handler.generatedDataFlowEdge(gate, op, value, set);
		DataFlowEdge d2 = handler.generatedDataFlowEdge(gate, op, set, property);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		queue.add(d1, drools);
		queue.add(d2, drools);

end

rule "Create condition 'check (gate)'"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session, overridden == false )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		not ( Condition ( eContainer == session, eval( name.equals("check " + gate.getName())) ))
	
	then
		CompositeCondition cond = handler.generatedCompositeCondition(gate, session);
		handler.setName(cond, "check " + gate.getName());
		queue.add(cond, drools);

end

rule "Connect condition 'check (gate)' with gate"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session, overridden == false )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		
		cond : Condition ( eContainer == session, eval( name.equals("check " + gate.getName())) )
		
		not ( ConditionEdge ( from == cond, to == gate ))

	then
		ConditionEdge cw = handler.generatedConditionEdge(gate, session, cond, gate);
		handler.setName(cw, "condition");
		queue.add(cw, drools);

end

rule "Create contents of 'check (gate)' condition"
	when
		session : Scope ( )
		gate : Gate ( eContainer == session, overridden == false )
		wire : ActionEdge ( from == gate, name == "first" || name == "last" )
		property : Property ( eContainer == session, eval( name.equals(gate.getName() + " flag")) )
		
		cond : CompositeCondition ( eContainer == session, eval( name.equals("check " + gate.getName())) )
		cw : ConditionEdge ( from == cond, to == gate )
		
		not ( StartNode ( eContainer == cond ))

	then
		StartNode start = handler.generatedStartNode(gate, cond);
		FinishNode finish = handler.generatedFinishNode(gate, cond);
		CancelNode cancel = handler.generatedCancelNode(gate, cond);
		DecisionNode cmp = handler.generatedDecisionNode(gate, cond);
		handler.setName(cmp, "true?");
		
		queue.add(start, drools);
		queue.add(finish, drools);
		queue.add(cancel, drools);
		queue.add(cmp, drools);
		
		ExecutionEdge e1 = handler.generatedExecutionEdge(gate, cond, start, cmp);
		ExecutionEdge e2 = handler.generatedExecutionEdge(gate, cond, cmp, finish);
		handler.setName(e2, "y");
		ExecutionEdge e3 = handler.generatedExecutionEdge(gate, cond, cmp, cancel);
		handler.setName(e3, "n");
		DataFlowEdge d1 = handler.generatedDataFlowEdge(gate, cond, property, cmp);
		
		queue.add(e1, drools);
		queue.add(e2, drools);
		queue.add(e3, drools);
		queue.add(d1, drools);

end

/**
 * TODO Should the Provides page be placed into a separate Session if the protected
 * Scope by the Gate is also a Session? The current implementation requires that if the
 * data entered is to be unique, the protected Session will also have to be contained
 * within a Session itself, otherwise the generated Provides Frame will allow access
 * to the private data explicitly.
 */
rule "If an EntryGate requires a Label value, then a Page should be created outside the Scope to enter it"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		not ( provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) ) ) 
	
	then
		Frame provide = handler.generatedFrame(gate, container);
		handler.setName(provide, functions.getEntryGateFrameNameForProvides(label));
		queue.add(provide, drools);
	
end

rule "For EntryGates that require Label values, connect a NavigateWire to the provides Frame"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
		
		# allow other ActionEdges to override this one
		not ( ActionEdge ( from == gate )) 
	
	then
		ActionEdge nav = handler.generatedActionEdge(gate, gate, gate, provide);
		handler.setName(nav, "fail");
		queue.add(nav, drools);
	
end

rule "Create TextFields for all Labels required by an EntryGate"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		not ( VisibleThing ( eContainer == provide, name == label.name ) )

	then
		InputTextField text = handler.generatedInputTextField(gate, provide);
		handler.setName(text, label.getName());
		handler.setType(text, label.getType());
		queue.add(text, drools);
	
end

rule "If an EntryGate requires a Label value, then the 'is set?' Condition in the Label is used as the Gate Condition"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )
		
		cond : Condition ( eContainer == label, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == cond, to == gate ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, cond, gate);
		queue.add(edge, drools);
	
end

rule "If an EntryGate requires a Label, get the containing Scope to update the Label from the expected external source"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )
		value : Property ( field.fieldValue == value )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		not ( ActionEdge ( from == onAccess, to == op ))
	
	then
		ActionEdge run = handler.generatedActionEdge(gate, gate, onAccess, op);
		handler.setName(run, "run");
		queue.add(run, drools);
		
		# connect with Parameter
		ParameterEdge param = handler.generatedParameterEdge(gate, gate, value, run);
		queue.add(param, drools);
	
end

rule "If an EntryGate requires a Label, the Label is only updated externally if the given value has been set"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		# Scope.onAccess --> Label.update()
		run : ActionEdge ( from == onAccess, to == op )
		
		# Text.isSet?
		condition : Condition ( eContainer == field, name == "fieldValue is set" )
		
		not ( ConditionEdge ( from == condition, to == run ))
	
	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, condition, run);
		queue.add(edge, drools);
	
end

rule "If an EntryGate requires a Label, the Label is only updated externally if the given value can be cast to the target type"
	when
		container : Scope ( )
		
		session : Scope ( eContainer == container )
		gate : EntryGate ( eContainer == session, overridden == false )
		
		label : Label ( eContainer == session )		
		requires : RequiresEdge ( from == gate, to == label )

		provide : Frame ( eContainer == container, name != null,
			eval ( functions.getEntryGateFrameNameForProvides(label).equals(provide.getName()) ) )
			
		field : VisibleThing ( eContainer == provide, name == label.name )
		value : Property ( field.fieldValue == value )

		# Scope.onAccess
		onAccess : EventTrigger ( session.onAccess == onAccess )
		
		# Label.update()
		op : Operation ( eContainer == label, name == "update" )
		
		# Scope.onAccess --> Label.update()
		run : ActionEdge ( from == onAccess, to == op )
		
		# Label.can cast?
		condition : Condition ( eContainer == label, name == "can cast?" )
		
		not ( ConditionEdge ( from == condition, to == run ))

	then
		ConditionEdge edge = handler.generatedConditionEdge(gate, gate, condition, run);
		queue.add(edge, drools);
		
		# connect with fieldValue
		ParameterEdge param = handler.generatedParameterEdge(gate, gate, value, edge);
		queue.add(param, drools);
	
end
