«IMPORT iaml»

«EXTENSION metamodel::LoopExtensions»

«DEFINE main FOR model::InternetApplication»
	«FILE "output/check.smv"»

«LET eAllContents.typeSelect(model::operations::StartNode) AS startNodes»
«LET eAllContents.typeSelect(model::operations::FinishNode) AS finishNodes»
«LET eAllContents.typeSelect(model::operations::CancelNode) AS cancelNodes»
«LET eAllContents.typeSelect(model::ActivityNode) AS allNodes»
«LET eAllContents.typeSelect(model::visual::Page) AS allPages»
«LET eAllContents.typeSelect(model::Operation) AS allOperations»
«LET eAllContents.typeSelect(model::visual::Button) AS allButtons»
«LET eAllContents.typeSelect(model::TemporaryVariable) AS allTemporaryVariables»

MODULE main

VAR
	operation_start : { null 
		«FOREACH startNodes AS n»
			, «safeName(n)»
		«ENDFOREACH» };

	operation_end : { null
		-- finish nodes
		«FOREACH finishNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		-- cancel nodes
		«FOREACH cancelNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		};
	
	current_step : { null
		-- nodes
		«FOREACH allNodes AS n»
			, «safeName(n)»
		«ENDFOREACH»
		-- operations
		«FOREACH allOperations AS n»
			, «safeName(n)»
		«ENDFOREACH» 
		};
	
	in_operation : boolean;
	
	current_page : {
		null 
		«FOREACH allPages AS p»
			, «safeName(p)»
		«ENDFOREACH»
	};
	
	-- temporary variables
	«FOREACH allTemporaryVariables AS v»
		«safeName(v)» : 0..«maximumIntegerSize()»;
	«ENDFOREACH»
		
	-- all buttons on all pages
	«FOREACH allButtons AS b»
	click_«safeName(b)» : boolean;
	«ENDFOREACH»
	
	-- value overflow
	value_overflow : boolean;

ASSIGN
	init(operation_start) := null;
	init(operation_end) := null;
	init(current_step) := null;
	init(in_operation) := 0;
	init(value_overflow) := 0;
	
	-- current_page is chosen by nusmv
	-- click_button is chosen by nusmv
	
	-- changes to temporary variables
	«EXPAND nextTemporaryVariable FOREACH allTemporaryVariables»
	
	-- checks for integer overflow
	next(value_overflow) := case
		-- prevent disabling the check
		value_overflow = 1 : 1;
	
		«EXPAND valueOverflowChecks FOREACH allTemporaryVariables»
		
		1 : value_overflow;
	esac;
	
	-- operation flow
	next(current_step) := case
		-- if we are in an operation
		in_operation = 1 : case
			-- nodes
			«EXPAND operationStep(false) FOREACH allNodes»
			-- operations
			«EXPAND operationStep(false) FOREACH allOperations»
		1 : null;
		esac;
		
		-- or an operation needs to start
		-- are we in a page?
		«EXPAND stepPage FOREACH allPages»
		
		-- otherwise, none
		1 : null;
	esac;
	
	-- are we now within an operation?
	next(in_operation) := case
		-- have we finished operations?
		in_operation = 1 : case
			-- finish nodes
			«EXPAND inOperationEnd FOREACH finishNodes»
			-- cancel nodes
			«EXPAND inOperationEnd FOREACH cancelNodes»
			1 : 1;
		esac;
		
		-- are we in a page?
		«EXPAND inOperationPage FOREACH allPages»
		
		-- we weren't in an operation to begin with
		in_operation = 0 : 0;
	esac;
	
	next(operation_start) := case
		-- if we are in an operation, keep operation start
		in_operation = 1 : case
			-- have we finished the operation?
			operation_end != null : null;
			
			1 : operation_start;
		esac;
		
		-- or if we are in a page, operations can start if we click buttons
		«EXPAND operationStartPage FOREACH allPages»
		
		-- otherwise, the operation has not started
		1 : null;
	esac;
	
	next(operation_end) := case
		-- only specify operation_end when the flow has ended
		in_operation = 1 : case
			-- nodes
			«EXPAND operationEnd FOREACH allNodes»			
			-- operations
			«EXPAND operationEnd FOREACH allOperations»			
			1 : null;
		esac;
		1 : null;
	esac;

	-- prevent random changes of the current page between states
	next(current_page) := case
		«EXPAND keepCurrentPage FOREACH allPages»
		current_page = null : null ;
	esac;

«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»

	«ENDFILE»
«ENDDEFINE»

/**
 * Changes to temporary variables.
 */
«DEFINE nextTemporaryVariable FOR model::TemporaryVariable»
next(«safeName()») := case
	in_operation = 1 : case
		-- start of operations
		current_step = «safeName(eContainer)» : 0; -- init

		-- incoming flows
		«FOREACH inFlows.from.typeSelect(model::PrimitiveOperation).select(o | o.name == "set" || o.name == "setValue") AS set»
		current_step = «safeName(set)» :
			-- work out the incoming variable
			«IF set.inFlows.from.size != 1»
				«EXPAND exception FOR throwException("Too many incoming data flows for: " + this)»
			«ENDIF»
			(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
			mod «maximumIntegerSize() + 1» -- prevent integer overflow
			;
		«ENDFOREACH»

		1 : «safeName()»;
	esac;	
	
	-- otherwise, leave it as it is
	1 : «safeName()»;
esac;
«ENDDEFINE»

«DEFINE valueOverflowChecks FOR model::TemporaryVariable»
	in_operation = 1 : case
		-- start of operations
		current_step = «safeName(eContainer)» : value_overflow; -- init

		-- incoming flows
		«FOREACH inFlows.from.typeSelect(model::PrimitiveOperation).select(o | o.name == "set" || o.name == "setValue") AS set»
		current_step = «safeName(set)» :
			-- work out the incoming variable
			«IF set.inFlows.from.size != 1»
				«EXPAND exception FOR throwException("Too many incoming data flows for: " + this)»
			«ENDIF»
			«REM»emulation of a ? b : c«ENDREM»
			case 
				-- if (a) = (a mod limit) then we have not overflown
				(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
				=
				(«EXPAND getTemporaryVariableValue FOR set.inFlows.from.first()»)
				mod «maximumIntegerSize() + 1» : value_overflow;
				-- otherwise, we have
				1 : 1;
			esac;
		«ENDFOREACH»

		1 : value_overflow;
	esac;	
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow source: " + this)»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::operations::Arithmetic»
	«IF operationType.toString() == "ADD"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " + "»
	«ELSEIF operationType.toString() == "SUBTRACT"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " - "»
	«ELSEIF operationType.toString() == "MULTIPLY"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " * "»
	«ELSEIF operationType.toString() == "DIVIDE"»
		«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " / "»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown arithmetic type: " + operationType + " for " + this)»
	«ENDIF»
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::TemporaryVariable»
	«safeName(this)»
	-- another temporary variable
«ENDDEFINE»

«DEFINE getTemporaryVariableValue FOR model::StaticValue»
	«value» 
	-- static value
«ENDDEFINE»

/**
 * Steps between operation nodes.
 */
«DEFINE operationStep(boolean lookingForEnd) FOR emf::EObject»
	«EXPAND exception FOR throwException("Unexpected operation step: " + this)»
«ENDDEFINE»
«DEFINE operationStep(boolean lookingForEnd) FOR model::ActivityNode»
	current_step = «safeName()» : «EXPAND nextOperationStep(lookingForEnd) FOR this»;
«ENDDEFINE»
«DEFINE operationStep(boolean lookingForEnd) FOR model::Operation»
	current_step = «safeName()» : «EXPAND nextOperationStep(lookingForEnd) FOR this»;
«ENDDEFINE»

/**
 * lookingForEnd = true:
 *  if (finishNode or cancelNode) [id of node];
 *  else [null];
 * lookingForEnd = false:
 *  [id of node];
 */
«DEFINE stepOrEnd(boolean lookingForEnd) FOR model::ExecutionEdgeDestination»
	«IF lookingForEnd»
		«IF model::operations::CancelNode.isInstance(this) ||
			model::operations::FinishNode.isInstance(this)»
			«safeName()»
		«ELSE»
			null
		«ENDIF»
	«ELSE»
		«safeName()»
	«ENDIF»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::ActivityNode»
	«EXPAND exception FOR throwException("Cannot expand generic activity node: " + this)»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::Operation»
	«EXPAND exception FOR throwException("Cannot expand generic operation: " + this)»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::StartNode»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::FinishNode»
	null
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::CancelNode»
	null
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::Arithmetic»
	null -- should never be called
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::PrimitiveOperation»
	«REM»TODO can a primitive operation have multiple outgoing edges?«ENDREM»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»
«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::CompositeOperation»
	«REM»TODO can a primitive operation have multiple outgoing edges?«ENDREM»
	«IF outExecutions.size > 0»
		«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
	«ELSE»
	null -- goes nowhere
	«ENDIF»
«ENDDEFINE»

«DEFINE nextOperationStep(boolean lookingForEnd) FOR model::operations::DecisionOperation»
	«IF name=="equal" || name=="equal?"»
		«IF getPassFlow().isEmpty || getFailFlow().isEmpty || inFlows.size < 2»
		-- there are no different pass/fail conditions
			
			«IF outExecutions.size > 0»
				«EXPAND stepOrEnd(lookingForEnd) FOR outExecutions.first().to»
			«ELSE»
			null -- goes nowhere
			«ENDIF»
		
		«ELSEIF inFlows.size > 2»
			«EXPAND exception FOR throwException("Too many inflows for decision operation: " + inFlows.size + " : " + this)»
		«ELSE»
		case
			«EXPAND getTemporaryVariableValue FOREACH inFlows.from SEPARATOR " = "»
				: «EXPAND stepOrEnd(lookingForEnd) FOR getPassFlow().first().to»;
			1 : «EXPAND stepOrEnd(lookingForEnd) FOR getFailFlow().first().to»;
		esac
		«ENDIF»
	«ELSE»
		«EXPAND exception FOR throwException("Unknown decision operation: " + this)»
	«ENDIF»
«ENDDEFINE»

/**
 * We are in a page, and we have clicked a button
 */
«DEFINE stepPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND stepPageButton FOREACH allButtonsOnPage(this)»
		1 : null;
	esac;
«ENDDEFINE»

«DEFINE stepPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			«safeName(((model::CompositeOperation) outRun.first().to).nodes.typeSelect(model::operations::StartNode).first())»
		«ENDLET» ;
«ENDDEFINE»

/**
 * Getting out of in_operation
 */
«DEFINE inOperationEnd FOR model::operations::FinishNode»
		current_step = «safeName()» : 0;
«ENDDEFINE»
«DEFINE inOperationEnd FOR model::operations::CancelNode»
		current_step = «safeName()» : 0;
«ENDDEFINE»

/**
 * Getting into in_operation
 */
«DEFINE inOperationPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND inOperationPageButton FOREACH allButtonsOnPage(this)»
		1 : 0;
	esac;
«ENDDEFINE»

«DEFINE inOperationPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			1
		«ENDLET» ;
«ENDDEFINE»

/**
 * Starting an operation by clicking a button
 */
«DEFINE operationStartPage FOR model::visual::Page»
	current_page = «safeName()» : case
		«EXPAND operationStartPageButton FOREACH allButtonsOnPage(this)»
		1 : null;
	esac;
«ENDDEFINE»

«DEFINE operationStartPageButton FOR model::visual::Button»
	click_«safeName()» = 1 : 
		«LET outEdges.typeSelect(model::wires::RunInstanceWire)
			.select(w|w.name == "click" || w.name == "onClick")
			.select(w|
				w.to != null &&
				model::CompositeOperation.isInstance(w.to) && 
				!((model::CompositeOperation) w.to).nodes.typeSelect(model::operations::StartNode).isEmpty ) AS outRun»
				
			«IF outRun.size > 1»«EXPAND exception FOR throwException("Too many outgoing click edges for button: " + this)»«ENDIF»
			«safeName(((model::CompositeOperation) outRun.first().to).nodes.typeSelect(model::operations::StartNode).first())»
		«ENDLET» ;
«ENDDEFINE»

/**
 * Ending an operation by getting to the end
 */
«DEFINE operationEnd FOR emf::EObject»
		current_step = «safeName()» : null; -- no way to finish from nameless node
«ENDDEFINE»
«DEFINE operationEnd FOR model::ExecutionEdgesSource»
	«EXPAND operationStep(true) FOR this»
«ENDDEFINE»

/**
 * Prevent random switching out of current_page
 * TODO make it so we can navigate without having to click buttons, etc
 */
«DEFINE keepCurrentPage FOR model::visual::Page»
	current_page = «safeName()» : «safeName()»;
«ENDDEFINE»

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540  
 */
«DEFINE exception FOR Object»
«ENDDEFINE»
