«IMPORT iaml»

«EXTENSION template::GeneratorExtensions»

/**
 * @implementation ExitGate
 *    When all incoming {@model Condition Conditions} to an activated {@model ExitGate} fail,
 *    that ExitGate is disabled.
 */    
«DEFINE runExitGate(model::visual::Frame currentFrame) FOR model::components::ExitGate-»
/* exit gate '«safeName()»' */

/* firstly, if we are in the scope that this gate is contained in,
   we need to activate it. */
«IF exitGateNeedsActivating(this, currentFrame)»
	«IF containingSession(this) != null»
		$_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_active"] = true;
	«ELSE»
		set_application_value("«safeNameString(id)»_active", true);
	«ENDIF»
«ELSE»
	// not activated by this frame
«ENDIF»

«REM»ignore gates which are inside the current scope«ENDREM»
«IF !exitGateNeedsToRedirect(this, currentFrame)»
	/* secondly, is this gate activated? (may have been activated just before) */
	if (
	«IF containingSession(this) != null»
		isset($_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_active"]) 
		&& $_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_active"]
	«ELSE»
		get_application_value("«safeNameString(id)»", null) !== null
	«ENDIF»
	) {
		log_message("[exitgate] Checking exit gate «name»");
		
		/* expand conditions - do any of them fail? */
		if (!(
			«EXPAND template::conditions::Runtime::callCondition(true, this, false, currentFrame) FOREACH inConditionEdges SEPARATOR " && "»
		)) {
			// one condition failed
			log_message("[exitgate] Exit gate «name» failed");
			
			// save the current frame, for resuming
			$resume = "«safeName(currentFrame)»";
			«IF containingSession(this) != null»
				$_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_resume"] = $resume;
			«ELSE»
				set_application_value("«safeNameString(id)»_resume", $resume);
			«ENDIF»
			
			// execute gate wires
			«EXPAND template::events::Frame::runGateWires(currentFrame) FOR this»
		} else {
			// otherwise, disable the activation (it has passed at least once)
			log_message("[exitgate] Exit gate «name» passed");
	
			«IF containingSession(this) != null»
				unset($_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_active"]); 
			«ELSE»
				set_application_value("«safeNameString(id)»_active", null);
			«ENDIF»
		}
	
	}
«ENDIF»

«ENDDEFINE»

/**
 * If we have been asked to navigate to the given Gate,
 * where should we resume?
 *
 * Should set '$arg' to the new frame ID, or empty if the resume is not set.
 */
«DEFINE getExitResumeTarget(String arg) FOR model::components::ExitGate»
	«IF containingSession(this) != null»
		$«arg-» = null;
		if (isset($_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_resume"]))
			$«arg-» = $_SESSION["«safeName(containingSession(this))»_«safeNameString(id)»_resume"];
	«ELSE»
		$«arg-» = get_application_value("«safeNameString(id)»_resume", null);
	«ENDIF»

	// check that this is a valid value for this resume
	$is_valid = false;
	«FOREACH getExitResumeTargets(this) AS target»
		if ($«arg-» == "«safeName(target)»")
			$is_valid = true;  
	«ENDFOREACH»
	if (!$is_valid)
		$«arg-» = "";	// reset
«ENDDEFINE»

/**
 * Find _any_ target for the Gate (i.e. the resume has not been set)
 */
«DEFINE getExitAnyTarget(String arg) FOR model::components::ExitGate»
	«IF getExitResumeTargets(this).isEmpty»
		«EXPAND exception FOR throwException("Gate '" + this + "' did not have any possible resume targets")»
	«ENDIF»
	$«arg-» = "«safeName(getExitResumeTargets(this).first())»"; 
«ENDDEFINE»

/** 
 * a hack way to create backtrace-able errors
 * based on http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=5540  
 */
«DEFINE exception FOR Object»
«ENDDEFINE»

