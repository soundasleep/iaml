«IMPORT iaml»

/**
 * Methods for casting instances of inherited domain objects.
 */
«EXTENSION template::GeneratorExtensions»

«DEFINE allCasts FOR model::DomainObject»
	«REM»expand self cast«ENDREM»
	«EXPAND castSourceAsTarget(this) FOR this»
	«EXPAND updateInstanceAttributeFrom FOR this»
	
	«LET inExtendsEdges.from.typeSelect(model::DomainObject) AS subclasses»
		«REM»expand all direct extends«ENDREM»
		«FOREACH subclasses AS target»
			«EXPAND castSourceAsTarget(target) FOR this»
			«EXPAND getSubclassInstance(target) FOR this»
		«ENDFOREACH»
		«REM»and all other roles, so we can cast between any two abritrary instances«ENDREM»
		«FOREACH getDomainStore().eAllContents.typeSelect(model::DomainObject).without(subclasses).remove(this) AS target»
			«EXPAND castSourceAsTargetOther(target) FOR this»
		«ENDFOREACH»
	«ENDLET»
«ENDDEFINE»

«DEFINE castSourceAsTarget(model::DomainObject target) FOR model::DomainObject»
/**
 * Try to cast a '«name»' into a subclass '«target.name»'. 
 *
 * Returns an instance of '«target.name»' with all accumulated attributes of
 * '«name»' and the heirarchy of subclasses, or <b>null</b> if it
 * could not be cast.
 */
function cast_«safeName()»_as_«safeName(target)»($instance) {
	«IF this == target»
		/* same instance; return immediately */
		return $instance;
	«ELSE»
		log_message("[cast] Casting '«name»' into subclass '«target.name»'...");
		«FOREACH inExtendsEdges.from.typeSelect(model::DomainObject) AS subclass»
			«IF allSubtypes(subclass).contains(target)»
			«LET attributes.selectFirst(a | a.primaryKey) AS sourceKey»
				«LET subclass.attributes.select(a | !a.outExtendsEdges.to.select( a | a == sourceKey ).isEmpty).first() AS targetKey»
					log_message("[cast] Attempting cast into '«subclass.name»'");
					$source_value = $instance["«safeNameString(sourceKey.name)»"];

					«EXPAND Select::selectDatabase FOR subclass»
					
					$query = "SELECT * FROM «safeNameString(subclass.name)» WHERE
						«safeNameString(targetKey.name)» = ?";

					$args = array($source_value);
					
					log_message("Selecting instance for cast from «name» to «target.name»: '$query', args = " . print_r($args, true));
					
					$db_query = new DatabaseQuery($db_name);
					$new_instance = $db_query->fetchFirst($query, $args);
					if ($new_instance !== null) {
						// we found an instance!
						log_message("Found instance: " . print_r($new_instance, true));
						 
						// add $instance to $new_instance
						foreach ($instance as $key => $value) {
							if (isset($new_instance[$key])) {
								$new_instance["«safeNameString(this.name)»." . $key] = $value;
							} else {
								$new_instance[$key] = $value;
							}
						}
						
						// continue casting call
						return cast_«safeName(subclass)»_as_«safeName(target)»($new_instance);
					}
				«ENDLET»
			«ENDLET»
			«ELSE»
				// subclass '«subclass.name»' does not contain a path to '«target.name»'
			«ENDIF»
		«ENDFOREACH»
	«ENDIF»
	
	// could not find any result
	log_message("[cast] Could not find any result for '«name»'");
	return null;
}
«ENDDEFINE»

«DEFINE castSourceAsTargetOther(model::DomainObject target) FOR model::DomainObject»
/**
 * Try to cast a '«name»' into a subclass '«target.name»'. 
 *
 * However, '«name»' and '«target.name»' are not related directly, 
 * so we will try all of the supertypes of '«name»'.
 *
 * Returns an instance of '«target.name»' with all accumulated attributes of
 * '«name»' and the heirarchy of subclasses, or <b>null</b> if it
 * could not be cast.
 */
function cast_«safeName()»_as_«safeName(target)»($instance) {
	«IF this == target»
		«throwException("Cannot castSourceAsTargetOther with the same instances")»
	«ELSE»
		«IF allSubtypes().contains(target)»
			// '«target.name»' is a direct subtype of '«name»'
			«LET inExtendsEdges.to.typeSelect(model::DomainObject).selectFirst( a | allSubtypes(a).contains(target) ) AS firstSubtype»
				// the first subtype that has a path: «firstSubtype.name»
				$new_instance = cast_«safeName()»_as_«safeName(firstSubtype)»($instance);
				if ($new_instance === null) {
					// none could be found
					return null;
				}
				
				// continue subtype casting
				return cast_«safeName(firstSubtype)»_as_«safeName(target)»($new_instance);
			«ENDLET»
		«ELSE»
			// '«target.name»' is not direct subtype of '«name»'
			// try all of the supertypes of '«name»'
			«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS superclass»
				// subclass '«superclass.name»'
				$superclass_instance = get_subclass_«safeName(superclass)»_from_«safeName()»($instance);
				if ($superclass_instance != null) {
					// continue supertype casting
					return cast_«safeName(superclass)»_as_«safeName(target)»($superclass_instance);
				}
			«ENDFOREACH»
		«ENDIF»
	«ENDIF»
	
	// none found
	return null;
}
«ENDDEFINE»

«DEFINE getSubclassInstance(model::DomainObject source) FOR model::DomainObject»
/**
 * Try to get the instance of the superclass '«name»' from the subclass
 * '«source.name»'.
 *
 * Returns an instance of only '«name»', or <b>null</b> if it
 * could not be retrieved.
 */
function get_subclass_«safeName()»_from_«safeName(source)»($instance) {
	«EXPAND Select::selectDatabase FOR this»
	
	$source_id = "«safeName()-»";
	$source_class = "«safeNameString(name)-»";
	$query = "«safeNameString(name)».«safeNameString(getPrimaryKey().name)» = ?";
	$args = array($instance["«safeNameString(source.attributes.selectFirst( a | !a.outExtendsEdges.select(e | e.to == getPrimaryKey()).isEmpty).name)-»"]);
	
	// fetch the instance
	$subclass_instance = evaluate_select_wire($db_name,
		$source_id,
		$source_class,
		$query,
		$args);
	
	return $subclass_instance;
}
«ENDDEFINE»

«DEFINE updateInstanceAttributeFrom FOR model::DomainObject»
/**
 * Try to update an attribute in an instance of '«name»'. Will
 * try subclasses if this attribute does not exist.
 *
 * Will only update one attribute, and will bail once this attribute
 * has been found.
 *
 * Returns the db_query if the attribute update was successful; null if not.
 */
function update_«safeName()»_attribute_instance($instance, $attribute_name, $arg0) {
	«LET attributes.selectFirst(a | a.primaryKey) AS pk»
		// properties for '«name»'
		if (!isset($instance["«safeNameString(pk.name)»"]))
			throw new IamlRuntimeException("instance[«safeNameString(pk.name)»] was not set");
		$source_value = $instance["«safeNameString(pk.name)»"];
			
		«EXPAND Select::selectDatabase»

		$attribute_name_resolved = null;
		«REM»only select attributes which are not extensions of subclass attributes«ENDREM»
		«FOREACH attributes.select(a | a.outExtendsEdges.to.typeSelect(model::DomainAttribute).isEmpty) AS targetAttribute»
		if ($attribute_name == '«safeNameString(targetAttribute.name)»') {
			/* in self instance */
			$attribute_name_resolved = '«safeNameString(targetAttribute.name)»'; 
			log_message("[update attribute instance] Resolved attribute '$attribute_name' as '$attribute_name_resolved'");
		}
		«ENDFOREACH»
		
		// have we resolved the attribute?
		if ($attribute_name_resolved !== null) {
			«REM»
				ideally we would use a query "UPDATE .. LIMIT 1 OFFSET (int) $offset"
				but PHP's SQlite does not define SQLITE_ENABLE_UPDATE_DELETE_LIMIT.
				as a result, this query is not available.
				
				TODO when migrating to a different database, this approach should
				be used instead.
			«ENDREM»
			$query = "UPDATE «safeNameString(name)»
				SET $attribute_name_resolved = ?
				WHERE «safeNameString(pk.name)» = ?";

			$args = array($arg0, $source_value);
			log_message("[update attribute instance] Updating attribute '$attribute_name_resolved' to '$arg0'");
		
			// update the current instance
			$db_query = new DatabaseQuery($db_name);
			$db_query->execute($query, $args);
			
			// and mark update as finished
			return $db_query;
		}
					
		// we haven't; try all the subclasses of '«name»'
		«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS targetSubclass»
		{
			/* subclass '«targetSubclass.name»' */
			// first, get the instance of this subclass
			
			$subclass_instance = get_subclass_«safeName(targetSubclass)»_from_«safeName()»($instance);
		
			if ($subclass_instance === null)
				throw new IamlRuntimeException("Could not get subclass '$source_class' from '«safeNameString(name)»': no results found for query '$query'");
		
			// try updating this instance
			$db_query = update_«safeName(targetSubclass)»_attribute_instance($subclass_instance, $attribute_name, $arg0);
			if ($db_query !== null)
				return $db_query;
		}
		«ENDFOREACH»
			
		// could not find the attribute at all in this superclass
		return null;
	«ENDLET»
}
«ENDDEFINE»

«REM»

we want this method to return _all_ joins for this object, not just
those which are directly inherited

direct_joins("doctoral") = array(
	"teacher" => "join teacher on teacher.id = doctoral.t_id",
	"student" => "join student on student.id = doctoral.s_id",
)

«ENDREM»

«DEFINE defineInheritanceJoins FOR model::DomainObject»
 	/* «safeNameString(name)» */ 
	$direct_joins["«safeNameString(id)»"] = array(
		
		«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS parent»
			«REM»find the PK of the parent object«ENDREM»
			«LET parent.attributes.select(a | a.primaryKey).first() AS parentPK»				
				«REM»find the corresponding FK of this current object«ENDREM»
				«LET attributes.select(a | a.outExtendsEdges.to.contains(parentPK)).first() AS fk»
					"«safeNameString(parent.id)»" => 
					"JOIN «safeNameString(parent.name)» ON
						«safeNameString(parent.name)».«safeNameString(parentPK.name)» 
						= «safeNameString(name)».«safeNameString(fk.name)»",
				«ENDLET»
			«ENDLET» 
		«ENDFOREACH»
		 
	); 
«ENDDEFINE»

«DEFINE createNewInstanceRecursively FOR model::DomainObject»
/**
 * Create a new domain object instance of '«safeNameString(name)»' recursively.
 * Sets primary keys to FKs as necessary.
 *
 * Return the newly created instance, complete with its newly
 * created primary key and resolved superclasses.
 */
function create_new_instance_«safeName()»() {
	log_message("Creating new instance of '«safeNameString(name)»'");

	// create all superclasses first
	$superclasses = array();
	«FOREACH outExtendsEdges.to.typeSelect(model::DomainObject) AS superclass»
		// superclass '«safeNameString(superclass.name)»'
		$superclass = create_new_instance_«safeName(superclass)»();
		
		// update the FK
		«LET superclass.attributes.selectFirst( a | a.primaryKey) AS primaryKey»
			«LET attributes.selectFirst(a | a.outExtendsEdges.to.contains(primaryKey)) AS foreignKey»
				$superclasses["«safeNameString(foreignKey.name)»"] = $superclass["«safeNameString(primaryKey.name)»"];
			«ENDLET»
		«ENDLET»
	«ENDFOREACH»
	
	// where are we loading it from? sets $db_name
	«EXPAND Select::selectDatabase FOR this»
	
	// create query
	$query = "INSERT INTO «safeNameString(name)» DEFAULT VALUES";
		
	// execute			
	$db_query = new DatabaseQuery($db_name);
	$db = $db_query->execute($query, array());

	// get the inserted id
	$new_id = $db->lastInsertId("«attributeName(getPrimaryKey(this))-»");
	log_message("New instance of '«safeNameString(name)»' insert ID: '$new_id'");
	
	// update with superclasses
	foreach ($superclasses as $fk => $pk) {
		$query = "UPDATE «safeNameString(name)»
			SET $fk = ?
			WHERE «attributeName(getPrimaryKey(this))-» = ?";
		$args = array($pk, $new_id);
		
		$db_query->execute($query, $args); 
	}
	
	// get this new instance along with subclasses
	$new_instance = evaluate_select_wire(
		$db_name,
		'«safeNameString(id)»',
		'«safeNameString(name)»',
		'«safeNameString(name)».«attributeName(getPrimaryKey(this))-» = ?',
		array($new_id)
	);
	
	if ($new_instance === null) {
		throw new IamlRuntimeException("Could not retrieve newly created instance of '«safeNameString(name)»' (ID = $new_id)");
	}
	
	// update the PK of this instance manually (a bit of a hack)
	$new_instance['«attributeName(getPrimaryKey(this))-»'] = $new_id;
	
	return $new_instance;	
}
«ENDDEFINE»
