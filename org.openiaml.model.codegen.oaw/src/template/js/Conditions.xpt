«IMPORT iaml»

«EXTENSION template::GeneratorExtensions»

«DEFINE conditionWires(model::wires::RunInstanceWire wire, boolean inline) FOR model::wires::ConditionWire»
	/* ConditionWire: «this-» */
	condition_«conditionName(from)»(
		«EXPAND Operations::callOperationParameters(wire, inline) FOREACH inEdges.typeSelect(model::wires::ParameterWire) SEPARATOR ", "»
	)
«ENDDEFINE»

/* expand out the conditions for the page */
«DEFINE expandConditions FOR model::ContainsConditions»
	«EXPAND expandCondition FOREACH getRoot().getAllConditions()»
«ENDDEFINE»

«DEFINE expandCondition FOR model::Condition-»
	«EXPAND exception FOR throwException("Cannot expand an abstract Condition: " + this)»
«ENDDEFINE»

«DEFINE expandCondition FOR model::operations::DecisionCondition»
	«REM»
		DecisionCondition is not expanded here; it is expanded as part of the
		execution flow. (this is only called for all conditions in the InternetApplication.)
	«ENDREM»
«ENDDEFINE»

«DEFINE expandCondition FOR model::CompositeCondition»
	/** composite condition "«name»" */
	function condition_«safeName()»(«EXPAND expandParameters FOREACH parameters SEPARATOR ", "-») {
		«REM»here we would expand out the data flow of the condition, etc«ENDREM»
				
		«EXPAND doExecutionFlow FOR startNodeCondition()-»

		return false;
	}
«ENDDEFINE»

«DEFINE expandCondition FOR model::operations::DecisionCondition»
	/** decision condition "«name»" */
	function decision_condition_«safeName()»() {
		«IF name=="xpathMatch"»
			
		«ELSE»
			«EXPAND exception FOR throwException("Cannot expand DecisionCondition '" + name + "': " + name)»
		«ENDIF»
	}
«ENDDEFINE»

«DEFINE expandParameters FOR model::Parameter-»
	«safeName()-»
«ENDDEFINE»

/* I don't know how in JS we are supposed to handle multiple out edges yet... but we'll get there ;) */
«DEFINE doExecutionFlow FOR model::operations::StartNode-»
	// flow starts here
	«FOREACH outExecutions AS e-»
		«EXPAND doExecutionFlowNext FOR e.to-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE doExecutionFlow FOR model::ActivityNode-»
	// nothing for an activity node
«ENDDEFINE»

/* an edge that is the end (both StartNode and FinishNode also fall into this) */
«DEFINE doExecutionFlowNext FOR model::ExecutionEdgeDestination-»
	// do nothing «this-»
«ENDDEFINE»

«DEFINE doExecutionFlowNext FOR model::operations::DecisionCondition»
	// DecisionCondition «this»
	«IF name=="xpathMatch"»
		if (!xpathMatch(«EXPAND getInflows FOREACH inFlows SEPARATOR ","»)) {
			«REM»continue expanding following conditions (if any)«ENDREM»
			«FOREACH getFailEdges() AS e-»
				«EXPAND doExecutionFlowNext FOR e.to-»
			«ENDFOREACH»
		} else {
			«REM»continue expanding following conditions (if any)«ENDREM»
			«FOREACH getPassEdges() AS e-»
				«EXPAND doExecutionFlowNext FOR e.to-»
			«ENDFOREACH»
		}
	«ELSE»
		«REM»unknown condition«ENDREM»
		«EXPAND exception FOR throwException("Cannot expand DecisionCondition '" + name + "': " + this)»
	«ENDIF»
«ENDDEFINE»

«DEFINE doExecutionFlowNext FOR model::operations::CancelNode-»
	return false; /* condition failed: «exceptionText» */
«ENDDEFINE»

«DEFINE doExecutionFlowNext FOR model::operations::FinishNode-»
	return true; /* condition passed */
«ENDDEFINE»

/* data flows in */
«DEFINE getInflows FOR model::DataFlowEdge-»
	«EXPAND inflowTarget FOR from-»
«ENDDEFINE»

«DEFINE inflowTarget FOR model::DataFlowEdgesSource»
	«EXPAND exception FOR throwException("Unknown data flow edge source for setPropertyToValue: " + this)»
«ENDDEFINE»

// TODO need to wrap value in some sort of encoding algorithm
«DEFINE inflowTarget FOR model::StaticValue»
	"«value-»" /* static value "«safeName()-»" */ 
«ENDDEFINE»

«DEFINE inflowTarget FOR model::Parameter»
	«safeName()»
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»