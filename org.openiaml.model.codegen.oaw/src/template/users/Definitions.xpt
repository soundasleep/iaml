«IMPORT iaml»

/**
 * Method definitions for access control handlers.
 */
«EXTENSION template::GeneratorExtensions»

/**
 * Expand out all domain object instances.
 */
«DEFINE accessControlHandlerDefinitions(Boolean php) FOR model::scopes::Session»
	«IF php»
		«REM»TODO clean up the metamodel, as an ACH can be either in 'children' or 'components' right now«ENDREM»
		«EXPAND checkAccessDefinition FOREACH children.typeSelect(model::components::AccessControlHandler)»
		«EXPAND checkAccessDefinition FOREACH components.typeSelect(model::components::AccessControlHandler)»
	«ELSE»
		/* no client-side access control handler definitions */
	«ENDIF»
«ENDDEFINE»

/**
 * Definition of the access_control_permissions_check_*() method.
 * Expected to be in PHP.
 */
«DEFINE checkAccessDefinition FOR model::components::AccessControlHandler»
	/**
	 * Definition of access control handler '«name»'
	 */
	function access_control_permissions_check_«safeNameString(id)»() {
		«REM»find the desired UserInstance to check against«ENDREM»
		«REM»there should be exactly one incoming parameter wire with a UserInstance«ENDREM»
		«LET inEdges.typeSelect(model::wires::ParameterWire).from.typeSelect(model::users::UserInstance).first() AS user»
			«EXPAND checkAccessDefinition(user) FOR this»
		«ENDLET»
	}
«ENDDEFINE»

«REM»
function check_role(initialRole, targetRole, $instance)
		
if initialRole == targetRole
	return true;
else
	foreach subclass of initialRole
		attribute source_key = initialRole.primaryKey;
		attribute target_key = subclass.attributes( k | k extends source_key )
		$source_key_value = $instance[source_key];
		$new_instance = select * from subclass where target_key = ? ($source_key_value);
		
		if (instance)
			return check_role(subclass, targetRole, $new_instance); 
		else
			return false;
			
...

why not a cast_domain_object_as() method?

see: template::domain::DomainInheritance
«ENDREM»

/**
 * We now have a UserInstance on which to validate against
 */
«DEFINE checkAccessDefinition(model::users::UserInstance user) FOR model::components::AccessControlHandler»
	$instance = get_object_instance_«inEdges.typeSelect(model::wires::ParameterWire).from.first().safeName()»();
	if (!$instance)
		throw new IamlRuntimeException("Unexpected empty UserInstance; has the user logged in?");

	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Role) AS targetRole»
		«LET user.inEdges.typeSelect(model::wires::SelectWire).from.typeSelect(model::DomainObject).first() AS initialRole»
			/* check role '«targetRole»' */
			if (cast_«safeName(initialRole)»_as_«safeName(targetRole)»($instance) == null) {
				throw new IamlRuntimeException("Source role '«initialRole.name»' could not be translated into '«targetRole.name»'");
			} else {
				// can be cast fine
			}
		«ENDLET»
	«ENDFOREACH»
	
	/* check permissions */
	«FOREACH outEdges.typeSelect(model::wires::RequiresWire).to.typeSelect(model::users::Permission) AS targetPermission»
		«EXPAND exception FOR throwException("Permission logic not yet implemented")»
	«ENDFOREACH»
	
	/* check is successful */
	return true;
«ENDDEFINE»

«DEFINE exception FOR Object»
«ENDDEFINE»
